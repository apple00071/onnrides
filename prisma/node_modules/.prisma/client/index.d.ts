
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AdminNotification
 * 
 */
export type AdminNotification = $Result.DefaultSelection<Prisma.$AdminNotificationPayload>
/**
 * Model DeliveryBooking
 * 
 */
export type DeliveryBooking = $Result.DefaultSelection<Prisma.$DeliveryBookingPayload>
/**
 * Model DeliveryPartner
 * 
 */
export type DeliveryPartner = $Result.DefaultSelection<Prisma.$DeliveryPartnerPayload>
/**
 * Model DeliveryTracking
 * 
 */
export type DeliveryTracking = $Result.DefaultSelection<Prisma.$DeliveryTrackingPayload>
/**
 * Model booking_history
 * 
 */
export type booking_history = $Result.DefaultSelection<Prisma.$booking_historyPayload>
/**
 * Model bookings
 * 
 */
export type bookings = $Result.DefaultSelection<Prisma.$bookingsPayload>
/**
 * Model coupons
 * 
 */
export type coupons = $Result.DefaultSelection<Prisma.$couponsPayload>
/**
 * Model document_submissions
 * 
 */
export type document_submissions = $Result.DefaultSelection<Prisma.$document_submissionsPayload>
/**
 * Model documents
 * 
 */
export type documents = $Result.DefaultSelection<Prisma.$documentsPayload>
/**
 * Model email_logs
 * 
 */
export type email_logs = $Result.DefaultSelection<Prisma.$email_logsPayload>
/**
 * Model locations
 * 
 */
export type locations = $Result.DefaultSelection<Prisma.$locationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model profiles
 * 
 */
export type profiles = $Result.DefaultSelection<Prisma.$profilesPayload>
/**
 * Model reviews
 * 
 */
export type reviews = $Result.DefaultSelection<Prisma.$reviewsPayload>
/**
 * Model settings
 * 
 */
export type settings = $Result.DefaultSelection<Prisma.$settingsPayload>
/**
 * Model sms_logs
 * 
 */
export type sms_logs = $Result.DefaultSelection<Prisma.$sms_logsPayload>
/**
 * Model trip_initiations
 * 
 */
export type trip_initiations = $Result.DefaultSelection<Prisma.$trip_initiationsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model vehicles
 * 
 */
export type vehicles = $Result.DefaultSelection<Prisma.$vehiclesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const vehicle_status: {
  active: 'active',
  maintenance: 'maintenance',
  retired: 'retired'
};

export type vehicle_status = (typeof vehicle_status)[keyof typeof vehicle_status]

}

export type vehicle_status = $Enums.vehicle_status

export const vehicle_status: typeof $Enums.vehicle_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AdminNotifications
 * const adminNotifications = await prisma.adminNotification.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AdminNotifications
   * const adminNotifications = await prisma.adminNotification.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.adminNotification`: Exposes CRUD operations for the **AdminNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminNotifications
    * const adminNotifications = await prisma.adminNotification.findMany()
    * ```
    */
  get adminNotification(): Prisma.AdminNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryBooking`: Exposes CRUD operations for the **DeliveryBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryBookings
    * const deliveryBookings = await prisma.deliveryBooking.findMany()
    * ```
    */
  get deliveryBooking(): Prisma.DeliveryBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryPartner`: Exposes CRUD operations for the **DeliveryPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryPartners
    * const deliveryPartners = await prisma.deliveryPartner.findMany()
    * ```
    */
  get deliveryPartner(): Prisma.DeliveryPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryTracking`: Exposes CRUD operations for the **DeliveryTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryTrackings
    * const deliveryTrackings = await prisma.deliveryTracking.findMany()
    * ```
    */
  get deliveryTracking(): Prisma.DeliveryTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking_history`: Exposes CRUD operations for the **booking_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Booking_histories
    * const booking_histories = await prisma.booking_history.findMany()
    * ```
    */
  get booking_history(): Prisma.booking_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookings`: Exposes CRUD operations for the **bookings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.bookings.findMany()
    * ```
    */
  get bookings(): Prisma.bookingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupons`: Exposes CRUD operations for the **coupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupons.findMany()
    * ```
    */
  get coupons(): Prisma.couponsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document_submissions`: Exposes CRUD operations for the **document_submissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Document_submissions
    * const document_submissions = await prisma.document_submissions.findMany()
    * ```
    */
  get document_submissions(): Prisma.document_submissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.documentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email_logs`: Exposes CRUD operations for the **email_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_logs
    * const email_logs = await prisma.email_logs.findMany()
    * ```
    */
  get email_logs(): Prisma.email_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.locationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profiles`: Exposes CRUD operations for the **profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profiles.findMany()
    * ```
    */
  get profiles(): Prisma.profilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.reviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sms_logs`: Exposes CRUD operations for the **sms_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sms_logs
    * const sms_logs = await prisma.sms_logs.findMany()
    * ```
    */
  get sms_logs(): Prisma.sms_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trip_initiations`: Exposes CRUD operations for the **trip_initiations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trip_initiations
    * const trip_initiations = await prisma.trip_initiations.findMany()
    * ```
    */
  get trip_initiations(): Prisma.trip_initiationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicles`: Exposes CRUD operations for the **vehicles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicles.findMany()
    * ```
    */
  get vehicles(): Prisma.vehiclesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AdminNotification: 'AdminNotification',
    DeliveryBooking: 'DeliveryBooking',
    DeliveryPartner: 'DeliveryPartner',
    DeliveryTracking: 'DeliveryTracking',
    booking_history: 'booking_history',
    bookings: 'bookings',
    coupons: 'coupons',
    document_submissions: 'document_submissions',
    documents: 'documents',
    email_logs: 'email_logs',
    locations: 'locations',
    payments: 'payments',
    profiles: 'profiles',
    reviews: 'reviews',
    settings: 'settings',
    sms_logs: 'sms_logs',
    trip_initiations: 'trip_initiations',
    users: 'users',
    vehicles: 'vehicles'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "adminNotification" | "deliveryBooking" | "deliveryPartner" | "deliveryTracking" | "booking_history" | "bookings" | "coupons" | "document_submissions" | "documents" | "email_logs" | "locations" | "payments" | "profiles" | "reviews" | "settings" | "sms_logs" | "trip_initiations" | "users" | "vehicles"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AdminNotification: {
        payload: Prisma.$AdminNotificationPayload<ExtArgs>
        fields: Prisma.AdminNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          findFirst: {
            args: Prisma.AdminNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          findMany: {
            args: Prisma.AdminNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>[]
          }
          create: {
            args: Prisma.AdminNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          createMany: {
            args: Prisma.AdminNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>[]
          }
          delete: {
            args: Prisma.AdminNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          update: {
            args: Prisma.AdminNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          deleteMany: {
            args: Prisma.AdminNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>[]
          }
          upsert: {
            args: Prisma.AdminNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotificationPayload>
          }
          aggregate: {
            args: Prisma.AdminNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminNotification>
          }
          groupBy: {
            args: Prisma.AdminNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<AdminNotificationCountAggregateOutputType> | number
          }
        }
      }
      DeliveryBooking: {
        payload: Prisma.$DeliveryBookingPayload<ExtArgs>
        fields: Prisma.DeliveryBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>
          }
          findFirst: {
            args: Prisma.DeliveryBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>
          }
          findMany: {
            args: Prisma.DeliveryBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>[]
          }
          create: {
            args: Prisma.DeliveryBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>
          }
          createMany: {
            args: Prisma.DeliveryBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>[]
          }
          delete: {
            args: Prisma.DeliveryBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>
          }
          update: {
            args: Prisma.DeliveryBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBookingPayload>
          }
          aggregate: {
            args: Prisma.DeliveryBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryBooking>
          }
          groupBy: {
            args: Prisma.DeliveryBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryBookingCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryBookingCountAggregateOutputType> | number
          }
        }
      }
      DeliveryPartner: {
        payload: Prisma.$DeliveryPartnerPayload<ExtArgs>
        fields: Prisma.DeliveryPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>
          }
          findFirst: {
            args: Prisma.DeliveryPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>
          }
          findMany: {
            args: Prisma.DeliveryPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>[]
          }
          create: {
            args: Prisma.DeliveryPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>
          }
          createMany: {
            args: Prisma.DeliveryPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>[]
          }
          delete: {
            args: Prisma.DeliveryPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>
          }
          update: {
            args: Prisma.DeliveryPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryPartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPartnerPayload>
          }
          aggregate: {
            args: Prisma.DeliveryPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryPartner>
          }
          groupBy: {
            args: Prisma.DeliveryPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryPartnerCountAggregateOutputType> | number
          }
        }
      }
      DeliveryTracking: {
        payload: Prisma.$DeliveryTrackingPayload<ExtArgs>
        fields: Prisma.DeliveryTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>
          }
          findFirst: {
            args: Prisma.DeliveryTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>
          }
          findMany: {
            args: Prisma.DeliveryTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>[]
          }
          create: {
            args: Prisma.DeliveryTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>
          }
          createMany: {
            args: Prisma.DeliveryTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>[]
          }
          delete: {
            args: Prisma.DeliveryTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>
          }
          update: {
            args: Prisma.DeliveryTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTrackingPayload>
          }
          aggregate: {
            args: Prisma.DeliveryTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryTracking>
          }
          groupBy: {
            args: Prisma.DeliveryTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTrackingCountAggregateOutputType> | number
          }
        }
      }
      booking_history: {
        payload: Prisma.$booking_historyPayload<ExtArgs>
        fields: Prisma.booking_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.booking_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.booking_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>
          }
          findFirst: {
            args: Prisma.booking_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.booking_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>
          }
          findMany: {
            args: Prisma.booking_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>[]
          }
          create: {
            args: Prisma.booking_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>
          }
          createMany: {
            args: Prisma.booking_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.booking_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>[]
          }
          delete: {
            args: Prisma.booking_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>
          }
          update: {
            args: Prisma.booking_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>
          }
          deleteMany: {
            args: Prisma.booking_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.booking_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.booking_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>[]
          }
          upsert: {
            args: Prisma.booking_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_historyPayload>
          }
          aggregate: {
            args: Prisma.Booking_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking_history>
          }
          groupBy: {
            args: Prisma.booking_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Booking_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.booking_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Booking_historyCountAggregateOutputType> | number
          }
        }
      }
      bookings: {
        payload: Prisma.$bookingsPayload<ExtArgs>
        fields: Prisma.bookingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          findFirst: {
            args: Prisma.bookingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          findMany: {
            args: Prisma.bookingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>[]
          }
          create: {
            args: Prisma.bookingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          createMany: {
            args: Prisma.bookingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bookingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>[]
          }
          delete: {
            args: Prisma.bookingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          update: {
            args: Prisma.bookingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          deleteMany: {
            args: Prisma.bookingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bookingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bookingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>[]
          }
          upsert: {
            args: Prisma.bookingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          aggregate: {
            args: Prisma.BookingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookings>
          }
          groupBy: {
            args: Prisma.bookingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookingsCountArgs<ExtArgs>
            result: $Utils.Optional<BookingsCountAggregateOutputType> | number
          }
        }
      }
      coupons: {
        payload: Prisma.$couponsPayload<ExtArgs>
        fields: Prisma.couponsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.couponsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.couponsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          findFirst: {
            args: Prisma.couponsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.couponsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          findMany: {
            args: Prisma.couponsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>[]
          }
          create: {
            args: Prisma.couponsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          createMany: {
            args: Prisma.couponsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.couponsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>[]
          }
          delete: {
            args: Prisma.couponsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          update: {
            args: Prisma.couponsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          deleteMany: {
            args: Prisma.couponsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.couponsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.couponsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>[]
          }
          upsert: {
            args: Prisma.couponsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsPayload>
          }
          aggregate: {
            args: Prisma.CouponsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupons>
          }
          groupBy: {
            args: Prisma.couponsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponsGroupByOutputType>[]
          }
          count: {
            args: Prisma.couponsCountArgs<ExtArgs>
            result: $Utils.Optional<CouponsCountAggregateOutputType> | number
          }
        }
      }
      document_submissions: {
        payload: Prisma.$document_submissionsPayload<ExtArgs>
        fields: Prisma.document_submissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.document_submissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.document_submissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>
          }
          findFirst: {
            args: Prisma.document_submissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.document_submissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>
          }
          findMany: {
            args: Prisma.document_submissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>[]
          }
          create: {
            args: Prisma.document_submissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>
          }
          createMany: {
            args: Prisma.document_submissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.document_submissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>[]
          }
          delete: {
            args: Prisma.document_submissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>
          }
          update: {
            args: Prisma.document_submissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>
          }
          deleteMany: {
            args: Prisma.document_submissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.document_submissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.document_submissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>[]
          }
          upsert: {
            args: Prisma.document_submissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$document_submissionsPayload>
          }
          aggregate: {
            args: Prisma.Document_submissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument_submissions>
          }
          groupBy: {
            args: Prisma.document_submissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Document_submissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.document_submissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Document_submissionsCountAggregateOutputType> | number
          }
        }
      }
      documents: {
        payload: Prisma.$documentsPayload<ExtArgs>
        fields: Prisma.documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findFirst: {
            args: Prisma.documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findMany: {
            args: Prisma.documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          create: {
            args: Prisma.documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          createMany: {
            args: Prisma.documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.documentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          delete: {
            args: Prisma.documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          update: {
            args: Prisma.documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          deleteMany: {
            args: Prisma.documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.documentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          upsert: {
            args: Prisma.documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.documentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      email_logs: {
        payload: Prisma.$email_logsPayload<ExtArgs>
        fields: Prisma.email_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>
          }
          findFirst: {
            args: Prisma.email_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>
          }
          findMany: {
            args: Prisma.email_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>[]
          }
          create: {
            args: Prisma.email_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>
          }
          createMany: {
            args: Prisma.email_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>[]
          }
          delete: {
            args: Prisma.email_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>
          }
          update: {
            args: Prisma.email_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>
          }
          deleteMany: {
            args: Prisma.email_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.email_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>[]
          }
          upsert: {
            args: Prisma.email_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_logsPayload>
          }
          aggregate: {
            args: Prisma.Email_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_logs>
          }
          groupBy: {
            args: Prisma.email_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Email_logsCountAggregateOutputType> | number
          }
        }
      }
      locations: {
        payload: Prisma.$locationsPayload<ExtArgs>
        fields: Prisma.locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findFirst: {
            args: Prisma.locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findMany: {
            args: Prisma.locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          create: {
            args: Prisma.locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          createMany: {
            args: Prisma.locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.locationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          delete: {
            args: Prisma.locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          update: {
            args: Prisma.locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          deleteMany: {
            args: Prisma.locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.locationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          upsert: {
            args: Prisma.locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      profiles: {
        payload: Prisma.$profilesPayload<ExtArgs>
        fields: Prisma.profilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          findFirst: {
            args: Prisma.profilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          findMany: {
            args: Prisma.profilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>[]
          }
          create: {
            args: Prisma.profilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          createMany: {
            args: Prisma.profilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.profilesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>[]
          }
          delete: {
            args: Prisma.profilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          update: {
            args: Prisma.profilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          deleteMany: {
            args: Prisma.profilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.profilesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>[]
          }
          upsert: {
            args: Prisma.profilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          aggregate: {
            args: Prisma.ProfilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfiles>
          }
          groupBy: {
            args: Prisma.profilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.profilesCountArgs<ExtArgs>
            result: $Utils.Optional<ProfilesCountAggregateOutputType> | number
          }
        }
      }
      reviews: {
        payload: Prisma.$reviewsPayload<ExtArgs>
        fields: Prisma.reviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findFirst: {
            args: Prisma.reviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findMany: {
            args: Prisma.reviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          create: {
            args: Prisma.reviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          createMany: {
            args: Prisma.reviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          delete: {
            args: Prisma.reviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          update: {
            args: Prisma.reviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          deleteMany: {
            args: Prisma.reviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          upsert: {
            args: Prisma.reviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.reviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      settings: {
        payload: Prisma.$settingsPayload<ExtArgs>
        fields: Prisma.settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findFirst: {
            args: Prisma.settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findMany: {
            args: Prisma.settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          create: {
            args: Prisma.settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          createMany: {
            args: Prisma.settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.settingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          delete: {
            args: Prisma.settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          update: {
            args: Prisma.settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          deleteMany: {
            args: Prisma.settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.settingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          upsert: {
            args: Prisma.settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      sms_logs: {
        payload: Prisma.$sms_logsPayload<ExtArgs>
        fields: Prisma.sms_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sms_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sms_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>
          }
          findFirst: {
            args: Prisma.sms_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sms_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>
          }
          findMany: {
            args: Prisma.sms_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>[]
          }
          create: {
            args: Prisma.sms_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>
          }
          createMany: {
            args: Prisma.sms_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sms_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>[]
          }
          delete: {
            args: Prisma.sms_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>
          }
          update: {
            args: Prisma.sms_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>
          }
          deleteMany: {
            args: Prisma.sms_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sms_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sms_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>[]
          }
          upsert: {
            args: Prisma.sms_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sms_logsPayload>
          }
          aggregate: {
            args: Prisma.Sms_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSms_logs>
          }
          groupBy: {
            args: Prisma.sms_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sms_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sms_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Sms_logsCountAggregateOutputType> | number
          }
        }
      }
      trip_initiations: {
        payload: Prisma.$trip_initiationsPayload<ExtArgs>
        fields: Prisma.trip_initiationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trip_initiationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trip_initiationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>
          }
          findFirst: {
            args: Prisma.trip_initiationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trip_initiationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>
          }
          findMany: {
            args: Prisma.trip_initiationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>[]
          }
          create: {
            args: Prisma.trip_initiationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>
          }
          createMany: {
            args: Prisma.trip_initiationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trip_initiationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>[]
          }
          delete: {
            args: Prisma.trip_initiationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>
          }
          update: {
            args: Prisma.trip_initiationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>
          }
          deleteMany: {
            args: Prisma.trip_initiationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trip_initiationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trip_initiationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>[]
          }
          upsert: {
            args: Prisma.trip_initiationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trip_initiationsPayload>
          }
          aggregate: {
            args: Prisma.Trip_initiationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip_initiations>
          }
          groupBy: {
            args: Prisma.trip_initiationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Trip_initiationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.trip_initiationsCountArgs<ExtArgs>
            result: $Utils.Optional<Trip_initiationsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      vehicles: {
        payload: Prisma.$vehiclesPayload<ExtArgs>
        fields: Prisma.vehiclesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehiclesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehiclesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findFirst: {
            args: Prisma.vehiclesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehiclesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findMany: {
            args: Prisma.vehiclesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          create: {
            args: Prisma.vehiclesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          createMany: {
            args: Prisma.vehiclesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehiclesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          delete: {
            args: Prisma.vehiclesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          update: {
            args: Prisma.vehiclesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          deleteMany: {
            args: Prisma.vehiclesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehiclesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vehiclesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          upsert: {
            args: Prisma.vehiclesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          aggregate: {
            args: Prisma.VehiclesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicles>
          }
          groupBy: {
            args: Prisma.vehiclesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiclesGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehiclesCountArgs<ExtArgs>
            result: $Utils.Optional<VehiclesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    adminNotification?: AdminNotificationOmit
    deliveryBooking?: DeliveryBookingOmit
    deliveryPartner?: DeliveryPartnerOmit
    deliveryTracking?: DeliveryTrackingOmit
    booking_history?: booking_historyOmit
    bookings?: bookingsOmit
    coupons?: couponsOmit
    document_submissions?: document_submissionsOmit
    documents?: documentsOmit
    email_logs?: email_logsOmit
    locations?: locationsOmit
    payments?: paymentsOmit
    profiles?: profilesOmit
    reviews?: reviewsOmit
    settings?: settingsOmit
    sms_logs?: sms_logsOmit
    trip_initiations?: trip_initiationsOmit
    users?: usersOmit
    vehicles?: vehiclesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DeliveryBookingCountOutputType
   */

  export type DeliveryBookingCountOutputType = {
    DeliveryTracking: number
  }

  export type DeliveryBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryTracking?: boolean | DeliveryBookingCountOutputTypeCountDeliveryTrackingArgs
  }

  // Custom InputTypes
  /**
   * DeliveryBookingCountOutputType without action
   */
  export type DeliveryBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBookingCountOutputType
     */
    select?: DeliveryBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryBookingCountOutputType without action
   */
  export type DeliveryBookingCountOutputTypeCountDeliveryTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTrackingWhereInput
  }


  /**
   * Count Type DeliveryPartnerCountOutputType
   */

  export type DeliveryPartnerCountOutputType = {
    DeliveryBooking: number
  }

  export type DeliveryPartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryBooking?: boolean | DeliveryPartnerCountOutputTypeCountDeliveryBookingArgs
  }

  // Custom InputTypes
  /**
   * DeliveryPartnerCountOutputType without action
   */
  export type DeliveryPartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartnerCountOutputType
     */
    select?: DeliveryPartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryPartnerCountOutputType without action
   */
  export type DeliveryPartnerCountOutputTypeCountDeliveryBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryBookingWhereInput
  }


  /**
   * Count Type BookingsCountOutputType
   */

  export type BookingsCountOutputType = {
    booking_history: number
  }

  export type BookingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking_history?: boolean | BookingsCountOutputTypeCountBooking_historyArgs
  }

  // Custom InputTypes
  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingsCountOutputType
     */
    select?: BookingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountBooking_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_historyWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    DeliveryPartner: number
    bookings: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryPartner?: boolean | UsersCountOutputTypeCountDeliveryPartnerArgs
    bookings?: boolean | UsersCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDeliveryPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryPartnerWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }


  /**
   * Count Type VehiclesCountOutputType
   */

  export type VehiclesCountOutputType = {
    bookings: number
  }

  export type VehiclesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | VehiclesCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * VehiclesCountOutputType without action
   */
  export type VehiclesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclesCountOutputType
     */
    select?: VehiclesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehiclesCountOutputType without action
   */
  export type VehiclesCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AdminNotification
   */

  export type AggregateAdminNotification = {
    _count: AdminNotificationCountAggregateOutputType | null
    _min: AdminNotificationMinAggregateOutputType | null
    _max: AdminNotificationMaxAggregateOutputType | null
  }

  export type AdminNotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    recipient: string | null
    channel: string | null
    status: string | null
    error: string | null
    data: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminNotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    recipient: string | null
    channel: string | null
    status: string | null
    error: string | null
    data: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminNotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    recipient: number
    channel: number
    status: number
    error: number
    data: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdminNotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    recipient?: true
    channel?: true
    status?: true
    error?: true
    data?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminNotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    recipient?: true
    channel?: true
    status?: true
    error?: true
    data?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminNotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    recipient?: true
    channel?: true
    status?: true
    error?: true
    data?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdminNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNotification to aggregate.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminNotifications
    **/
    _count?: true | AdminNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminNotificationMaxAggregateInputType
  }

  export type GetAdminNotificationAggregateType<T extends AdminNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminNotification[P]>
      : GetScalarType<T[P], AggregateAdminNotification[P]>
  }




  export type AdminNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNotificationWhereInput
    orderBy?: AdminNotificationOrderByWithAggregationInput | AdminNotificationOrderByWithAggregationInput[]
    by: AdminNotificationScalarFieldEnum[] | AdminNotificationScalarFieldEnum
    having?: AdminNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminNotificationCountAggregateInputType | true
    _min?: AdminNotificationMinAggregateInputType
    _max?: AdminNotificationMaxAggregateInputType
  }

  export type AdminNotificationGroupByOutputType = {
    id: string
    type: string
    title: string
    recipient: string
    channel: string
    status: string
    error: string | null
    data: string | null
    created_at: Date
    updated_at: Date
    _count: AdminNotificationCountAggregateOutputType | null
    _min: AdminNotificationMinAggregateOutputType | null
    _max: AdminNotificationMaxAggregateOutputType | null
  }

  type GetAdminNotificationGroupByPayload<T extends AdminNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], AdminNotificationGroupByOutputType[P]>
        }
      >
    >


  export type AdminNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    recipient?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["adminNotification"]>

  export type AdminNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    recipient?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["adminNotification"]>

  export type AdminNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    recipient?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["adminNotification"]>

  export type AdminNotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    recipient?: boolean
    channel?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AdminNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "recipient" | "channel" | "status" | "error" | "data" | "created_at" | "updated_at", ExtArgs["result"]["adminNotification"]>

  export type $AdminNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminNotification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      recipient: string
      channel: string
      status: string
      error: string | null
      data: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["adminNotification"]>
    composites: {}
  }

  type AdminNotificationGetPayload<S extends boolean | null | undefined | AdminNotificationDefaultArgs> = $Result.GetResult<Prisma.$AdminNotificationPayload, S>

  type AdminNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminNotificationCountAggregateInputType | true
    }

  export interface AdminNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminNotification'], meta: { name: 'AdminNotification' } }
    /**
     * Find zero or one AdminNotification that matches the filter.
     * @param {AdminNotificationFindUniqueArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminNotificationFindUniqueArgs>(args: SelectSubset<T, AdminNotificationFindUniqueArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminNotificationFindUniqueOrThrowArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationFindFirstArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminNotificationFindFirstArgs>(args?: SelectSubset<T, AdminNotificationFindFirstArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationFindFirstOrThrowArgs} args - Arguments to find a AdminNotification
     * @example
     * // Get one AdminNotification
     * const adminNotification = await prisma.adminNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminNotifications
     * const adminNotifications = await prisma.adminNotification.findMany()
     * 
     * // Get first 10 AdminNotifications
     * const adminNotifications = await prisma.adminNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminNotificationWithIdOnly = await prisma.adminNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminNotificationFindManyArgs>(args?: SelectSubset<T, AdminNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminNotification.
     * @param {AdminNotificationCreateArgs} args - Arguments to create a AdminNotification.
     * @example
     * // Create one AdminNotification
     * const AdminNotification = await prisma.adminNotification.create({
     *   data: {
     *     // ... data to create a AdminNotification
     *   }
     * })
     * 
     */
    create<T extends AdminNotificationCreateArgs>(args: SelectSubset<T, AdminNotificationCreateArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminNotifications.
     * @param {AdminNotificationCreateManyArgs} args - Arguments to create many AdminNotifications.
     * @example
     * // Create many AdminNotifications
     * const adminNotification = await prisma.adminNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminNotificationCreateManyArgs>(args?: SelectSubset<T, AdminNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminNotifications and returns the data saved in the database.
     * @param {AdminNotificationCreateManyAndReturnArgs} args - Arguments to create many AdminNotifications.
     * @example
     * // Create many AdminNotifications
     * const adminNotification = await prisma.adminNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminNotifications and only return the `id`
     * const adminNotificationWithIdOnly = await prisma.adminNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminNotification.
     * @param {AdminNotificationDeleteArgs} args - Arguments to delete one AdminNotification.
     * @example
     * // Delete one AdminNotification
     * const AdminNotification = await prisma.adminNotification.delete({
     *   where: {
     *     // ... filter to delete one AdminNotification
     *   }
     * })
     * 
     */
    delete<T extends AdminNotificationDeleteArgs>(args: SelectSubset<T, AdminNotificationDeleteArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminNotification.
     * @param {AdminNotificationUpdateArgs} args - Arguments to update one AdminNotification.
     * @example
     * // Update one AdminNotification
     * const adminNotification = await prisma.adminNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminNotificationUpdateArgs>(args: SelectSubset<T, AdminNotificationUpdateArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminNotifications.
     * @param {AdminNotificationDeleteManyArgs} args - Arguments to filter AdminNotifications to delete.
     * @example
     * // Delete a few AdminNotifications
     * const { count } = await prisma.adminNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminNotificationDeleteManyArgs>(args?: SelectSubset<T, AdminNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminNotifications
     * const adminNotification = await prisma.adminNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminNotificationUpdateManyArgs>(args: SelectSubset<T, AdminNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminNotifications and returns the data updated in the database.
     * @param {AdminNotificationUpdateManyAndReturnArgs} args - Arguments to update many AdminNotifications.
     * @example
     * // Update many AdminNotifications
     * const adminNotification = await prisma.adminNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminNotifications and only return the `id`
     * const adminNotificationWithIdOnly = await prisma.adminNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminNotification.
     * @param {AdminNotificationUpsertArgs} args - Arguments to update or create a AdminNotification.
     * @example
     * // Update or create a AdminNotification
     * const adminNotification = await prisma.adminNotification.upsert({
     *   create: {
     *     // ... data to create a AdminNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminNotification we want to update
     *   }
     * })
     */
    upsert<T extends AdminNotificationUpsertArgs>(args: SelectSubset<T, AdminNotificationUpsertArgs<ExtArgs>>): Prisma__AdminNotificationClient<$Result.GetResult<Prisma.$AdminNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationCountArgs} args - Arguments to filter AdminNotifications to count.
     * @example
     * // Count the number of AdminNotifications
     * const count = await prisma.adminNotification.count({
     *   where: {
     *     // ... the filter for the AdminNotifications we want to count
     *   }
     * })
    **/
    count<T extends AdminNotificationCountArgs>(
      args?: Subset<T, AdminNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminNotificationAggregateArgs>(args: Subset<T, AdminNotificationAggregateArgs>): Prisma.PrismaPromise<GetAdminNotificationAggregateType<T>>

    /**
     * Group by AdminNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminNotificationGroupByArgs['orderBy'] }
        : { orderBy?: AdminNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminNotification model
   */
  readonly fields: AdminNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminNotification model
   */
  interface AdminNotificationFieldRefs {
    readonly id: FieldRef<"AdminNotification", 'String'>
    readonly type: FieldRef<"AdminNotification", 'String'>
    readonly title: FieldRef<"AdminNotification", 'String'>
    readonly recipient: FieldRef<"AdminNotification", 'String'>
    readonly channel: FieldRef<"AdminNotification", 'String'>
    readonly status: FieldRef<"AdminNotification", 'String'>
    readonly error: FieldRef<"AdminNotification", 'String'>
    readonly data: FieldRef<"AdminNotification", 'String'>
    readonly created_at: FieldRef<"AdminNotification", 'DateTime'>
    readonly updated_at: FieldRef<"AdminNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminNotification findUnique
   */
  export type AdminNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification findUniqueOrThrow
   */
  export type AdminNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification findFirst
   */
  export type AdminNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotifications.
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotifications.
     */
    distinct?: AdminNotificationScalarFieldEnum | AdminNotificationScalarFieldEnum[]
  }

  /**
   * AdminNotification findFirstOrThrow
   */
  export type AdminNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Filter, which AdminNotification to fetch.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotifications.
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotifications.
     */
    distinct?: AdminNotificationScalarFieldEnum | AdminNotificationScalarFieldEnum[]
  }

  /**
   * AdminNotification findMany
   */
  export type AdminNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Filter, which AdminNotifications to fetch.
     */
    where?: AdminNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotifications to fetch.
     */
    orderBy?: AdminNotificationOrderByWithRelationInput | AdminNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminNotifications.
     */
    cursor?: AdminNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotifications.
     */
    skip?: number
    distinct?: AdminNotificationScalarFieldEnum | AdminNotificationScalarFieldEnum[]
  }

  /**
   * AdminNotification create
   */
  export type AdminNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminNotification.
     */
    data: XOR<AdminNotificationCreateInput, AdminNotificationUncheckedCreateInput>
  }

  /**
   * AdminNotification createMany
   */
  export type AdminNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminNotifications.
     */
    data: AdminNotificationCreateManyInput | AdminNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminNotification createManyAndReturn
   */
  export type AdminNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many AdminNotifications.
     */
    data: AdminNotificationCreateManyInput | AdminNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminNotification update
   */
  export type AdminNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminNotification.
     */
    data: XOR<AdminNotificationUpdateInput, AdminNotificationUncheckedUpdateInput>
    /**
     * Choose, which AdminNotification to update.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification updateMany
   */
  export type AdminNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminNotifications.
     */
    data: XOR<AdminNotificationUpdateManyMutationInput, AdminNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AdminNotifications to update
     */
    where?: AdminNotificationWhereInput
    /**
     * Limit how many AdminNotifications to update.
     */
    limit?: number
  }

  /**
   * AdminNotification updateManyAndReturn
   */
  export type AdminNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * The data used to update AdminNotifications.
     */
    data: XOR<AdminNotificationUpdateManyMutationInput, AdminNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AdminNotifications to update
     */
    where?: AdminNotificationWhereInput
    /**
     * Limit how many AdminNotifications to update.
     */
    limit?: number
  }

  /**
   * AdminNotification upsert
   */
  export type AdminNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminNotification to update in case it exists.
     */
    where: AdminNotificationWhereUniqueInput
    /**
     * In case the AdminNotification found by the `where` argument doesn't exist, create a new AdminNotification with this data.
     */
    create: XOR<AdminNotificationCreateInput, AdminNotificationUncheckedCreateInput>
    /**
     * In case the AdminNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminNotificationUpdateInput, AdminNotificationUncheckedUpdateInput>
  }

  /**
   * AdminNotification delete
   */
  export type AdminNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
    /**
     * Filter which AdminNotification to delete.
     */
    where: AdminNotificationWhereUniqueInput
  }

  /**
   * AdminNotification deleteMany
   */
  export type AdminNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNotifications to delete
     */
    where?: AdminNotificationWhereInput
    /**
     * Limit how many AdminNotifications to delete.
     */
    limit?: number
  }

  /**
   * AdminNotification without action
   */
  export type AdminNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNotification
     */
    select?: AdminNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminNotification
     */
    omit?: AdminNotificationOmit<ExtArgs> | null
  }


  /**
   * Model DeliveryBooking
   */

  export type AggregateDeliveryBooking = {
    _count: DeliveryBookingCountAggregateOutputType | null
    _avg: DeliveryBookingAvgAggregateOutputType | null
    _sum: DeliveryBookingSumAggregateOutputType | null
    _min: DeliveryBookingMinAggregateOutputType | null
    _max: DeliveryBookingMaxAggregateOutputType | null
  }

  export type DeliveryBookingAvgAggregateOutputType = {
    estimated_distance: number | null
    estimated_duration: number | null
    actual_duration: number | null
    price: number | null
  }

  export type DeliveryBookingSumAggregateOutputType = {
    estimated_distance: number | null
    estimated_duration: number | null
    actual_duration: number | null
    price: number | null
  }

  export type DeliveryBookingMinAggregateOutputType = {
    id: string | null
    delivery_partner_id: string | null
    booking_id: string | null
    status: string | null
    estimated_distance: number | null
    estimated_duration: number | null
    actual_duration: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeliveryBookingMaxAggregateOutputType = {
    id: string | null
    delivery_partner_id: string | null
    booking_id: string | null
    status: string | null
    estimated_distance: number | null
    estimated_duration: number | null
    actual_duration: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeliveryBookingCountAggregateOutputType = {
    id: number
    delivery_partner_id: number
    booking_id: number
    pickup_location: number
    dropoff_location: number
    status: number
    estimated_distance: number
    estimated_duration: number
    actual_duration: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeliveryBookingAvgAggregateInputType = {
    estimated_distance?: true
    estimated_duration?: true
    actual_duration?: true
    price?: true
  }

  export type DeliveryBookingSumAggregateInputType = {
    estimated_distance?: true
    estimated_duration?: true
    actual_duration?: true
    price?: true
  }

  export type DeliveryBookingMinAggregateInputType = {
    id?: true
    delivery_partner_id?: true
    booking_id?: true
    status?: true
    estimated_distance?: true
    estimated_duration?: true
    actual_duration?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type DeliveryBookingMaxAggregateInputType = {
    id?: true
    delivery_partner_id?: true
    booking_id?: true
    status?: true
    estimated_distance?: true
    estimated_duration?: true
    actual_duration?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type DeliveryBookingCountAggregateInputType = {
    id?: true
    delivery_partner_id?: true
    booking_id?: true
    pickup_location?: true
    dropoff_location?: true
    status?: true
    estimated_distance?: true
    estimated_duration?: true
    actual_duration?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeliveryBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryBooking to aggregate.
     */
    where?: DeliveryBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBookings to fetch.
     */
    orderBy?: DeliveryBookingOrderByWithRelationInput | DeliveryBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryBookings
    **/
    _count?: true | DeliveryBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryBookingMaxAggregateInputType
  }

  export type GetDeliveryBookingAggregateType<T extends DeliveryBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryBooking[P]>
      : GetScalarType<T[P], AggregateDeliveryBooking[P]>
  }




  export type DeliveryBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryBookingWhereInput
    orderBy?: DeliveryBookingOrderByWithAggregationInput | DeliveryBookingOrderByWithAggregationInput[]
    by: DeliveryBookingScalarFieldEnum[] | DeliveryBookingScalarFieldEnum
    having?: DeliveryBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryBookingCountAggregateInputType | true
    _avg?: DeliveryBookingAvgAggregateInputType
    _sum?: DeliveryBookingSumAggregateInputType
    _min?: DeliveryBookingMinAggregateInputType
    _max?: DeliveryBookingMaxAggregateInputType
  }

  export type DeliveryBookingGroupByOutputType = {
    id: string
    delivery_partner_id: string
    booking_id: string
    pickup_location: JsonValue
    dropoff_location: JsonValue
    status: string
    estimated_distance: number
    estimated_duration: number
    actual_duration: number | null
    price: number
    created_at: Date
    updated_at: Date
    _count: DeliveryBookingCountAggregateOutputType | null
    _avg: DeliveryBookingAvgAggregateOutputType | null
    _sum: DeliveryBookingSumAggregateOutputType | null
    _min: DeliveryBookingMinAggregateOutputType | null
    _max: DeliveryBookingMaxAggregateOutputType | null
  }

  type GetDeliveryBookingGroupByPayload<T extends DeliveryBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryBookingGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryBookingGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_partner_id?: boolean
    booking_id?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    status?: boolean
    estimated_distance?: boolean
    estimated_duration?: boolean
    actual_duration?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
    DeliveryPartner?: boolean | DeliveryPartnerDefaultArgs<ExtArgs>
    DeliveryTracking?: boolean | DeliveryBooking$DeliveryTrackingArgs<ExtArgs>
    _count?: boolean | DeliveryBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryBooking"]>

  export type DeliveryBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_partner_id?: boolean
    booking_id?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    status?: boolean
    estimated_distance?: boolean
    estimated_duration?: boolean
    actual_duration?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
    DeliveryPartner?: boolean | DeliveryPartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryBooking"]>

  export type DeliveryBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_partner_id?: boolean
    booking_id?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    status?: boolean
    estimated_distance?: boolean
    estimated_duration?: boolean
    actual_duration?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
    DeliveryPartner?: boolean | DeliveryPartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryBooking"]>

  export type DeliveryBookingSelectScalar = {
    id?: boolean
    delivery_partner_id?: boolean
    booking_id?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    status?: boolean
    estimated_distance?: boolean
    estimated_duration?: boolean
    actual_duration?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DeliveryBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "delivery_partner_id" | "booking_id" | "pickup_location" | "dropoff_location" | "status" | "estimated_distance" | "estimated_duration" | "actual_duration" | "price" | "created_at" | "updated_at", ExtArgs["result"]["deliveryBooking"]>
  export type DeliveryBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
    DeliveryPartner?: boolean | DeliveryPartnerDefaultArgs<ExtArgs>
    DeliveryTracking?: boolean | DeliveryBooking$DeliveryTrackingArgs<ExtArgs>
    _count?: boolean | DeliveryBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
    DeliveryPartner?: boolean | DeliveryPartnerDefaultArgs<ExtArgs>
  }
  export type DeliveryBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
    DeliveryPartner?: boolean | DeliveryPartnerDefaultArgs<ExtArgs>
  }

  export type $DeliveryBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryBooking"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>
      DeliveryPartner: Prisma.$DeliveryPartnerPayload<ExtArgs>
      DeliveryTracking: Prisma.$DeliveryTrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      delivery_partner_id: string
      booking_id: string
      pickup_location: Prisma.JsonValue
      dropoff_location: Prisma.JsonValue
      status: string
      estimated_distance: number
      estimated_duration: number
      actual_duration: number | null
      price: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["deliveryBooking"]>
    composites: {}
  }

  type DeliveryBookingGetPayload<S extends boolean | null | undefined | DeliveryBookingDefaultArgs> = $Result.GetResult<Prisma.$DeliveryBookingPayload, S>

  type DeliveryBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryBookingCountAggregateInputType | true
    }

  export interface DeliveryBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryBooking'], meta: { name: 'DeliveryBooking' } }
    /**
     * Find zero or one DeliveryBooking that matches the filter.
     * @param {DeliveryBookingFindUniqueArgs} args - Arguments to find a DeliveryBooking
     * @example
     * // Get one DeliveryBooking
     * const deliveryBooking = await prisma.deliveryBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryBookingFindUniqueArgs>(args: SelectSubset<T, DeliveryBookingFindUniqueArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryBookingFindUniqueOrThrowArgs} args - Arguments to find a DeliveryBooking
     * @example
     * // Get one DeliveryBooking
     * const deliveryBooking = await prisma.deliveryBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBookingFindFirstArgs} args - Arguments to find a DeliveryBooking
     * @example
     * // Get one DeliveryBooking
     * const deliveryBooking = await prisma.deliveryBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryBookingFindFirstArgs>(args?: SelectSubset<T, DeliveryBookingFindFirstArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBookingFindFirstOrThrowArgs} args - Arguments to find a DeliveryBooking
     * @example
     * // Get one DeliveryBooking
     * const deliveryBooking = await prisma.deliveryBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryBookings
     * const deliveryBookings = await prisma.deliveryBooking.findMany()
     * 
     * // Get first 10 DeliveryBookings
     * const deliveryBookings = await prisma.deliveryBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryBookingWithIdOnly = await prisma.deliveryBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryBookingFindManyArgs>(args?: SelectSubset<T, DeliveryBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryBooking.
     * @param {DeliveryBookingCreateArgs} args - Arguments to create a DeliveryBooking.
     * @example
     * // Create one DeliveryBooking
     * const DeliveryBooking = await prisma.deliveryBooking.create({
     *   data: {
     *     // ... data to create a DeliveryBooking
     *   }
     * })
     * 
     */
    create<T extends DeliveryBookingCreateArgs>(args: SelectSubset<T, DeliveryBookingCreateArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryBookings.
     * @param {DeliveryBookingCreateManyArgs} args - Arguments to create many DeliveryBookings.
     * @example
     * // Create many DeliveryBookings
     * const deliveryBooking = await prisma.deliveryBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryBookingCreateManyArgs>(args?: SelectSubset<T, DeliveryBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryBookings and returns the data saved in the database.
     * @param {DeliveryBookingCreateManyAndReturnArgs} args - Arguments to create many DeliveryBookings.
     * @example
     * // Create many DeliveryBookings
     * const deliveryBooking = await prisma.deliveryBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryBookings and only return the `id`
     * const deliveryBookingWithIdOnly = await prisma.deliveryBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryBooking.
     * @param {DeliveryBookingDeleteArgs} args - Arguments to delete one DeliveryBooking.
     * @example
     * // Delete one DeliveryBooking
     * const DeliveryBooking = await prisma.deliveryBooking.delete({
     *   where: {
     *     // ... filter to delete one DeliveryBooking
     *   }
     * })
     * 
     */
    delete<T extends DeliveryBookingDeleteArgs>(args: SelectSubset<T, DeliveryBookingDeleteArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryBooking.
     * @param {DeliveryBookingUpdateArgs} args - Arguments to update one DeliveryBooking.
     * @example
     * // Update one DeliveryBooking
     * const deliveryBooking = await prisma.deliveryBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryBookingUpdateArgs>(args: SelectSubset<T, DeliveryBookingUpdateArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryBookings.
     * @param {DeliveryBookingDeleteManyArgs} args - Arguments to filter DeliveryBookings to delete.
     * @example
     * // Delete a few DeliveryBookings
     * const { count } = await prisma.deliveryBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryBookingDeleteManyArgs>(args?: SelectSubset<T, DeliveryBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryBookings
     * const deliveryBooking = await prisma.deliveryBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryBookingUpdateManyArgs>(args: SelectSubset<T, DeliveryBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryBookings and returns the data updated in the database.
     * @param {DeliveryBookingUpdateManyAndReturnArgs} args - Arguments to update many DeliveryBookings.
     * @example
     * // Update many DeliveryBookings
     * const deliveryBooking = await prisma.deliveryBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryBookings and only return the `id`
     * const deliveryBookingWithIdOnly = await prisma.deliveryBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryBooking.
     * @param {DeliveryBookingUpsertArgs} args - Arguments to update or create a DeliveryBooking.
     * @example
     * // Update or create a DeliveryBooking
     * const deliveryBooking = await prisma.deliveryBooking.upsert({
     *   create: {
     *     // ... data to create a DeliveryBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryBooking we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryBookingUpsertArgs>(args: SelectSubset<T, DeliveryBookingUpsertArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBookingCountArgs} args - Arguments to filter DeliveryBookings to count.
     * @example
     * // Count the number of DeliveryBookings
     * const count = await prisma.deliveryBooking.count({
     *   where: {
     *     // ... the filter for the DeliveryBookings we want to count
     *   }
     * })
    **/
    count<T extends DeliveryBookingCountArgs>(
      args?: Subset<T, DeliveryBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryBookingAggregateArgs>(args: Subset<T, DeliveryBookingAggregateArgs>): Prisma.PrismaPromise<GetDeliveryBookingAggregateType<T>>

    /**
     * Group by DeliveryBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryBookingGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryBooking model
   */
  readonly fields: DeliveryBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeliveryPartner<T extends DeliveryPartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPartnerDefaultArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeliveryTracking<T extends DeliveryBooking$DeliveryTrackingArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryBooking$DeliveryTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryBooking model
   */
  interface DeliveryBookingFieldRefs {
    readonly id: FieldRef<"DeliveryBooking", 'String'>
    readonly delivery_partner_id: FieldRef<"DeliveryBooking", 'String'>
    readonly booking_id: FieldRef<"DeliveryBooking", 'String'>
    readonly pickup_location: FieldRef<"DeliveryBooking", 'Json'>
    readonly dropoff_location: FieldRef<"DeliveryBooking", 'Json'>
    readonly status: FieldRef<"DeliveryBooking", 'String'>
    readonly estimated_distance: FieldRef<"DeliveryBooking", 'Float'>
    readonly estimated_duration: FieldRef<"DeliveryBooking", 'Int'>
    readonly actual_duration: FieldRef<"DeliveryBooking", 'Int'>
    readonly price: FieldRef<"DeliveryBooking", 'Float'>
    readonly created_at: FieldRef<"DeliveryBooking", 'DateTime'>
    readonly updated_at: FieldRef<"DeliveryBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryBooking findUnique
   */
  export type DeliveryBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBooking to fetch.
     */
    where: DeliveryBookingWhereUniqueInput
  }

  /**
   * DeliveryBooking findUniqueOrThrow
   */
  export type DeliveryBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBooking to fetch.
     */
    where: DeliveryBookingWhereUniqueInput
  }

  /**
   * DeliveryBooking findFirst
   */
  export type DeliveryBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBooking to fetch.
     */
    where?: DeliveryBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBookings to fetch.
     */
    orderBy?: DeliveryBookingOrderByWithRelationInput | DeliveryBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryBookings.
     */
    cursor?: DeliveryBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryBookings.
     */
    distinct?: DeliveryBookingScalarFieldEnum | DeliveryBookingScalarFieldEnum[]
  }

  /**
   * DeliveryBooking findFirstOrThrow
   */
  export type DeliveryBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBooking to fetch.
     */
    where?: DeliveryBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBookings to fetch.
     */
    orderBy?: DeliveryBookingOrderByWithRelationInput | DeliveryBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryBookings.
     */
    cursor?: DeliveryBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryBookings.
     */
    distinct?: DeliveryBookingScalarFieldEnum | DeliveryBookingScalarFieldEnum[]
  }

  /**
   * DeliveryBooking findMany
   */
  export type DeliveryBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryBookings to fetch.
     */
    where?: DeliveryBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBookings to fetch.
     */
    orderBy?: DeliveryBookingOrderByWithRelationInput | DeliveryBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryBookings.
     */
    cursor?: DeliveryBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBookings.
     */
    skip?: number
    distinct?: DeliveryBookingScalarFieldEnum | DeliveryBookingScalarFieldEnum[]
  }

  /**
   * DeliveryBooking create
   */
  export type DeliveryBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryBooking.
     */
    data: XOR<DeliveryBookingCreateInput, DeliveryBookingUncheckedCreateInput>
  }

  /**
   * DeliveryBooking createMany
   */
  export type DeliveryBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryBookings.
     */
    data: DeliveryBookingCreateManyInput | DeliveryBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryBooking createManyAndReturn
   */
  export type DeliveryBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryBookings.
     */
    data: DeliveryBookingCreateManyInput | DeliveryBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryBooking update
   */
  export type DeliveryBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryBooking.
     */
    data: XOR<DeliveryBookingUpdateInput, DeliveryBookingUncheckedUpdateInput>
    /**
     * Choose, which DeliveryBooking to update.
     */
    where: DeliveryBookingWhereUniqueInput
  }

  /**
   * DeliveryBooking updateMany
   */
  export type DeliveryBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryBookings.
     */
    data: XOR<DeliveryBookingUpdateManyMutationInput, DeliveryBookingUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryBookings to update
     */
    where?: DeliveryBookingWhereInput
    /**
     * Limit how many DeliveryBookings to update.
     */
    limit?: number
  }

  /**
   * DeliveryBooking updateManyAndReturn
   */
  export type DeliveryBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryBookings.
     */
    data: XOR<DeliveryBookingUpdateManyMutationInput, DeliveryBookingUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryBookings to update
     */
    where?: DeliveryBookingWhereInput
    /**
     * Limit how many DeliveryBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryBooking upsert
   */
  export type DeliveryBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryBooking to update in case it exists.
     */
    where: DeliveryBookingWhereUniqueInput
    /**
     * In case the DeliveryBooking found by the `where` argument doesn't exist, create a new DeliveryBooking with this data.
     */
    create: XOR<DeliveryBookingCreateInput, DeliveryBookingUncheckedCreateInput>
    /**
     * In case the DeliveryBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryBookingUpdateInput, DeliveryBookingUncheckedUpdateInput>
  }

  /**
   * DeliveryBooking delete
   */
  export type DeliveryBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    /**
     * Filter which DeliveryBooking to delete.
     */
    where: DeliveryBookingWhereUniqueInput
  }

  /**
   * DeliveryBooking deleteMany
   */
  export type DeliveryBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryBookings to delete
     */
    where?: DeliveryBookingWhereInput
    /**
     * Limit how many DeliveryBookings to delete.
     */
    limit?: number
  }

  /**
   * DeliveryBooking.DeliveryTracking
   */
  export type DeliveryBooking$DeliveryTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    where?: DeliveryTrackingWhereInput
    orderBy?: DeliveryTrackingOrderByWithRelationInput | DeliveryTrackingOrderByWithRelationInput[]
    cursor?: DeliveryTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryTrackingScalarFieldEnum | DeliveryTrackingScalarFieldEnum[]
  }

  /**
   * DeliveryBooking without action
   */
  export type DeliveryBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryPartner
   */

  export type AggregateDeliveryPartner = {
    _count: DeliveryPartnerCountAggregateOutputType | null
    _avg: DeliveryPartnerAvgAggregateOutputType | null
    _sum: DeliveryPartnerSumAggregateOutputType | null
    _min: DeliveryPartnerMinAggregateOutputType | null
    _max: DeliveryPartnerMaxAggregateOutputType | null
  }

  export type DeliveryPartnerAvgAggregateOutputType = {
    rating: number | null
    total_trips: number | null
  }

  export type DeliveryPartnerSumAggregateOutputType = {
    rating: number | null
    total_trips: number | null
  }

  export type DeliveryPartnerMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    vehicle_type: string | null
    vehicle_number: string | null
    license_number: string | null
    is_available: boolean | null
    rating: number | null
    total_trips: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeliveryPartnerMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    vehicle_type: string | null
    vehicle_number: string | null
    license_number: string | null
    is_available: boolean | null
    rating: number | null
    total_trips: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DeliveryPartnerCountAggregateOutputType = {
    id: number
    user_id: number
    vehicle_type: number
    vehicle_number: number
    license_number: number
    is_available: number
    current_location: number
    rating: number
    total_trips: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DeliveryPartnerAvgAggregateInputType = {
    rating?: true
    total_trips?: true
  }

  export type DeliveryPartnerSumAggregateInputType = {
    rating?: true
    total_trips?: true
  }

  export type DeliveryPartnerMinAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_type?: true
    vehicle_number?: true
    license_number?: true
    is_available?: true
    rating?: true
    total_trips?: true
    created_at?: true
    updated_at?: true
  }

  export type DeliveryPartnerMaxAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_type?: true
    vehicle_number?: true
    license_number?: true
    is_available?: true
    rating?: true
    total_trips?: true
    created_at?: true
    updated_at?: true
  }

  export type DeliveryPartnerCountAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_type?: true
    vehicle_number?: true
    license_number?: true
    is_available?: true
    current_location?: true
    rating?: true
    total_trips?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DeliveryPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryPartner to aggregate.
     */
    where?: DeliveryPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPartners to fetch.
     */
    orderBy?: DeliveryPartnerOrderByWithRelationInput | DeliveryPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryPartners
    **/
    _count?: true | DeliveryPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryPartnerMaxAggregateInputType
  }

  export type GetDeliveryPartnerAggregateType<T extends DeliveryPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryPartner[P]>
      : GetScalarType<T[P], AggregateDeliveryPartner[P]>
  }




  export type DeliveryPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryPartnerWhereInput
    orderBy?: DeliveryPartnerOrderByWithAggregationInput | DeliveryPartnerOrderByWithAggregationInput[]
    by: DeliveryPartnerScalarFieldEnum[] | DeliveryPartnerScalarFieldEnum
    having?: DeliveryPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryPartnerCountAggregateInputType | true
    _avg?: DeliveryPartnerAvgAggregateInputType
    _sum?: DeliveryPartnerSumAggregateInputType
    _min?: DeliveryPartnerMinAggregateInputType
    _max?: DeliveryPartnerMaxAggregateInputType
  }

  export type DeliveryPartnerGroupByOutputType = {
    id: string
    user_id: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available: boolean
    current_location: JsonValue | null
    rating: number
    total_trips: number
    created_at: Date
    updated_at: Date
    _count: DeliveryPartnerCountAggregateOutputType | null
    _avg: DeliveryPartnerAvgAggregateOutputType | null
    _sum: DeliveryPartnerSumAggregateOutputType | null
    _min: DeliveryPartnerMinAggregateOutputType | null
    _max: DeliveryPartnerMaxAggregateOutputType | null
  }

  type GetDeliveryPartnerGroupByPayload<T extends DeliveryPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryPartnerGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_type?: boolean
    vehicle_number?: boolean
    license_number?: boolean
    is_available?: boolean
    current_location?: boolean
    rating?: boolean
    total_trips?: boolean
    created_at?: boolean
    updated_at?: boolean
    DeliveryBooking?: boolean | DeliveryPartner$DeliveryBookingArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | DeliveryPartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryPartner"]>

  export type DeliveryPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_type?: boolean
    vehicle_number?: boolean
    license_number?: boolean
    is_available?: boolean
    current_location?: boolean
    rating?: boolean
    total_trips?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryPartner"]>

  export type DeliveryPartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_type?: boolean
    vehicle_number?: boolean
    license_number?: boolean
    is_available?: boolean
    current_location?: boolean
    rating?: boolean
    total_trips?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryPartner"]>

  export type DeliveryPartnerSelectScalar = {
    id?: boolean
    user_id?: boolean
    vehicle_type?: boolean
    vehicle_number?: boolean
    license_number?: boolean
    is_available?: boolean
    current_location?: boolean
    rating?: boolean
    total_trips?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DeliveryPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "vehicle_type" | "vehicle_number" | "license_number" | "is_available" | "current_location" | "rating" | "total_trips" | "created_at" | "updated_at", ExtArgs["result"]["deliveryPartner"]>
  export type DeliveryPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryBooking?: boolean | DeliveryPartner$DeliveryBookingArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | DeliveryPartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryPartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type DeliveryPartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $DeliveryPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryPartner"
    objects: {
      DeliveryBooking: Prisma.$DeliveryBookingPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      vehicle_type: string
      vehicle_number: string
      license_number: string
      is_available: boolean
      current_location: Prisma.JsonValue | null
      rating: number
      total_trips: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["deliveryPartner"]>
    composites: {}
  }

  type DeliveryPartnerGetPayload<S extends boolean | null | undefined | DeliveryPartnerDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPartnerPayload, S>

  type DeliveryPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryPartnerCountAggregateInputType | true
    }

  export interface DeliveryPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryPartner'], meta: { name: 'DeliveryPartner' } }
    /**
     * Find zero or one DeliveryPartner that matches the filter.
     * @param {DeliveryPartnerFindUniqueArgs} args - Arguments to find a DeliveryPartner
     * @example
     * // Get one DeliveryPartner
     * const deliveryPartner = await prisma.deliveryPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryPartnerFindUniqueArgs>(args: SelectSubset<T, DeliveryPartnerFindUniqueArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryPartnerFindUniqueOrThrowArgs} args - Arguments to find a DeliveryPartner
     * @example
     * // Get one DeliveryPartner
     * const deliveryPartner = await prisma.deliveryPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPartnerFindFirstArgs} args - Arguments to find a DeliveryPartner
     * @example
     * // Get one DeliveryPartner
     * const deliveryPartner = await prisma.deliveryPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryPartnerFindFirstArgs>(args?: SelectSubset<T, DeliveryPartnerFindFirstArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPartnerFindFirstOrThrowArgs} args - Arguments to find a DeliveryPartner
     * @example
     * // Get one DeliveryPartner
     * const deliveryPartner = await prisma.deliveryPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryPartners
     * const deliveryPartners = await prisma.deliveryPartner.findMany()
     * 
     * // Get first 10 DeliveryPartners
     * const deliveryPartners = await prisma.deliveryPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryPartnerWithIdOnly = await prisma.deliveryPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryPartnerFindManyArgs>(args?: SelectSubset<T, DeliveryPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryPartner.
     * @param {DeliveryPartnerCreateArgs} args - Arguments to create a DeliveryPartner.
     * @example
     * // Create one DeliveryPartner
     * const DeliveryPartner = await prisma.deliveryPartner.create({
     *   data: {
     *     // ... data to create a DeliveryPartner
     *   }
     * })
     * 
     */
    create<T extends DeliveryPartnerCreateArgs>(args: SelectSubset<T, DeliveryPartnerCreateArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryPartners.
     * @param {DeliveryPartnerCreateManyArgs} args - Arguments to create many DeliveryPartners.
     * @example
     * // Create many DeliveryPartners
     * const deliveryPartner = await prisma.deliveryPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryPartnerCreateManyArgs>(args?: SelectSubset<T, DeliveryPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryPartners and returns the data saved in the database.
     * @param {DeliveryPartnerCreateManyAndReturnArgs} args - Arguments to create many DeliveryPartners.
     * @example
     * // Create many DeliveryPartners
     * const deliveryPartner = await prisma.deliveryPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryPartners and only return the `id`
     * const deliveryPartnerWithIdOnly = await prisma.deliveryPartner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryPartner.
     * @param {DeliveryPartnerDeleteArgs} args - Arguments to delete one DeliveryPartner.
     * @example
     * // Delete one DeliveryPartner
     * const DeliveryPartner = await prisma.deliveryPartner.delete({
     *   where: {
     *     // ... filter to delete one DeliveryPartner
     *   }
     * })
     * 
     */
    delete<T extends DeliveryPartnerDeleteArgs>(args: SelectSubset<T, DeliveryPartnerDeleteArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryPartner.
     * @param {DeliveryPartnerUpdateArgs} args - Arguments to update one DeliveryPartner.
     * @example
     * // Update one DeliveryPartner
     * const deliveryPartner = await prisma.deliveryPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryPartnerUpdateArgs>(args: SelectSubset<T, DeliveryPartnerUpdateArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryPartners.
     * @param {DeliveryPartnerDeleteManyArgs} args - Arguments to filter DeliveryPartners to delete.
     * @example
     * // Delete a few DeliveryPartners
     * const { count } = await prisma.deliveryPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryPartnerDeleteManyArgs>(args?: SelectSubset<T, DeliveryPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryPartners
     * const deliveryPartner = await prisma.deliveryPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryPartnerUpdateManyArgs>(args: SelectSubset<T, DeliveryPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryPartners and returns the data updated in the database.
     * @param {DeliveryPartnerUpdateManyAndReturnArgs} args - Arguments to update many DeliveryPartners.
     * @example
     * // Update many DeliveryPartners
     * const deliveryPartner = await prisma.deliveryPartner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryPartners and only return the `id`
     * const deliveryPartnerWithIdOnly = await prisma.deliveryPartner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryPartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryPartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryPartner.
     * @param {DeliveryPartnerUpsertArgs} args - Arguments to update or create a DeliveryPartner.
     * @example
     * // Update or create a DeliveryPartner
     * const deliveryPartner = await prisma.deliveryPartner.upsert({
     *   create: {
     *     // ... data to create a DeliveryPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryPartner we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryPartnerUpsertArgs>(args: SelectSubset<T, DeliveryPartnerUpsertArgs<ExtArgs>>): Prisma__DeliveryPartnerClient<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPartnerCountArgs} args - Arguments to filter DeliveryPartners to count.
     * @example
     * // Count the number of DeliveryPartners
     * const count = await prisma.deliveryPartner.count({
     *   where: {
     *     // ... the filter for the DeliveryPartners we want to count
     *   }
     * })
    **/
    count<T extends DeliveryPartnerCountArgs>(
      args?: Subset<T, DeliveryPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryPartnerAggregateArgs>(args: Subset<T, DeliveryPartnerAggregateArgs>): Prisma.PrismaPromise<GetDeliveryPartnerAggregateType<T>>

    /**
     * Group by DeliveryPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryPartnerGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryPartner model
   */
  readonly fields: DeliveryPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeliveryBooking<T extends DeliveryPartner$DeliveryBookingArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryPartner$DeliveryBookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryPartner model
   */
  interface DeliveryPartnerFieldRefs {
    readonly id: FieldRef<"DeliveryPartner", 'String'>
    readonly user_id: FieldRef<"DeliveryPartner", 'String'>
    readonly vehicle_type: FieldRef<"DeliveryPartner", 'String'>
    readonly vehicle_number: FieldRef<"DeliveryPartner", 'String'>
    readonly license_number: FieldRef<"DeliveryPartner", 'String'>
    readonly is_available: FieldRef<"DeliveryPartner", 'Boolean'>
    readonly current_location: FieldRef<"DeliveryPartner", 'Json'>
    readonly rating: FieldRef<"DeliveryPartner", 'Float'>
    readonly total_trips: FieldRef<"DeliveryPartner", 'Int'>
    readonly created_at: FieldRef<"DeliveryPartner", 'DateTime'>
    readonly updated_at: FieldRef<"DeliveryPartner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryPartner findUnique
   */
  export type DeliveryPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPartner to fetch.
     */
    where: DeliveryPartnerWhereUniqueInput
  }

  /**
   * DeliveryPartner findUniqueOrThrow
   */
  export type DeliveryPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPartner to fetch.
     */
    where: DeliveryPartnerWhereUniqueInput
  }

  /**
   * DeliveryPartner findFirst
   */
  export type DeliveryPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPartner to fetch.
     */
    where?: DeliveryPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPartners to fetch.
     */
    orderBy?: DeliveryPartnerOrderByWithRelationInput | DeliveryPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryPartners.
     */
    cursor?: DeliveryPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryPartners.
     */
    distinct?: DeliveryPartnerScalarFieldEnum | DeliveryPartnerScalarFieldEnum[]
  }

  /**
   * DeliveryPartner findFirstOrThrow
   */
  export type DeliveryPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPartner to fetch.
     */
    where?: DeliveryPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPartners to fetch.
     */
    orderBy?: DeliveryPartnerOrderByWithRelationInput | DeliveryPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryPartners.
     */
    cursor?: DeliveryPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryPartners.
     */
    distinct?: DeliveryPartnerScalarFieldEnum | DeliveryPartnerScalarFieldEnum[]
  }

  /**
   * DeliveryPartner findMany
   */
  export type DeliveryPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryPartners to fetch.
     */
    where?: DeliveryPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryPartners to fetch.
     */
    orderBy?: DeliveryPartnerOrderByWithRelationInput | DeliveryPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryPartners.
     */
    cursor?: DeliveryPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryPartners.
     */
    skip?: number
    distinct?: DeliveryPartnerScalarFieldEnum | DeliveryPartnerScalarFieldEnum[]
  }

  /**
   * DeliveryPartner create
   */
  export type DeliveryPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryPartner.
     */
    data: XOR<DeliveryPartnerCreateInput, DeliveryPartnerUncheckedCreateInput>
  }

  /**
   * DeliveryPartner createMany
   */
  export type DeliveryPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryPartners.
     */
    data: DeliveryPartnerCreateManyInput | DeliveryPartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryPartner createManyAndReturn
   */
  export type DeliveryPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryPartners.
     */
    data: DeliveryPartnerCreateManyInput | DeliveryPartnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryPartner update
   */
  export type DeliveryPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryPartner.
     */
    data: XOR<DeliveryPartnerUpdateInput, DeliveryPartnerUncheckedUpdateInput>
    /**
     * Choose, which DeliveryPartner to update.
     */
    where: DeliveryPartnerWhereUniqueInput
  }

  /**
   * DeliveryPartner updateMany
   */
  export type DeliveryPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryPartners.
     */
    data: XOR<DeliveryPartnerUpdateManyMutationInput, DeliveryPartnerUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryPartners to update
     */
    where?: DeliveryPartnerWhereInput
    /**
     * Limit how many DeliveryPartners to update.
     */
    limit?: number
  }

  /**
   * DeliveryPartner updateManyAndReturn
   */
  export type DeliveryPartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryPartners.
     */
    data: XOR<DeliveryPartnerUpdateManyMutationInput, DeliveryPartnerUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryPartners to update
     */
    where?: DeliveryPartnerWhereInput
    /**
     * Limit how many DeliveryPartners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryPartner upsert
   */
  export type DeliveryPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryPartner to update in case it exists.
     */
    where: DeliveryPartnerWhereUniqueInput
    /**
     * In case the DeliveryPartner found by the `where` argument doesn't exist, create a new DeliveryPartner with this data.
     */
    create: XOR<DeliveryPartnerCreateInput, DeliveryPartnerUncheckedCreateInput>
    /**
     * In case the DeliveryPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryPartnerUpdateInput, DeliveryPartnerUncheckedUpdateInput>
  }

  /**
   * DeliveryPartner delete
   */
  export type DeliveryPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    /**
     * Filter which DeliveryPartner to delete.
     */
    where: DeliveryPartnerWhereUniqueInput
  }

  /**
   * DeliveryPartner deleteMany
   */
  export type DeliveryPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryPartners to delete
     */
    where?: DeliveryPartnerWhereInput
    /**
     * Limit how many DeliveryPartners to delete.
     */
    limit?: number
  }

  /**
   * DeliveryPartner.DeliveryBooking
   */
  export type DeliveryPartner$DeliveryBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    where?: DeliveryBookingWhereInput
    orderBy?: DeliveryBookingOrderByWithRelationInput | DeliveryBookingOrderByWithRelationInput[]
    cursor?: DeliveryBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryBookingScalarFieldEnum | DeliveryBookingScalarFieldEnum[]
  }

  /**
   * DeliveryPartner without action
   */
  export type DeliveryPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryTracking
   */

  export type AggregateDeliveryTracking = {
    _count: DeliveryTrackingCountAggregateOutputType | null
    _min: DeliveryTrackingMinAggregateOutputType | null
    _max: DeliveryTrackingMaxAggregateOutputType | null
  }

  export type DeliveryTrackingMinAggregateOutputType = {
    id: string | null
    delivery_booking_id: string | null
    timestamp: Date | null
    status: string | null
    notes: string | null
  }

  export type DeliveryTrackingMaxAggregateOutputType = {
    id: string | null
    delivery_booking_id: string | null
    timestamp: Date | null
    status: string | null
    notes: string | null
  }

  export type DeliveryTrackingCountAggregateOutputType = {
    id: number
    delivery_booking_id: number
    location: number
    timestamp: number
    status: number
    notes: number
    _all: number
  }


  export type DeliveryTrackingMinAggregateInputType = {
    id?: true
    delivery_booking_id?: true
    timestamp?: true
    status?: true
    notes?: true
  }

  export type DeliveryTrackingMaxAggregateInputType = {
    id?: true
    delivery_booking_id?: true
    timestamp?: true
    status?: true
    notes?: true
  }

  export type DeliveryTrackingCountAggregateInputType = {
    id?: true
    delivery_booking_id?: true
    location?: true
    timestamp?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type DeliveryTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTracking to aggregate.
     */
    where?: DeliveryTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTrackings to fetch.
     */
    orderBy?: DeliveryTrackingOrderByWithRelationInput | DeliveryTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryTrackings
    **/
    _count?: true | DeliveryTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryTrackingMaxAggregateInputType
  }

  export type GetDeliveryTrackingAggregateType<T extends DeliveryTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryTracking[P]>
      : GetScalarType<T[P], AggregateDeliveryTracking[P]>
  }




  export type DeliveryTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTrackingWhereInput
    orderBy?: DeliveryTrackingOrderByWithAggregationInput | DeliveryTrackingOrderByWithAggregationInput[]
    by: DeliveryTrackingScalarFieldEnum[] | DeliveryTrackingScalarFieldEnum
    having?: DeliveryTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryTrackingCountAggregateInputType | true
    _min?: DeliveryTrackingMinAggregateInputType
    _max?: DeliveryTrackingMaxAggregateInputType
  }

  export type DeliveryTrackingGroupByOutputType = {
    id: string
    delivery_booking_id: string
    location: JsonValue
    timestamp: Date
    status: string
    notes: string | null
    _count: DeliveryTrackingCountAggregateOutputType | null
    _min: DeliveryTrackingMinAggregateOutputType | null
    _max: DeliveryTrackingMaxAggregateOutputType | null
  }

  type GetDeliveryTrackingGroupByPayload<T extends DeliveryTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryTrackingGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_booking_id?: boolean
    location?: boolean
    timestamp?: boolean
    status?: boolean
    notes?: boolean
    DeliveryBooking?: boolean | DeliveryBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTracking"]>

  export type DeliveryTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_booking_id?: boolean
    location?: boolean
    timestamp?: boolean
    status?: boolean
    notes?: boolean
    DeliveryBooking?: boolean | DeliveryBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTracking"]>

  export type DeliveryTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delivery_booking_id?: boolean
    location?: boolean
    timestamp?: boolean
    status?: boolean
    notes?: boolean
    DeliveryBooking?: boolean | DeliveryBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryTracking"]>

  export type DeliveryTrackingSelectScalar = {
    id?: boolean
    delivery_booking_id?: boolean
    location?: boolean
    timestamp?: boolean
    status?: boolean
    notes?: boolean
  }

  export type DeliveryTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "delivery_booking_id" | "location" | "timestamp" | "status" | "notes", ExtArgs["result"]["deliveryTracking"]>
  export type DeliveryTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryBooking?: boolean | DeliveryBookingDefaultArgs<ExtArgs>
  }
  export type DeliveryTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryBooking?: boolean | DeliveryBookingDefaultArgs<ExtArgs>
  }
  export type DeliveryTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryBooking?: boolean | DeliveryBookingDefaultArgs<ExtArgs>
  }

  export type $DeliveryTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryTracking"
    objects: {
      DeliveryBooking: Prisma.$DeliveryBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      delivery_booking_id: string
      location: Prisma.JsonValue
      timestamp: Date
      status: string
      notes: string | null
    }, ExtArgs["result"]["deliveryTracking"]>
    composites: {}
  }

  type DeliveryTrackingGetPayload<S extends boolean | null | undefined | DeliveryTrackingDefaultArgs> = $Result.GetResult<Prisma.$DeliveryTrackingPayload, S>

  type DeliveryTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryTrackingCountAggregateInputType | true
    }

  export interface DeliveryTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryTracking'], meta: { name: 'DeliveryTracking' } }
    /**
     * Find zero or one DeliveryTracking that matches the filter.
     * @param {DeliveryTrackingFindUniqueArgs} args - Arguments to find a DeliveryTracking
     * @example
     * // Get one DeliveryTracking
     * const deliveryTracking = await prisma.deliveryTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryTrackingFindUniqueArgs>(args: SelectSubset<T, DeliveryTrackingFindUniqueArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryTrackingFindUniqueOrThrowArgs} args - Arguments to find a DeliveryTracking
     * @example
     * // Get one DeliveryTracking
     * const deliveryTracking = await prisma.deliveryTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTrackingFindFirstArgs} args - Arguments to find a DeliveryTracking
     * @example
     * // Get one DeliveryTracking
     * const deliveryTracking = await prisma.deliveryTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryTrackingFindFirstArgs>(args?: SelectSubset<T, DeliveryTrackingFindFirstArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTrackingFindFirstOrThrowArgs} args - Arguments to find a DeliveryTracking
     * @example
     * // Get one DeliveryTracking
     * const deliveryTracking = await prisma.deliveryTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryTrackings
     * const deliveryTrackings = await prisma.deliveryTracking.findMany()
     * 
     * // Get first 10 DeliveryTrackings
     * const deliveryTrackings = await prisma.deliveryTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryTrackingWithIdOnly = await prisma.deliveryTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryTrackingFindManyArgs>(args?: SelectSubset<T, DeliveryTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryTracking.
     * @param {DeliveryTrackingCreateArgs} args - Arguments to create a DeliveryTracking.
     * @example
     * // Create one DeliveryTracking
     * const DeliveryTracking = await prisma.deliveryTracking.create({
     *   data: {
     *     // ... data to create a DeliveryTracking
     *   }
     * })
     * 
     */
    create<T extends DeliveryTrackingCreateArgs>(args: SelectSubset<T, DeliveryTrackingCreateArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryTrackings.
     * @param {DeliveryTrackingCreateManyArgs} args - Arguments to create many DeliveryTrackings.
     * @example
     * // Create many DeliveryTrackings
     * const deliveryTracking = await prisma.deliveryTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryTrackingCreateManyArgs>(args?: SelectSubset<T, DeliveryTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryTrackings and returns the data saved in the database.
     * @param {DeliveryTrackingCreateManyAndReturnArgs} args - Arguments to create many DeliveryTrackings.
     * @example
     * // Create many DeliveryTrackings
     * const deliveryTracking = await prisma.deliveryTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryTrackings and only return the `id`
     * const deliveryTrackingWithIdOnly = await prisma.deliveryTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryTracking.
     * @param {DeliveryTrackingDeleteArgs} args - Arguments to delete one DeliveryTracking.
     * @example
     * // Delete one DeliveryTracking
     * const DeliveryTracking = await prisma.deliveryTracking.delete({
     *   where: {
     *     // ... filter to delete one DeliveryTracking
     *   }
     * })
     * 
     */
    delete<T extends DeliveryTrackingDeleteArgs>(args: SelectSubset<T, DeliveryTrackingDeleteArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryTracking.
     * @param {DeliveryTrackingUpdateArgs} args - Arguments to update one DeliveryTracking.
     * @example
     * // Update one DeliveryTracking
     * const deliveryTracking = await prisma.deliveryTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryTrackingUpdateArgs>(args: SelectSubset<T, DeliveryTrackingUpdateArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryTrackings.
     * @param {DeliveryTrackingDeleteManyArgs} args - Arguments to filter DeliveryTrackings to delete.
     * @example
     * // Delete a few DeliveryTrackings
     * const { count } = await prisma.deliveryTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryTrackingDeleteManyArgs>(args?: SelectSubset<T, DeliveryTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryTrackings
     * const deliveryTracking = await prisma.deliveryTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryTrackingUpdateManyArgs>(args: SelectSubset<T, DeliveryTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTrackings and returns the data updated in the database.
     * @param {DeliveryTrackingUpdateManyAndReturnArgs} args - Arguments to update many DeliveryTrackings.
     * @example
     * // Update many DeliveryTrackings
     * const deliveryTracking = await prisma.deliveryTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryTrackings and only return the `id`
     * const deliveryTrackingWithIdOnly = await prisma.deliveryTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryTracking.
     * @param {DeliveryTrackingUpsertArgs} args - Arguments to update or create a DeliveryTracking.
     * @example
     * // Update or create a DeliveryTracking
     * const deliveryTracking = await prisma.deliveryTracking.upsert({
     *   create: {
     *     // ... data to create a DeliveryTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryTracking we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryTrackingUpsertArgs>(args: SelectSubset<T, DeliveryTrackingUpsertArgs<ExtArgs>>): Prisma__DeliveryTrackingClient<$Result.GetResult<Prisma.$DeliveryTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTrackingCountArgs} args - Arguments to filter DeliveryTrackings to count.
     * @example
     * // Count the number of DeliveryTrackings
     * const count = await prisma.deliveryTracking.count({
     *   where: {
     *     // ... the filter for the DeliveryTrackings we want to count
     *   }
     * })
    **/
    count<T extends DeliveryTrackingCountArgs>(
      args?: Subset<T, DeliveryTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryTrackingAggregateArgs>(args: Subset<T, DeliveryTrackingAggregateArgs>): Prisma.PrismaPromise<GetDeliveryTrackingAggregateType<T>>

    /**
     * Group by DeliveryTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryTrackingGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryTracking model
   */
  readonly fields: DeliveryTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeliveryBooking<T extends DeliveryBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryBookingDefaultArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryTracking model
   */
  interface DeliveryTrackingFieldRefs {
    readonly id: FieldRef<"DeliveryTracking", 'String'>
    readonly delivery_booking_id: FieldRef<"DeliveryTracking", 'String'>
    readonly location: FieldRef<"DeliveryTracking", 'Json'>
    readonly timestamp: FieldRef<"DeliveryTracking", 'DateTime'>
    readonly status: FieldRef<"DeliveryTracking", 'String'>
    readonly notes: FieldRef<"DeliveryTracking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryTracking findUnique
   */
  export type DeliveryTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTracking to fetch.
     */
    where: DeliveryTrackingWhereUniqueInput
  }

  /**
   * DeliveryTracking findUniqueOrThrow
   */
  export type DeliveryTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTracking to fetch.
     */
    where: DeliveryTrackingWhereUniqueInput
  }

  /**
   * DeliveryTracking findFirst
   */
  export type DeliveryTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTracking to fetch.
     */
    where?: DeliveryTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTrackings to fetch.
     */
    orderBy?: DeliveryTrackingOrderByWithRelationInput | DeliveryTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTrackings.
     */
    cursor?: DeliveryTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTrackings.
     */
    distinct?: DeliveryTrackingScalarFieldEnum | DeliveryTrackingScalarFieldEnum[]
  }

  /**
   * DeliveryTracking findFirstOrThrow
   */
  export type DeliveryTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTracking to fetch.
     */
    where?: DeliveryTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTrackings to fetch.
     */
    orderBy?: DeliveryTrackingOrderByWithRelationInput | DeliveryTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTrackings.
     */
    cursor?: DeliveryTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTrackings.
     */
    distinct?: DeliveryTrackingScalarFieldEnum | DeliveryTrackingScalarFieldEnum[]
  }

  /**
   * DeliveryTracking findMany
   */
  export type DeliveryTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTrackings to fetch.
     */
    where?: DeliveryTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTrackings to fetch.
     */
    orderBy?: DeliveryTrackingOrderByWithRelationInput | DeliveryTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryTrackings.
     */
    cursor?: DeliveryTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTrackings.
     */
    skip?: number
    distinct?: DeliveryTrackingScalarFieldEnum | DeliveryTrackingScalarFieldEnum[]
  }

  /**
   * DeliveryTracking create
   */
  export type DeliveryTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryTracking.
     */
    data: XOR<DeliveryTrackingCreateInput, DeliveryTrackingUncheckedCreateInput>
  }

  /**
   * DeliveryTracking createMany
   */
  export type DeliveryTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryTrackings.
     */
    data: DeliveryTrackingCreateManyInput | DeliveryTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryTracking createManyAndReturn
   */
  export type DeliveryTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryTrackings.
     */
    data: DeliveryTrackingCreateManyInput | DeliveryTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryTracking update
   */
  export type DeliveryTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryTracking.
     */
    data: XOR<DeliveryTrackingUpdateInput, DeliveryTrackingUncheckedUpdateInput>
    /**
     * Choose, which DeliveryTracking to update.
     */
    where: DeliveryTrackingWhereUniqueInput
  }

  /**
   * DeliveryTracking updateMany
   */
  export type DeliveryTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryTrackings.
     */
    data: XOR<DeliveryTrackingUpdateManyMutationInput, DeliveryTrackingUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTrackings to update
     */
    where?: DeliveryTrackingWhereInput
    /**
     * Limit how many DeliveryTrackings to update.
     */
    limit?: number
  }

  /**
   * DeliveryTracking updateManyAndReturn
   */
  export type DeliveryTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryTrackings.
     */
    data: XOR<DeliveryTrackingUpdateManyMutationInput, DeliveryTrackingUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTrackings to update
     */
    where?: DeliveryTrackingWhereInput
    /**
     * Limit how many DeliveryTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryTracking upsert
   */
  export type DeliveryTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryTracking to update in case it exists.
     */
    where: DeliveryTrackingWhereUniqueInput
    /**
     * In case the DeliveryTracking found by the `where` argument doesn't exist, create a new DeliveryTracking with this data.
     */
    create: XOR<DeliveryTrackingCreateInput, DeliveryTrackingUncheckedCreateInput>
    /**
     * In case the DeliveryTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryTrackingUpdateInput, DeliveryTrackingUncheckedUpdateInput>
  }

  /**
   * DeliveryTracking delete
   */
  export type DeliveryTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
    /**
     * Filter which DeliveryTracking to delete.
     */
    where: DeliveryTrackingWhereUniqueInput
  }

  /**
   * DeliveryTracking deleteMany
   */
  export type DeliveryTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTrackings to delete
     */
    where?: DeliveryTrackingWhereInput
    /**
     * Limit how many DeliveryTrackings to delete.
     */
    limit?: number
  }

  /**
   * DeliveryTracking without action
   */
  export type DeliveryTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTracking
     */
    select?: DeliveryTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryTracking
     */
    omit?: DeliveryTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTrackingInclude<ExtArgs> | null
  }


  /**
   * Model booking_history
   */

  export type AggregateBooking_history = {
    _count: Booking_historyCountAggregateOutputType | null
    _min: Booking_historyMinAggregateOutputType | null
    _max: Booking_historyMaxAggregateOutputType | null
  }

  export type Booking_historyMinAggregateOutputType = {
    id: string | null
    booking_id: string | null
    action: string | null
    details: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Booking_historyMaxAggregateOutputType = {
    id: string | null
    booking_id: string | null
    action: string | null
    details: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Booking_historyCountAggregateOutputType = {
    id: number
    booking_id: number
    action: number
    details: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Booking_historyMinAggregateInputType = {
    id?: true
    booking_id?: true
    action?: true
    details?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type Booking_historyMaxAggregateInputType = {
    id?: true
    booking_id?: true
    action?: true
    details?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type Booking_historyCountAggregateInputType = {
    id?: true
    booking_id?: true
    action?: true
    details?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Booking_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_history to aggregate.
     */
    where?: booking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_histories to fetch.
     */
    orderBy?: booking_historyOrderByWithRelationInput | booking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: booking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned booking_histories
    **/
    _count?: true | Booking_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Booking_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Booking_historyMaxAggregateInputType
  }

  export type GetBooking_historyAggregateType<T extends Booking_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking_history[P]>
      : GetScalarType<T[P], AggregateBooking_history[P]>
  }




  export type booking_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_historyWhereInput
    orderBy?: booking_historyOrderByWithAggregationInput | booking_historyOrderByWithAggregationInput[]
    by: Booking_historyScalarFieldEnum[] | Booking_historyScalarFieldEnum
    having?: booking_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Booking_historyCountAggregateInputType | true
    _min?: Booking_historyMinAggregateInputType
    _max?: Booking_historyMaxAggregateInputType
  }

  export type Booking_historyGroupByOutputType = {
    id: string
    booking_id: string
    action: string
    details: string
    created_by: string
    created_at: Date
    updated_at: Date
    _count: Booking_historyCountAggregateOutputType | null
    _min: Booking_historyMinAggregateOutputType | null
    _max: Booking_historyMaxAggregateOutputType | null
  }

  type GetBooking_historyGroupByPayload<T extends booking_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Booking_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Booking_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Booking_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Booking_historyGroupByOutputType[P]>
        }
      >
    >


  export type booking_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    action?: boolean
    details?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking_history"]>

  export type booking_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    action?: boolean
    details?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking_history"]>

  export type booking_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    action?: boolean
    details?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking_history"]>

  export type booking_historySelectScalar = {
    id?: boolean
    booking_id?: boolean
    action?: boolean
    details?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type booking_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "booking_id" | "action" | "details" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["booking_history"]>
  export type booking_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }
  export type booking_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }
  export type booking_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }

  export type $booking_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "booking_history"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      booking_id: string
      action: string
      details: string
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["booking_history"]>
    composites: {}
  }

  type booking_historyGetPayload<S extends boolean | null | undefined | booking_historyDefaultArgs> = $Result.GetResult<Prisma.$booking_historyPayload, S>

  type booking_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<booking_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Booking_historyCountAggregateInputType | true
    }

  export interface booking_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['booking_history'], meta: { name: 'booking_history' } }
    /**
     * Find zero or one Booking_history that matches the filter.
     * @param {booking_historyFindUniqueArgs} args - Arguments to find a Booking_history
     * @example
     * // Get one Booking_history
     * const booking_history = await prisma.booking_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends booking_historyFindUniqueArgs>(args: SelectSubset<T, booking_historyFindUniqueArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {booking_historyFindUniqueOrThrowArgs} args - Arguments to find a Booking_history
     * @example
     * // Get one Booking_history
     * const booking_history = await prisma.booking_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends booking_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, booking_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_historyFindFirstArgs} args - Arguments to find a Booking_history
     * @example
     * // Get one Booking_history
     * const booking_history = await prisma.booking_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends booking_historyFindFirstArgs>(args?: SelectSubset<T, booking_historyFindFirstArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_historyFindFirstOrThrowArgs} args - Arguments to find a Booking_history
     * @example
     * // Get one Booking_history
     * const booking_history = await prisma.booking_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends booking_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, booking_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Booking_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Booking_histories
     * const booking_histories = await prisma.booking_history.findMany()
     * 
     * // Get first 10 Booking_histories
     * const booking_histories = await prisma.booking_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const booking_historyWithIdOnly = await prisma.booking_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends booking_historyFindManyArgs>(args?: SelectSubset<T, booking_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking_history.
     * @param {booking_historyCreateArgs} args - Arguments to create a Booking_history.
     * @example
     * // Create one Booking_history
     * const Booking_history = await prisma.booking_history.create({
     *   data: {
     *     // ... data to create a Booking_history
     *   }
     * })
     * 
     */
    create<T extends booking_historyCreateArgs>(args: SelectSubset<T, booking_historyCreateArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Booking_histories.
     * @param {booking_historyCreateManyArgs} args - Arguments to create many Booking_histories.
     * @example
     * // Create many Booking_histories
     * const booking_history = await prisma.booking_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends booking_historyCreateManyArgs>(args?: SelectSubset<T, booking_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Booking_histories and returns the data saved in the database.
     * @param {booking_historyCreateManyAndReturnArgs} args - Arguments to create many Booking_histories.
     * @example
     * // Create many Booking_histories
     * const booking_history = await prisma.booking_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Booking_histories and only return the `id`
     * const booking_historyWithIdOnly = await prisma.booking_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends booking_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, booking_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking_history.
     * @param {booking_historyDeleteArgs} args - Arguments to delete one Booking_history.
     * @example
     * // Delete one Booking_history
     * const Booking_history = await prisma.booking_history.delete({
     *   where: {
     *     // ... filter to delete one Booking_history
     *   }
     * })
     * 
     */
    delete<T extends booking_historyDeleteArgs>(args: SelectSubset<T, booking_historyDeleteArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking_history.
     * @param {booking_historyUpdateArgs} args - Arguments to update one Booking_history.
     * @example
     * // Update one Booking_history
     * const booking_history = await prisma.booking_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends booking_historyUpdateArgs>(args: SelectSubset<T, booking_historyUpdateArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Booking_histories.
     * @param {booking_historyDeleteManyArgs} args - Arguments to filter Booking_histories to delete.
     * @example
     * // Delete a few Booking_histories
     * const { count } = await prisma.booking_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends booking_historyDeleteManyArgs>(args?: SelectSubset<T, booking_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Booking_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Booking_histories
     * const booking_history = await prisma.booking_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends booking_historyUpdateManyArgs>(args: SelectSubset<T, booking_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Booking_histories and returns the data updated in the database.
     * @param {booking_historyUpdateManyAndReturnArgs} args - Arguments to update many Booking_histories.
     * @example
     * // Update many Booking_histories
     * const booking_history = await prisma.booking_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Booking_histories and only return the `id`
     * const booking_historyWithIdOnly = await prisma.booking_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends booking_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, booking_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking_history.
     * @param {booking_historyUpsertArgs} args - Arguments to update or create a Booking_history.
     * @example
     * // Update or create a Booking_history
     * const booking_history = await prisma.booking_history.upsert({
     *   create: {
     *     // ... data to create a Booking_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking_history we want to update
     *   }
     * })
     */
    upsert<T extends booking_historyUpsertArgs>(args: SelectSubset<T, booking_historyUpsertArgs<ExtArgs>>): Prisma__booking_historyClient<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Booking_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_historyCountArgs} args - Arguments to filter Booking_histories to count.
     * @example
     * // Count the number of Booking_histories
     * const count = await prisma.booking_history.count({
     *   where: {
     *     // ... the filter for the Booking_histories we want to count
     *   }
     * })
    **/
    count<T extends booking_historyCountArgs>(
      args?: Subset<T, booking_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Booking_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Booking_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Booking_historyAggregateArgs>(args: Subset<T, Booking_historyAggregateArgs>): Prisma.PrismaPromise<GetBooking_historyAggregateType<T>>

    /**
     * Group by Booking_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends booking_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: booking_historyGroupByArgs['orderBy'] }
        : { orderBy?: booking_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, booking_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooking_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the booking_history model
   */
  readonly fields: booking_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for booking_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__booking_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the booking_history model
   */
  interface booking_historyFieldRefs {
    readonly id: FieldRef<"booking_history", 'String'>
    readonly booking_id: FieldRef<"booking_history", 'String'>
    readonly action: FieldRef<"booking_history", 'String'>
    readonly details: FieldRef<"booking_history", 'String'>
    readonly created_by: FieldRef<"booking_history", 'String'>
    readonly created_at: FieldRef<"booking_history", 'DateTime'>
    readonly updated_at: FieldRef<"booking_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * booking_history findUnique
   */
  export type booking_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_history to fetch.
     */
    where: booking_historyWhereUniqueInput
  }

  /**
   * booking_history findUniqueOrThrow
   */
  export type booking_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_history to fetch.
     */
    where: booking_historyWhereUniqueInput
  }

  /**
   * booking_history findFirst
   */
  export type booking_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_history to fetch.
     */
    where?: booking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_histories to fetch.
     */
    orderBy?: booking_historyOrderByWithRelationInput | booking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_histories.
     */
    cursor?: booking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_histories.
     */
    distinct?: Booking_historyScalarFieldEnum | Booking_historyScalarFieldEnum[]
  }

  /**
   * booking_history findFirstOrThrow
   */
  export type booking_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_history to fetch.
     */
    where?: booking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_histories to fetch.
     */
    orderBy?: booking_historyOrderByWithRelationInput | booking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_histories.
     */
    cursor?: booking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_histories.
     */
    distinct?: Booking_historyScalarFieldEnum | Booking_historyScalarFieldEnum[]
  }

  /**
   * booking_history findMany
   */
  export type booking_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_histories to fetch.
     */
    where?: booking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_histories to fetch.
     */
    orderBy?: booking_historyOrderByWithRelationInput | booking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing booking_histories.
     */
    cursor?: booking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_histories.
     */
    skip?: number
    distinct?: Booking_historyScalarFieldEnum | Booking_historyScalarFieldEnum[]
  }

  /**
   * booking_history create
   */
  export type booking_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a booking_history.
     */
    data: XOR<booking_historyCreateInput, booking_historyUncheckedCreateInput>
  }

  /**
   * booking_history createMany
   */
  export type booking_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many booking_histories.
     */
    data: booking_historyCreateManyInput | booking_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * booking_history createManyAndReturn
   */
  export type booking_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * The data used to create many booking_histories.
     */
    data: booking_historyCreateManyInput | booking_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * booking_history update
   */
  export type booking_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a booking_history.
     */
    data: XOR<booking_historyUpdateInput, booking_historyUncheckedUpdateInput>
    /**
     * Choose, which booking_history to update.
     */
    where: booking_historyWhereUniqueInput
  }

  /**
   * booking_history updateMany
   */
  export type booking_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update booking_histories.
     */
    data: XOR<booking_historyUpdateManyMutationInput, booking_historyUncheckedUpdateManyInput>
    /**
     * Filter which booking_histories to update
     */
    where?: booking_historyWhereInput
    /**
     * Limit how many booking_histories to update.
     */
    limit?: number
  }

  /**
   * booking_history updateManyAndReturn
   */
  export type booking_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * The data used to update booking_histories.
     */
    data: XOR<booking_historyUpdateManyMutationInput, booking_historyUncheckedUpdateManyInput>
    /**
     * Filter which booking_histories to update
     */
    where?: booking_historyWhereInput
    /**
     * Limit how many booking_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * booking_history upsert
   */
  export type booking_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the booking_history to update in case it exists.
     */
    where: booking_historyWhereUniqueInput
    /**
     * In case the booking_history found by the `where` argument doesn't exist, create a new booking_history with this data.
     */
    create: XOR<booking_historyCreateInput, booking_historyUncheckedCreateInput>
    /**
     * In case the booking_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<booking_historyUpdateInput, booking_historyUncheckedUpdateInput>
  }

  /**
   * booking_history delete
   */
  export type booking_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    /**
     * Filter which booking_history to delete.
     */
    where: booking_historyWhereUniqueInput
  }

  /**
   * booking_history deleteMany
   */
  export type booking_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_histories to delete
     */
    where?: booking_historyWhereInput
    /**
     * Limit how many booking_histories to delete.
     */
    limit?: number
  }

  /**
   * booking_history without action
   */
  export type booking_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
  }


  /**
   * Model bookings
   */

  export type AggregateBookings = {
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  export type BookingsAvgAggregateOutputType = {
    total_hours: number | null
    total_price: number | null
  }

  export type BookingsSumAggregateOutputType = {
    total_hours: number | null
    total_price: number | null
  }

  export type BookingsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    vehicle_id: string | null
    start_date: Date | null
    end_date: Date | null
    total_hours: number | null
    total_price: number | null
    status: string | null
    payment_status: string | null
    payment_details: string | null
    created_at: Date | null
    updated_at: Date | null
    pickup_location: string | null
    dropoff_location: string | null
    booking_id: string | null
    payment_intent_id: string | null
  }

  export type BookingsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    vehicle_id: string | null
    start_date: Date | null
    end_date: Date | null
    total_hours: number | null
    total_price: number | null
    status: string | null
    payment_status: string | null
    payment_details: string | null
    created_at: Date | null
    updated_at: Date | null
    pickup_location: string | null
    dropoff_location: string | null
    booking_id: string | null
    payment_intent_id: string | null
  }

  export type BookingsCountAggregateOutputType = {
    id: number
    user_id: number
    vehicle_id: number
    start_date: number
    end_date: number
    total_hours: number
    total_price: number
    status: number
    payment_status: number
    payment_details: number
    created_at: number
    updated_at: number
    pickup_location: number
    dropoff_location: number
    booking_id: number
    payment_intent_id: number
    _all: number
  }


  export type BookingsAvgAggregateInputType = {
    total_hours?: true
    total_price?: true
  }

  export type BookingsSumAggregateInputType = {
    total_hours?: true
    total_price?: true
  }

  export type BookingsMinAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    start_date?: true
    end_date?: true
    total_hours?: true
    total_price?: true
    status?: true
    payment_status?: true
    payment_details?: true
    created_at?: true
    updated_at?: true
    pickup_location?: true
    dropoff_location?: true
    booking_id?: true
    payment_intent_id?: true
  }

  export type BookingsMaxAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    start_date?: true
    end_date?: true
    total_hours?: true
    total_price?: true
    status?: true
    payment_status?: true
    payment_details?: true
    created_at?: true
    updated_at?: true
    pickup_location?: true
    dropoff_location?: true
    booking_id?: true
    payment_intent_id?: true
  }

  export type BookingsCountAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    start_date?: true
    end_date?: true
    total_hours?: true
    total_price?: true
    status?: true
    payment_status?: true
    payment_details?: true
    created_at?: true
    updated_at?: true
    pickup_location?: true
    dropoff_location?: true
    booking_id?: true
    payment_intent_id?: true
    _all?: true
  }

  export type BookingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookings to aggregate.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bookings
    **/
    _count?: true | BookingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingsMaxAggregateInputType
  }

  export type GetBookingsAggregateType<T extends BookingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBookings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookings[P]>
      : GetScalarType<T[P], AggregateBookings[P]>
  }




  export type bookingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithAggregationInput | bookingsOrderByWithAggregationInput[]
    by: BookingsScalarFieldEnum[] | BookingsScalarFieldEnum
    having?: bookingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingsCountAggregateInputType | true
    _avg?: BookingsAvgAggregateInputType
    _sum?: BookingsSumAggregateInputType
    _min?: BookingsMinAggregateInputType
    _max?: BookingsMaxAggregateInputType
  }

  export type BookingsGroupByOutputType = {
    id: string
    user_id: string
    vehicle_id: string
    start_date: Date
    end_date: Date
    total_hours: number
    total_price: number
    status: string | null
    payment_status: string | null
    payment_details: string | null
    created_at: Date | null
    updated_at: Date | null
    pickup_location: string | null
    dropoff_location: string | null
    booking_id: string | null
    payment_intent_id: string | null
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  type GetBookingsGroupByPayload<T extends bookingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingsGroupByOutputType[P]>
            : GetScalarType<T[P], BookingsGroupByOutputType[P]>
        }
      >
    >


  export type bookingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    start_date?: boolean
    end_date?: boolean
    total_hours?: boolean
    total_price?: boolean
    status?: boolean
    payment_status?: boolean
    payment_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    booking_id?: boolean
    payment_intent_id?: boolean
    DeliveryBooking?: boolean | bookings$DeliveryBookingArgs<ExtArgs>
    booking_history?: boolean | bookings$booking_historyArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    vehicles?: boolean | vehiclesDefaultArgs<ExtArgs>
    trip_initiations?: boolean | bookings$trip_initiationsArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type bookingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    start_date?: boolean
    end_date?: boolean
    total_hours?: boolean
    total_price?: boolean
    status?: boolean
    payment_status?: boolean
    payment_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    booking_id?: boolean
    payment_intent_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    vehicles?: boolean | vehiclesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type bookingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    start_date?: boolean
    end_date?: boolean
    total_hours?: boolean
    total_price?: boolean
    status?: boolean
    payment_status?: boolean
    payment_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    booking_id?: boolean
    payment_intent_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    vehicles?: boolean | vehiclesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type bookingsSelectScalar = {
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    start_date?: boolean
    end_date?: boolean
    total_hours?: boolean
    total_price?: boolean
    status?: boolean
    payment_status?: boolean
    payment_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    pickup_location?: boolean
    dropoff_location?: boolean
    booking_id?: boolean
    payment_intent_id?: boolean
  }

  export type bookingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "vehicle_id" | "start_date" | "end_date" | "total_hours" | "total_price" | "status" | "payment_status" | "payment_details" | "created_at" | "updated_at" | "pickup_location" | "dropoff_location" | "booking_id" | "payment_intent_id", ExtArgs["result"]["bookings"]>
  export type bookingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryBooking?: boolean | bookings$DeliveryBookingArgs<ExtArgs>
    booking_history?: boolean | bookings$booking_historyArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    vehicles?: boolean | vehiclesDefaultArgs<ExtArgs>
    trip_initiations?: boolean | bookings$trip_initiationsArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bookingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    vehicles?: boolean | vehiclesDefaultArgs<ExtArgs>
  }
  export type bookingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    vehicles?: boolean | vehiclesDefaultArgs<ExtArgs>
  }

  export type $bookingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bookings"
    objects: {
      DeliveryBooking: Prisma.$DeliveryBookingPayload<ExtArgs> | null
      booking_history: Prisma.$booking_historyPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      vehicles: Prisma.$vehiclesPayload<ExtArgs>
      trip_initiations: Prisma.$trip_initiationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      vehicle_id: string
      start_date: Date
      end_date: Date
      total_hours: number
      total_price: number
      status: string | null
      payment_status: string | null
      payment_details: string | null
      created_at: Date | null
      updated_at: Date | null
      pickup_location: string | null
      dropoff_location: string | null
      booking_id: string | null
      payment_intent_id: string | null
    }, ExtArgs["result"]["bookings"]>
    composites: {}
  }

  type bookingsGetPayload<S extends boolean | null | undefined | bookingsDefaultArgs> = $Result.GetResult<Prisma.$bookingsPayload, S>

  type bookingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bookingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingsCountAggregateInputType | true
    }

  export interface bookingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bookings'], meta: { name: 'bookings' } }
    /**
     * Find zero or one Bookings that matches the filter.
     * @param {bookingsFindUniqueArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bookingsFindUniqueArgs>(args: SelectSubset<T, bookingsFindUniqueArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bookings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bookingsFindUniqueOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bookingsFindUniqueOrThrowArgs>(args: SelectSubset<T, bookingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindFirstArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bookingsFindFirstArgs>(args?: SelectSubset<T, bookingsFindFirstArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindFirstOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bookingsFindFirstOrThrowArgs>(args?: SelectSubset<T, bookingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.bookings.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.bookings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingsWithIdOnly = await prisma.bookings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bookingsFindManyArgs>(args?: SelectSubset<T, bookingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bookings.
     * @param {bookingsCreateArgs} args - Arguments to create a Bookings.
     * @example
     * // Create one Bookings
     * const Bookings = await prisma.bookings.create({
     *   data: {
     *     // ... data to create a Bookings
     *   }
     * })
     * 
     */
    create<T extends bookingsCreateArgs>(args: SelectSubset<T, bookingsCreateArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {bookingsCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bookingsCreateManyArgs>(args?: SelectSubset<T, bookingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {bookingsCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingsWithIdOnly = await prisma.bookings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bookingsCreateManyAndReturnArgs>(args?: SelectSubset<T, bookingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bookings.
     * @param {bookingsDeleteArgs} args - Arguments to delete one Bookings.
     * @example
     * // Delete one Bookings
     * const Bookings = await prisma.bookings.delete({
     *   where: {
     *     // ... filter to delete one Bookings
     *   }
     * })
     * 
     */
    delete<T extends bookingsDeleteArgs>(args: SelectSubset<T, bookingsDeleteArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bookings.
     * @param {bookingsUpdateArgs} args - Arguments to update one Bookings.
     * @example
     * // Update one Bookings
     * const bookings = await prisma.bookings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bookingsUpdateArgs>(args: SelectSubset<T, bookingsUpdateArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {bookingsDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.bookings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bookingsDeleteManyArgs>(args?: SelectSubset<T, bookingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const bookings = await prisma.bookings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bookingsUpdateManyArgs>(args: SelectSubset<T, bookingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {bookingsUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const bookings = await prisma.bookings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingsWithIdOnly = await prisma.bookings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bookingsUpdateManyAndReturnArgs>(args: SelectSubset<T, bookingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bookings.
     * @param {bookingsUpsertArgs} args - Arguments to update or create a Bookings.
     * @example
     * // Update or create a Bookings
     * const bookings = await prisma.bookings.upsert({
     *   create: {
     *     // ... data to create a Bookings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookings we want to update
     *   }
     * })
     */
    upsert<T extends bookingsUpsertArgs>(args: SelectSubset<T, bookingsUpsertArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.bookings.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends bookingsCountArgs>(
      args?: Subset<T, bookingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingsAggregateArgs>(args: Subset<T, BookingsAggregateArgs>): Prisma.PrismaPromise<GetBookingsAggregateType<T>>

    /**
     * Group by Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookingsGroupByArgs['orderBy'] }
        : { orderBy?: bookingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bookings model
   */
  readonly fields: bookingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bookings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeliveryBooking<T extends bookings$DeliveryBookingArgs<ExtArgs> = {}>(args?: Subset<T, bookings$DeliveryBookingArgs<ExtArgs>>): Prisma__DeliveryBookingClient<$Result.GetResult<Prisma.$DeliveryBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking_history<T extends bookings$booking_historyArgs<ExtArgs> = {}>(args?: Subset<T, bookings$booking_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicles<T extends vehiclesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehiclesDefaultArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trip_initiations<T extends bookings$trip_initiationsArgs<ExtArgs> = {}>(args?: Subset<T, bookings$trip_initiationsArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bookings model
   */
  interface bookingsFieldRefs {
    readonly id: FieldRef<"bookings", 'String'>
    readonly user_id: FieldRef<"bookings", 'String'>
    readonly vehicle_id: FieldRef<"bookings", 'String'>
    readonly start_date: FieldRef<"bookings", 'DateTime'>
    readonly end_date: FieldRef<"bookings", 'DateTime'>
    readonly total_hours: FieldRef<"bookings", 'Float'>
    readonly total_price: FieldRef<"bookings", 'Float'>
    readonly status: FieldRef<"bookings", 'String'>
    readonly payment_status: FieldRef<"bookings", 'String'>
    readonly payment_details: FieldRef<"bookings", 'String'>
    readonly created_at: FieldRef<"bookings", 'DateTime'>
    readonly updated_at: FieldRef<"bookings", 'DateTime'>
    readonly pickup_location: FieldRef<"bookings", 'String'>
    readonly dropoff_location: FieldRef<"bookings", 'String'>
    readonly booking_id: FieldRef<"bookings", 'String'>
    readonly payment_intent_id: FieldRef<"bookings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bookings findUnique
   */
  export type bookingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings findUniqueOrThrow
   */
  export type bookingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings findFirst
   */
  export type bookingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings findFirstOrThrow
   */
  export type bookingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings findMany
   */
  export type bookingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings create
   */
  export type bookingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The data needed to create a bookings.
     */
    data: XOR<bookingsCreateInput, bookingsUncheckedCreateInput>
  }

  /**
   * bookings createMany
   */
  export type bookingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bookings.
     */
    data: bookingsCreateManyInput | bookingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bookings createManyAndReturn
   */
  export type bookingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * The data used to create many bookings.
     */
    data: bookingsCreateManyInput | bookingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bookings update
   */
  export type bookingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The data needed to update a bookings.
     */
    data: XOR<bookingsUpdateInput, bookingsUncheckedUpdateInput>
    /**
     * Choose, which bookings to update.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings updateMany
   */
  export type bookingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bookings.
     */
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyInput>
    /**
     * Filter which bookings to update
     */
    where?: bookingsWhereInput
    /**
     * Limit how many bookings to update.
     */
    limit?: number
  }

  /**
   * bookings updateManyAndReturn
   */
  export type bookingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * The data used to update bookings.
     */
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyInput>
    /**
     * Filter which bookings to update
     */
    where?: bookingsWhereInput
    /**
     * Limit how many bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bookings upsert
   */
  export type bookingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The filter to search for the bookings to update in case it exists.
     */
    where: bookingsWhereUniqueInput
    /**
     * In case the bookings found by the `where` argument doesn't exist, create a new bookings with this data.
     */
    create: XOR<bookingsCreateInput, bookingsUncheckedCreateInput>
    /**
     * In case the bookings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookingsUpdateInput, bookingsUncheckedUpdateInput>
  }

  /**
   * bookings delete
   */
  export type bookingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter which bookings to delete.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings deleteMany
   */
  export type bookingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookings to delete
     */
    where?: bookingsWhereInput
    /**
     * Limit how many bookings to delete.
     */
    limit?: number
  }

  /**
   * bookings.DeliveryBooking
   */
  export type bookings$DeliveryBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBooking
     */
    select?: DeliveryBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryBooking
     */
    omit?: DeliveryBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryBookingInclude<ExtArgs> | null
    where?: DeliveryBookingWhereInput
  }

  /**
   * bookings.booking_history
   */
  export type bookings$booking_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_history
     */
    select?: booking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_history
     */
    omit?: booking_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_historyInclude<ExtArgs> | null
    where?: booking_historyWhereInput
    orderBy?: booking_historyOrderByWithRelationInput | booking_historyOrderByWithRelationInput[]
    cursor?: booking_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Booking_historyScalarFieldEnum | Booking_historyScalarFieldEnum[]
  }

  /**
   * bookings.trip_initiations
   */
  export type bookings$trip_initiationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    where?: trip_initiationsWhereInput
  }

  /**
   * bookings without action
   */
  export type bookingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
  }


  /**
   * Model coupons
   */

  export type AggregateCoupons = {
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  export type CouponsAvgAggregateOutputType = {
    discount_value: Decimal | null
    min_booking_amount: Decimal | null
    max_discount_amount: Decimal | null
    usage_limit: number | null
    times_used: number | null
  }

  export type CouponsSumAggregateOutputType = {
    discount_value: Decimal | null
    min_booking_amount: Decimal | null
    max_discount_amount: Decimal | null
    usage_limit: number | null
    times_used: number | null
  }

  export type CouponsMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discount_type: string | null
    discount_value: Decimal | null
    min_booking_amount: Decimal | null
    max_discount_amount: Decimal | null
    start_date: Date | null
    end_date: Date | null
    usage_limit: number | null
    times_used: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponsMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discount_type: string | null
    discount_value: Decimal | null
    min_booking_amount: Decimal | null
    max_discount_amount: Decimal | null
    start_date: Date | null
    end_date: Date | null
    usage_limit: number | null
    times_used: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponsCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discount_type: number
    discount_value: number
    min_booking_amount: number
    max_discount_amount: number
    start_date: number
    end_date: number
    usage_limit: number
    times_used: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CouponsAvgAggregateInputType = {
    discount_value?: true
    min_booking_amount?: true
    max_discount_amount?: true
    usage_limit?: true
    times_used?: true
  }

  export type CouponsSumAggregateInputType = {
    discount_value?: true
    min_booking_amount?: true
    max_discount_amount?: true
    usage_limit?: true
    times_used?: true
  }

  export type CouponsMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount_type?: true
    discount_value?: true
    min_booking_amount?: true
    max_discount_amount?: true
    start_date?: true
    end_date?: true
    usage_limit?: true
    times_used?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponsMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount_type?: true
    discount_value?: true
    min_booking_amount?: true
    max_discount_amount?: true
    start_date?: true
    end_date?: true
    usage_limit?: true
    times_used?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponsCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount_type?: true
    discount_value?: true
    min_booking_amount?: true
    max_discount_amount?: true
    start_date?: true
    end_date?: true
    usage_limit?: true
    times_used?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CouponsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupons to aggregate.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coupons
    **/
    _count?: true | CouponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponsMaxAggregateInputType
  }

  export type GetCouponsAggregateType<T extends CouponsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupons[P]>
      : GetScalarType<T[P], AggregateCoupons[P]>
  }




  export type couponsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponsWhereInput
    orderBy?: couponsOrderByWithAggregationInput | couponsOrderByWithAggregationInput[]
    by: CouponsScalarFieldEnum[] | CouponsScalarFieldEnum
    having?: couponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponsCountAggregateInputType | true
    _avg?: CouponsAvgAggregateInputType
    _sum?: CouponsSumAggregateInputType
    _min?: CouponsMinAggregateInputType
    _max?: CouponsMaxAggregateInputType
  }

  export type CouponsGroupByOutputType = {
    id: string
    code: string
    description: string | null
    discount_type: string
    discount_value: Decimal
    min_booking_amount: Decimal | null
    max_discount_amount: Decimal | null
    start_date: Date | null
    end_date: Date | null
    usage_limit: number | null
    times_used: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  type GetCouponsGroupByPayload<T extends couponsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponsGroupByOutputType[P]>
            : GetScalarType<T[P], CouponsGroupByOutputType[P]>
        }
      >
    >


  export type couponsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discount_type?: boolean
    discount_value?: boolean
    min_booking_amount?: boolean
    max_discount_amount?: boolean
    start_date?: boolean
    end_date?: boolean
    usage_limit?: boolean
    times_used?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["coupons"]>

  export type couponsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discount_type?: boolean
    discount_value?: boolean
    min_booking_amount?: boolean
    max_discount_amount?: boolean
    start_date?: boolean
    end_date?: boolean
    usage_limit?: boolean
    times_used?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["coupons"]>

  export type couponsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discount_type?: boolean
    discount_value?: boolean
    min_booking_amount?: boolean
    max_discount_amount?: boolean
    start_date?: boolean
    end_date?: boolean
    usage_limit?: boolean
    times_used?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["coupons"]>

  export type couponsSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discount_type?: boolean
    discount_value?: boolean
    min_booking_amount?: boolean
    max_discount_amount?: boolean
    start_date?: boolean
    end_date?: boolean
    usage_limit?: boolean
    times_used?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type couponsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discount_type" | "discount_value" | "min_booking_amount" | "max_discount_amount" | "start_date" | "end_date" | "usage_limit" | "times_used" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["coupons"]>

  export type $couponsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coupons"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      discount_type: string
      discount_value: Prisma.Decimal
      min_booking_amount: Prisma.Decimal | null
      max_discount_amount: Prisma.Decimal | null
      start_date: Date | null
      end_date: Date | null
      usage_limit: number | null
      times_used: number | null
      is_active: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["coupons"]>
    composites: {}
  }

  type couponsGetPayload<S extends boolean | null | undefined | couponsDefaultArgs> = $Result.GetResult<Prisma.$couponsPayload, S>

  type couponsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<couponsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponsCountAggregateInputType | true
    }

  export interface couponsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coupons'], meta: { name: 'coupons' } }
    /**
     * Find zero or one Coupons that matches the filter.
     * @param {couponsFindUniqueArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends couponsFindUniqueArgs>(args: SelectSubset<T, couponsFindUniqueArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {couponsFindUniqueOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends couponsFindUniqueOrThrowArgs>(args: SelectSubset<T, couponsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends couponsFindFirstArgs>(args?: SelectSubset<T, couponsFindFirstArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends couponsFindFirstOrThrowArgs>(args?: SelectSubset<T, couponsFindFirstOrThrowArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupons.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponsWithIdOnly = await prisma.coupons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends couponsFindManyArgs>(args?: SelectSubset<T, couponsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupons.
     * @param {couponsCreateArgs} args - Arguments to create a Coupons.
     * @example
     * // Create one Coupons
     * const Coupons = await prisma.coupons.create({
     *   data: {
     *     // ... data to create a Coupons
     *   }
     * })
     * 
     */
    create<T extends couponsCreateArgs>(args: SelectSubset<T, couponsCreateArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {couponsCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupons = await prisma.coupons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends couponsCreateManyArgs>(args?: SelectSubset<T, couponsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {couponsCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupons = await prisma.coupons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponsWithIdOnly = await prisma.coupons.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends couponsCreateManyAndReturnArgs>(args?: SelectSubset<T, couponsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupons.
     * @param {couponsDeleteArgs} args - Arguments to delete one Coupons.
     * @example
     * // Delete one Coupons
     * const Coupons = await prisma.coupons.delete({
     *   where: {
     *     // ... filter to delete one Coupons
     *   }
     * })
     * 
     */
    delete<T extends couponsDeleteArgs>(args: SelectSubset<T, couponsDeleteArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupons.
     * @param {couponsUpdateArgs} args - Arguments to update one Coupons.
     * @example
     * // Update one Coupons
     * const coupons = await prisma.coupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends couponsUpdateArgs>(args: SelectSubset<T, couponsUpdateArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {couponsDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends couponsDeleteManyArgs>(args?: SelectSubset<T, couponsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends couponsUpdateManyArgs>(args: SelectSubset<T, couponsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {couponsUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponsWithIdOnly = await prisma.coupons.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends couponsUpdateManyAndReturnArgs>(args: SelectSubset<T, couponsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupons.
     * @param {couponsUpsertArgs} args - Arguments to update or create a Coupons.
     * @example
     * // Update or create a Coupons
     * const coupons = await prisma.coupons.upsert({
     *   create: {
     *     // ... data to create a Coupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupons we want to update
     *   }
     * })
     */
    upsert<T extends couponsUpsertArgs>(args: SelectSubset<T, couponsUpsertArgs<ExtArgs>>): Prisma__couponsClient<$Result.GetResult<Prisma.$couponsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupons.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends couponsCountArgs>(
      args?: Subset<T, couponsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponsAggregateArgs>(args: Subset<T, CouponsAggregateArgs>): Prisma.PrismaPromise<GetCouponsAggregateType<T>>

    /**
     * Group by Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends couponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: couponsGroupByArgs['orderBy'] }
        : { orderBy?: couponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, couponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coupons model
   */
  readonly fields: couponsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__couponsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coupons model
   */
  interface couponsFieldRefs {
    readonly id: FieldRef<"coupons", 'String'>
    readonly code: FieldRef<"coupons", 'String'>
    readonly description: FieldRef<"coupons", 'String'>
    readonly discount_type: FieldRef<"coupons", 'String'>
    readonly discount_value: FieldRef<"coupons", 'Decimal'>
    readonly min_booking_amount: FieldRef<"coupons", 'Decimal'>
    readonly max_discount_amount: FieldRef<"coupons", 'Decimal'>
    readonly start_date: FieldRef<"coupons", 'DateTime'>
    readonly end_date: FieldRef<"coupons", 'DateTime'>
    readonly usage_limit: FieldRef<"coupons", 'Int'>
    readonly times_used: FieldRef<"coupons", 'Int'>
    readonly is_active: FieldRef<"coupons", 'Boolean'>
    readonly created_at: FieldRef<"coupons", 'DateTime'>
    readonly updated_at: FieldRef<"coupons", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * coupons findUnique
   */
  export type couponsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons findUniqueOrThrow
   */
  export type couponsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons findFirst
   */
  export type couponsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * coupons findFirstOrThrow
   */
  export type couponsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * coupons findMany
   */
  export type couponsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponsOrderByWithRelationInput | couponsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coupons.
     */
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    distinct?: CouponsScalarFieldEnum | CouponsScalarFieldEnum[]
  }

  /**
   * coupons create
   */
  export type couponsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * The data needed to create a coupons.
     */
    data: XOR<couponsCreateInput, couponsUncheckedCreateInput>
  }

  /**
   * coupons createMany
   */
  export type couponsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coupons.
     */
    data: couponsCreateManyInput | couponsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coupons createManyAndReturn
   */
  export type couponsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * The data used to create many coupons.
     */
    data: couponsCreateManyInput | couponsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coupons update
   */
  export type couponsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * The data needed to update a coupons.
     */
    data: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
    /**
     * Choose, which coupons to update.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons updateMany
   */
  export type couponsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coupons.
     */
    data: XOR<couponsUpdateManyMutationInput, couponsUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponsWhereInput
    /**
     * Limit how many coupons to update.
     */
    limit?: number
  }

  /**
   * coupons updateManyAndReturn
   */
  export type couponsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * The data used to update coupons.
     */
    data: XOR<couponsUpdateManyMutationInput, couponsUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponsWhereInput
    /**
     * Limit how many coupons to update.
     */
    limit?: number
  }

  /**
   * coupons upsert
   */
  export type couponsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * The filter to search for the coupons to update in case it exists.
     */
    where: couponsWhereUniqueInput
    /**
     * In case the coupons found by the `where` argument doesn't exist, create a new coupons with this data.
     */
    create: XOR<couponsCreateInput, couponsUncheckedCreateInput>
    /**
     * In case the coupons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
  }

  /**
   * coupons delete
   */
  export type couponsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
    /**
     * Filter which coupons to delete.
     */
    where: couponsWhereUniqueInput
  }

  /**
   * coupons deleteMany
   */
  export type couponsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupons to delete
     */
    where?: couponsWhereInput
    /**
     * Limit how many coupons to delete.
     */
    limit?: number
  }

  /**
   * coupons without action
   */
  export type couponsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupons
     */
    select?: couponsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupons
     */
    omit?: couponsOmit<ExtArgs> | null
  }


  /**
   * Model document_submissions
   */

  export type AggregateDocument_submissions = {
    _count: Document_submissionsCountAggregateOutputType | null
    _avg: Document_submissionsAvgAggregateOutputType | null
    _sum: Document_submissionsSumAggregateOutputType | null
    _min: Document_submissionsMinAggregateOutputType | null
    _max: Document_submissionsMaxAggregateOutputType | null
  }

  export type Document_submissionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Document_submissionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Document_submissionsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    document_type: string | null
    document_url: string | null
    status: string | null
    admin_comments: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Document_submissionsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    document_type: string | null
    document_url: string | null
    status: string | null
    admin_comments: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Document_submissionsCountAggregateOutputType = {
    id: number
    user_id: number
    document_type: number
    document_url: number
    status: number
    admin_comments: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Document_submissionsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Document_submissionsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Document_submissionsMinAggregateInputType = {
    id?: true
    user_id?: true
    document_type?: true
    document_url?: true
    status?: true
    admin_comments?: true
    created_at?: true
    updated_at?: true
  }

  export type Document_submissionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    document_type?: true
    document_url?: true
    status?: true
    admin_comments?: true
    created_at?: true
    updated_at?: true
  }

  export type Document_submissionsCountAggregateInputType = {
    id?: true
    user_id?: true
    document_type?: true
    document_url?: true
    status?: true
    admin_comments?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Document_submissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which document_submissions to aggregate.
     */
    where?: document_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_submissions to fetch.
     */
    orderBy?: document_submissionsOrderByWithRelationInput | document_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: document_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned document_submissions
    **/
    _count?: true | Document_submissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Document_submissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Document_submissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Document_submissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Document_submissionsMaxAggregateInputType
  }

  export type GetDocument_submissionsAggregateType<T extends Document_submissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument_submissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument_submissions[P]>
      : GetScalarType<T[P], AggregateDocument_submissions[P]>
  }




  export type document_submissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: document_submissionsWhereInput
    orderBy?: document_submissionsOrderByWithAggregationInput | document_submissionsOrderByWithAggregationInput[]
    by: Document_submissionsScalarFieldEnum[] | Document_submissionsScalarFieldEnum
    having?: document_submissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Document_submissionsCountAggregateInputType | true
    _avg?: Document_submissionsAvgAggregateInputType
    _sum?: Document_submissionsSumAggregateInputType
    _min?: Document_submissionsMinAggregateInputType
    _max?: Document_submissionsMaxAggregateInputType
  }

  export type Document_submissionsGroupByOutputType = {
    id: number
    user_id: number | null
    document_type: string
    document_url: string
    status: string | null
    admin_comments: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Document_submissionsCountAggregateOutputType | null
    _avg: Document_submissionsAvgAggregateOutputType | null
    _sum: Document_submissionsSumAggregateOutputType | null
    _min: Document_submissionsMinAggregateOutputType | null
    _max: Document_submissionsMaxAggregateOutputType | null
  }

  type GetDocument_submissionsGroupByPayload<T extends document_submissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Document_submissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Document_submissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Document_submissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Document_submissionsGroupByOutputType[P]>
        }
      >
    >


  export type document_submissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    document_type?: boolean
    document_url?: boolean
    status?: boolean
    admin_comments?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["document_submissions"]>

  export type document_submissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    document_type?: boolean
    document_url?: boolean
    status?: boolean
    admin_comments?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["document_submissions"]>

  export type document_submissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    document_type?: boolean
    document_url?: boolean
    status?: boolean
    admin_comments?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["document_submissions"]>

  export type document_submissionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    document_type?: boolean
    document_url?: boolean
    status?: boolean
    admin_comments?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type document_submissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "document_type" | "document_url" | "status" | "admin_comments" | "created_at" | "updated_at", ExtArgs["result"]["document_submissions"]>

  export type $document_submissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "document_submissions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      document_type: string
      document_url: string
      status: string | null
      admin_comments: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["document_submissions"]>
    composites: {}
  }

  type document_submissionsGetPayload<S extends boolean | null | undefined | document_submissionsDefaultArgs> = $Result.GetResult<Prisma.$document_submissionsPayload, S>

  type document_submissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<document_submissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Document_submissionsCountAggregateInputType | true
    }

  export interface document_submissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['document_submissions'], meta: { name: 'document_submissions' } }
    /**
     * Find zero or one Document_submissions that matches the filter.
     * @param {document_submissionsFindUniqueArgs} args - Arguments to find a Document_submissions
     * @example
     * // Get one Document_submissions
     * const document_submissions = await prisma.document_submissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends document_submissionsFindUniqueArgs>(args: SelectSubset<T, document_submissionsFindUniqueArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document_submissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {document_submissionsFindUniqueOrThrowArgs} args - Arguments to find a Document_submissions
     * @example
     * // Get one Document_submissions
     * const document_submissions = await prisma.document_submissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends document_submissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, document_submissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_submissionsFindFirstArgs} args - Arguments to find a Document_submissions
     * @example
     * // Get one Document_submissions
     * const document_submissions = await prisma.document_submissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends document_submissionsFindFirstArgs>(args?: SelectSubset<T, document_submissionsFindFirstArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document_submissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_submissionsFindFirstOrThrowArgs} args - Arguments to find a Document_submissions
     * @example
     * // Get one Document_submissions
     * const document_submissions = await prisma.document_submissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends document_submissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, document_submissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Document_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_submissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Document_submissions
     * const document_submissions = await prisma.document_submissions.findMany()
     * 
     * // Get first 10 Document_submissions
     * const document_submissions = await prisma.document_submissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const document_submissionsWithIdOnly = await prisma.document_submissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends document_submissionsFindManyArgs>(args?: SelectSubset<T, document_submissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document_submissions.
     * @param {document_submissionsCreateArgs} args - Arguments to create a Document_submissions.
     * @example
     * // Create one Document_submissions
     * const Document_submissions = await prisma.document_submissions.create({
     *   data: {
     *     // ... data to create a Document_submissions
     *   }
     * })
     * 
     */
    create<T extends document_submissionsCreateArgs>(args: SelectSubset<T, document_submissionsCreateArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Document_submissions.
     * @param {document_submissionsCreateManyArgs} args - Arguments to create many Document_submissions.
     * @example
     * // Create many Document_submissions
     * const document_submissions = await prisma.document_submissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends document_submissionsCreateManyArgs>(args?: SelectSubset<T, document_submissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Document_submissions and returns the data saved in the database.
     * @param {document_submissionsCreateManyAndReturnArgs} args - Arguments to create many Document_submissions.
     * @example
     * // Create many Document_submissions
     * const document_submissions = await prisma.document_submissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Document_submissions and only return the `id`
     * const document_submissionsWithIdOnly = await prisma.document_submissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends document_submissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, document_submissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document_submissions.
     * @param {document_submissionsDeleteArgs} args - Arguments to delete one Document_submissions.
     * @example
     * // Delete one Document_submissions
     * const Document_submissions = await prisma.document_submissions.delete({
     *   where: {
     *     // ... filter to delete one Document_submissions
     *   }
     * })
     * 
     */
    delete<T extends document_submissionsDeleteArgs>(args: SelectSubset<T, document_submissionsDeleteArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document_submissions.
     * @param {document_submissionsUpdateArgs} args - Arguments to update one Document_submissions.
     * @example
     * // Update one Document_submissions
     * const document_submissions = await prisma.document_submissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends document_submissionsUpdateArgs>(args: SelectSubset<T, document_submissionsUpdateArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Document_submissions.
     * @param {document_submissionsDeleteManyArgs} args - Arguments to filter Document_submissions to delete.
     * @example
     * // Delete a few Document_submissions
     * const { count } = await prisma.document_submissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends document_submissionsDeleteManyArgs>(args?: SelectSubset<T, document_submissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Document_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_submissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Document_submissions
     * const document_submissions = await prisma.document_submissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends document_submissionsUpdateManyArgs>(args: SelectSubset<T, document_submissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Document_submissions and returns the data updated in the database.
     * @param {document_submissionsUpdateManyAndReturnArgs} args - Arguments to update many Document_submissions.
     * @example
     * // Update many Document_submissions
     * const document_submissions = await prisma.document_submissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Document_submissions and only return the `id`
     * const document_submissionsWithIdOnly = await prisma.document_submissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends document_submissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, document_submissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document_submissions.
     * @param {document_submissionsUpsertArgs} args - Arguments to update or create a Document_submissions.
     * @example
     * // Update or create a Document_submissions
     * const document_submissions = await prisma.document_submissions.upsert({
     *   create: {
     *     // ... data to create a Document_submissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document_submissions we want to update
     *   }
     * })
     */
    upsert<T extends document_submissionsUpsertArgs>(args: SelectSubset<T, document_submissionsUpsertArgs<ExtArgs>>): Prisma__document_submissionsClient<$Result.GetResult<Prisma.$document_submissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Document_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_submissionsCountArgs} args - Arguments to filter Document_submissions to count.
     * @example
     * // Count the number of Document_submissions
     * const count = await prisma.document_submissions.count({
     *   where: {
     *     // ... the filter for the Document_submissions we want to count
     *   }
     * })
    **/
    count<T extends document_submissionsCountArgs>(
      args?: Subset<T, document_submissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Document_submissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Document_submissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Document_submissionsAggregateArgs>(args: Subset<T, Document_submissionsAggregateArgs>): Prisma.PrismaPromise<GetDocument_submissionsAggregateType<T>>

    /**
     * Group by Document_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {document_submissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends document_submissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: document_submissionsGroupByArgs['orderBy'] }
        : { orderBy?: document_submissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, document_submissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocument_submissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the document_submissions model
   */
  readonly fields: document_submissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for document_submissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__document_submissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the document_submissions model
   */
  interface document_submissionsFieldRefs {
    readonly id: FieldRef<"document_submissions", 'Int'>
    readonly user_id: FieldRef<"document_submissions", 'Int'>
    readonly document_type: FieldRef<"document_submissions", 'String'>
    readonly document_url: FieldRef<"document_submissions", 'String'>
    readonly status: FieldRef<"document_submissions", 'String'>
    readonly admin_comments: FieldRef<"document_submissions", 'String'>
    readonly created_at: FieldRef<"document_submissions", 'DateTime'>
    readonly updated_at: FieldRef<"document_submissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * document_submissions findUnique
   */
  export type document_submissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which document_submissions to fetch.
     */
    where: document_submissionsWhereUniqueInput
  }

  /**
   * document_submissions findUniqueOrThrow
   */
  export type document_submissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which document_submissions to fetch.
     */
    where: document_submissionsWhereUniqueInput
  }

  /**
   * document_submissions findFirst
   */
  export type document_submissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which document_submissions to fetch.
     */
    where?: document_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_submissions to fetch.
     */
    orderBy?: document_submissionsOrderByWithRelationInput | document_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for document_submissions.
     */
    cursor?: document_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of document_submissions.
     */
    distinct?: Document_submissionsScalarFieldEnum | Document_submissionsScalarFieldEnum[]
  }

  /**
   * document_submissions findFirstOrThrow
   */
  export type document_submissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which document_submissions to fetch.
     */
    where?: document_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_submissions to fetch.
     */
    orderBy?: document_submissionsOrderByWithRelationInput | document_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for document_submissions.
     */
    cursor?: document_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of document_submissions.
     */
    distinct?: Document_submissionsScalarFieldEnum | Document_submissionsScalarFieldEnum[]
  }

  /**
   * document_submissions findMany
   */
  export type document_submissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * Filter, which document_submissions to fetch.
     */
    where?: document_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of document_submissions to fetch.
     */
    orderBy?: document_submissionsOrderByWithRelationInput | document_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing document_submissions.
     */
    cursor?: document_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_submissions.
     */
    skip?: number
    distinct?: Document_submissionsScalarFieldEnum | Document_submissionsScalarFieldEnum[]
  }

  /**
   * document_submissions create
   */
  export type document_submissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * The data needed to create a document_submissions.
     */
    data: XOR<document_submissionsCreateInput, document_submissionsUncheckedCreateInput>
  }

  /**
   * document_submissions createMany
   */
  export type document_submissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many document_submissions.
     */
    data: document_submissionsCreateManyInput | document_submissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * document_submissions createManyAndReturn
   */
  export type document_submissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * The data used to create many document_submissions.
     */
    data: document_submissionsCreateManyInput | document_submissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * document_submissions update
   */
  export type document_submissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * The data needed to update a document_submissions.
     */
    data: XOR<document_submissionsUpdateInput, document_submissionsUncheckedUpdateInput>
    /**
     * Choose, which document_submissions to update.
     */
    where: document_submissionsWhereUniqueInput
  }

  /**
   * document_submissions updateMany
   */
  export type document_submissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update document_submissions.
     */
    data: XOR<document_submissionsUpdateManyMutationInput, document_submissionsUncheckedUpdateManyInput>
    /**
     * Filter which document_submissions to update
     */
    where?: document_submissionsWhereInput
    /**
     * Limit how many document_submissions to update.
     */
    limit?: number
  }

  /**
   * document_submissions updateManyAndReturn
   */
  export type document_submissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * The data used to update document_submissions.
     */
    data: XOR<document_submissionsUpdateManyMutationInput, document_submissionsUncheckedUpdateManyInput>
    /**
     * Filter which document_submissions to update
     */
    where?: document_submissionsWhereInput
    /**
     * Limit how many document_submissions to update.
     */
    limit?: number
  }

  /**
   * document_submissions upsert
   */
  export type document_submissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * The filter to search for the document_submissions to update in case it exists.
     */
    where: document_submissionsWhereUniqueInput
    /**
     * In case the document_submissions found by the `where` argument doesn't exist, create a new document_submissions with this data.
     */
    create: XOR<document_submissionsCreateInput, document_submissionsUncheckedCreateInput>
    /**
     * In case the document_submissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<document_submissionsUpdateInput, document_submissionsUncheckedUpdateInput>
  }

  /**
   * document_submissions delete
   */
  export type document_submissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
    /**
     * Filter which document_submissions to delete.
     */
    where: document_submissionsWhereUniqueInput
  }

  /**
   * document_submissions deleteMany
   */
  export type document_submissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which document_submissions to delete
     */
    where?: document_submissionsWhereInput
    /**
     * Limit how many document_submissions to delete.
     */
    limit?: number
  }

  /**
   * document_submissions without action
   */
  export type document_submissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the document_submissions
     */
    select?: document_submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the document_submissions
     */
    omit?: document_submissionsOmit<ExtArgs> | null
  }


  /**
   * Model documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: string | null
    status: string | null
    file_url: string | null
    rejection_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: string | null
    status: string | null
    file_url: string | null
    rejection_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    status: number
    file_url: number
    rejection_reason: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DocumentsMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    status?: true
    file_url?: true
    rejection_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    status?: true
    file_url?: true
    rejection_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    status?: true
    file_url?: true
    rejection_reason?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to aggregate.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithAggregationInput | documentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: string
    user_id: string
    type: string
    status: string | null
    file_url: string
    rejection_reason: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: DocumentsCountAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    status?: boolean
    file_url?: boolean
    rejection_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    status?: boolean
    file_url?: boolean
    rejection_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    status?: boolean
    file_url?: boolean
    rejection_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    status?: boolean
    file_url?: boolean
    rejection_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type documentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "status" | "file_url" | "rejection_reason" | "created_at" | "updated_at", ExtArgs["result"]["documents"]>

  export type $documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documents"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      type: string
      status: string | null
      file_url: string
      rejection_reason: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type documentsGetPayload<S extends boolean | null | undefined | documentsDefaultArgs> = $Result.GetResult<Prisma.$documentsPayload, S>

  type documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<documentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documents'], meta: { name: 'documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {documentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentsFindUniqueArgs>(args: SelectSubset<T, documentsFindUniqueArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {documentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentsFindFirstArgs>(args?: SelectSubset<T, documentsFindFirstArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentsFindManyArgs>(args?: SelectSubset<T, documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documents.
     * @param {documentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends documentsCreateArgs>(args: SelectSubset<T, documentsCreateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {documentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentsCreateManyArgs>(args?: SelectSubset<T, documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {documentsCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends documentsCreateManyAndReturnArgs>(args?: SelectSubset<T, documentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Documents.
     * @param {documentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends documentsDeleteArgs>(args: SelectSubset<T, documentsDeleteArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documents.
     * @param {documentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentsUpdateArgs>(args: SelectSubset<T, documentsUpdateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {documentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentsDeleteManyArgs>(args?: SelectSubset<T, documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentsUpdateManyArgs>(args: SelectSubset<T, documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {documentsUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends documentsUpdateManyAndReturnArgs>(args: SelectSubset<T, documentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Documents.
     * @param {documentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends documentsUpsertArgs>(args: SelectSubset<T, documentsUpsertArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends documentsCountArgs>(
      args?: Subset<T, documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentsGroupByArgs['orderBy'] }
        : { orderBy?: documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documents model
   */
  readonly fields: documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documents model
   */
  interface documentsFieldRefs {
    readonly id: FieldRef<"documents", 'String'>
    readonly user_id: FieldRef<"documents", 'String'>
    readonly type: FieldRef<"documents", 'String'>
    readonly status: FieldRef<"documents", 'String'>
    readonly file_url: FieldRef<"documents", 'String'>
    readonly rejection_reason: FieldRef<"documents", 'String'>
    readonly created_at: FieldRef<"documents", 'DateTime'>
    readonly updated_at: FieldRef<"documents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * documents findUnique
   */
  export type documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findUniqueOrThrow
   */
  export type documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findFirst
   */
  export type documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findFirstOrThrow
   */
  export type documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findMany
   */
  export type documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents create
   */
  export type documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data needed to create a documents.
     */
    data: XOR<documentsCreateInput, documentsUncheckedCreateInput>
  }

  /**
   * documents createMany
   */
  export type documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documents createManyAndReturn
   */
  export type documentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documents update
   */
  export type documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data needed to update a documents.
     */
    data: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
    /**
     * Choose, which documents to update.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents updateMany
   */
  export type documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documents.
     */
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyInput>
    /**
     * Filter which documents to update
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to update.
     */
    limit?: number
  }

  /**
   * documents updateManyAndReturn
   */
  export type documentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data used to update documents.
     */
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyInput>
    /**
     * Filter which documents to update
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to update.
     */
    limit?: number
  }

  /**
   * documents upsert
   */
  export type documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The filter to search for the documents to update in case it exists.
     */
    where: documentsWhereUniqueInput
    /**
     * In case the documents found by the `where` argument doesn't exist, create a new documents with this data.
     */
    create: XOR<documentsCreateInput, documentsUncheckedCreateInput>
    /**
     * In case the documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
  }

  /**
   * documents delete
   */
  export type documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Filter which documents to delete.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents deleteMany
   */
  export type documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to delete
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to delete.
     */
    limit?: number
  }

  /**
   * documents without action
   */
  export type documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
  }


  /**
   * Model email_logs
   */

  export type AggregateEmail_logs = {
    _count: Email_logsCountAggregateOutputType | null
    _min: Email_logsMinAggregateOutputType | null
    _max: Email_logsMaxAggregateOutputType | null
  }

  export type Email_logsMinAggregateOutputType = {
    id: string | null
    recipient: string | null
    subject: string | null
    message_content: string | null
    status: string | null
    error: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Email_logsMaxAggregateOutputType = {
    id: string | null
    recipient: string | null
    subject: string | null
    message_content: string | null
    status: string | null
    error: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Email_logsCountAggregateOutputType = {
    id: number
    recipient: number
    subject: number
    message_content: number
    status: number
    error: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Email_logsMinAggregateInputType = {
    id?: true
    recipient?: true
    subject?: true
    message_content?: true
    status?: true
    error?: true
    created_at?: true
    updated_at?: true
  }

  export type Email_logsMaxAggregateInputType = {
    id?: true
    recipient?: true
    subject?: true
    message_content?: true
    status?: true
    error?: true
    created_at?: true
    updated_at?: true
  }

  export type Email_logsCountAggregateInputType = {
    id?: true
    recipient?: true
    subject?: true
    message_content?: true
    status?: true
    error?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Email_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_logs to aggregate.
     */
    where?: email_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_logs to fetch.
     */
    orderBy?: email_logsOrderByWithRelationInput | email_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_logs
    **/
    _count?: true | Email_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_logsMaxAggregateInputType
  }

  export type GetEmail_logsAggregateType<T extends Email_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_logs[P]>
      : GetScalarType<T[P], AggregateEmail_logs[P]>
  }




  export type email_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_logsWhereInput
    orderBy?: email_logsOrderByWithAggregationInput | email_logsOrderByWithAggregationInput[]
    by: Email_logsScalarFieldEnum[] | Email_logsScalarFieldEnum
    having?: email_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_logsCountAggregateInputType | true
    _min?: Email_logsMinAggregateInputType
    _max?: Email_logsMaxAggregateInputType
  }

  export type Email_logsGroupByOutputType = {
    id: string
    recipient: string
    subject: string
    message_content: string
    status: string
    error: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Email_logsCountAggregateOutputType | null
    _min: Email_logsMinAggregateOutputType | null
    _max: Email_logsMaxAggregateOutputType | null
  }

  type GetEmail_logsGroupByPayload<T extends email_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Email_logsGroupByOutputType[P]>
        }
      >
    >


  export type email_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient?: boolean
    subject?: boolean
    message_content?: boolean
    status?: boolean
    error?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["email_logs"]>

  export type email_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient?: boolean
    subject?: boolean
    message_content?: boolean
    status?: boolean
    error?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["email_logs"]>

  export type email_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient?: boolean
    subject?: boolean
    message_content?: boolean
    status?: boolean
    error?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["email_logs"]>

  export type email_logsSelectScalar = {
    id?: boolean
    recipient?: boolean
    subject?: boolean
    message_content?: boolean
    status?: boolean
    error?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type email_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipient" | "subject" | "message_content" | "status" | "error" | "created_at" | "updated_at", ExtArgs["result"]["email_logs"]>

  export type $email_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipient: string
      subject: string
      message_content: string
      status: string
      error: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["email_logs"]>
    composites: {}
  }

  type email_logsGetPayload<S extends boolean | null | undefined | email_logsDefaultArgs> = $Result.GetResult<Prisma.$email_logsPayload, S>

  type email_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<email_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Email_logsCountAggregateInputType | true
    }

  export interface email_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_logs'], meta: { name: 'email_logs' } }
    /**
     * Find zero or one Email_logs that matches the filter.
     * @param {email_logsFindUniqueArgs} args - Arguments to find a Email_logs
     * @example
     * // Get one Email_logs
     * const email_logs = await prisma.email_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_logsFindUniqueArgs>(args: SelectSubset<T, email_logsFindUniqueArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {email_logsFindUniqueOrThrowArgs} args - Arguments to find a Email_logs
     * @example
     * // Get one Email_logs
     * const email_logs = await prisma.email_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, email_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_logsFindFirstArgs} args - Arguments to find a Email_logs
     * @example
     * // Get one Email_logs
     * const email_logs = await prisma.email_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_logsFindFirstArgs>(args?: SelectSubset<T, email_logsFindFirstArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_logsFindFirstOrThrowArgs} args - Arguments to find a Email_logs
     * @example
     * // Get one Email_logs
     * const email_logs = await prisma.email_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, email_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Email_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_logs
     * const email_logs = await prisma.email_logs.findMany()
     * 
     * // Get first 10 Email_logs
     * const email_logs = await prisma.email_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_logsWithIdOnly = await prisma.email_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_logsFindManyArgs>(args?: SelectSubset<T, email_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email_logs.
     * @param {email_logsCreateArgs} args - Arguments to create a Email_logs.
     * @example
     * // Create one Email_logs
     * const Email_logs = await prisma.email_logs.create({
     *   data: {
     *     // ... data to create a Email_logs
     *   }
     * })
     * 
     */
    create<T extends email_logsCreateArgs>(args: SelectSubset<T, email_logsCreateArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Email_logs.
     * @param {email_logsCreateManyArgs} args - Arguments to create many Email_logs.
     * @example
     * // Create many Email_logs
     * const email_logs = await prisma.email_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_logsCreateManyArgs>(args?: SelectSubset<T, email_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_logs and returns the data saved in the database.
     * @param {email_logsCreateManyAndReturnArgs} args - Arguments to create many Email_logs.
     * @example
     * // Create many Email_logs
     * const email_logs = await prisma.email_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_logs and only return the `id`
     * const email_logsWithIdOnly = await prisma.email_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, email_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email_logs.
     * @param {email_logsDeleteArgs} args - Arguments to delete one Email_logs.
     * @example
     * // Delete one Email_logs
     * const Email_logs = await prisma.email_logs.delete({
     *   where: {
     *     // ... filter to delete one Email_logs
     *   }
     * })
     * 
     */
    delete<T extends email_logsDeleteArgs>(args: SelectSubset<T, email_logsDeleteArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email_logs.
     * @param {email_logsUpdateArgs} args - Arguments to update one Email_logs.
     * @example
     * // Update one Email_logs
     * const email_logs = await prisma.email_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_logsUpdateArgs>(args: SelectSubset<T, email_logsUpdateArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Email_logs.
     * @param {email_logsDeleteManyArgs} args - Arguments to filter Email_logs to delete.
     * @example
     * // Delete a few Email_logs
     * const { count } = await prisma.email_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_logsDeleteManyArgs>(args?: SelectSubset<T, email_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_logs
     * const email_logs = await prisma.email_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_logsUpdateManyArgs>(args: SelectSubset<T, email_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_logs and returns the data updated in the database.
     * @param {email_logsUpdateManyAndReturnArgs} args - Arguments to update many Email_logs.
     * @example
     * // Update many Email_logs
     * const email_logs = await prisma.email_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Email_logs and only return the `id`
     * const email_logsWithIdOnly = await prisma.email_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends email_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, email_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email_logs.
     * @param {email_logsUpsertArgs} args - Arguments to update or create a Email_logs.
     * @example
     * // Update or create a Email_logs
     * const email_logs = await prisma.email_logs.upsert({
     *   create: {
     *     // ... data to create a Email_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_logs we want to update
     *   }
     * })
     */
    upsert<T extends email_logsUpsertArgs>(args: SelectSubset<T, email_logsUpsertArgs<ExtArgs>>): Prisma__email_logsClient<$Result.GetResult<Prisma.$email_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Email_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_logsCountArgs} args - Arguments to filter Email_logs to count.
     * @example
     * // Count the number of Email_logs
     * const count = await prisma.email_logs.count({
     *   where: {
     *     // ... the filter for the Email_logs we want to count
     *   }
     * })
    **/
    count<T extends email_logsCountArgs>(
      args?: Subset<T, email_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_logsAggregateArgs>(args: Subset<T, Email_logsAggregateArgs>): Prisma.PrismaPromise<GetEmail_logsAggregateType<T>>

    /**
     * Group by Email_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_logsGroupByArgs['orderBy'] }
        : { orderBy?: email_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_logs model
   */
  readonly fields: email_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_logs model
   */
  interface email_logsFieldRefs {
    readonly id: FieldRef<"email_logs", 'String'>
    readonly recipient: FieldRef<"email_logs", 'String'>
    readonly subject: FieldRef<"email_logs", 'String'>
    readonly message_content: FieldRef<"email_logs", 'String'>
    readonly status: FieldRef<"email_logs", 'String'>
    readonly error: FieldRef<"email_logs", 'String'>
    readonly created_at: FieldRef<"email_logs", 'DateTime'>
    readonly updated_at: FieldRef<"email_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * email_logs findUnique
   */
  export type email_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * Filter, which email_logs to fetch.
     */
    where: email_logsWhereUniqueInput
  }

  /**
   * email_logs findUniqueOrThrow
   */
  export type email_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * Filter, which email_logs to fetch.
     */
    where: email_logsWhereUniqueInput
  }

  /**
   * email_logs findFirst
   */
  export type email_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * Filter, which email_logs to fetch.
     */
    where?: email_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_logs to fetch.
     */
    orderBy?: email_logsOrderByWithRelationInput | email_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_logs.
     */
    cursor?: email_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_logs.
     */
    distinct?: Email_logsScalarFieldEnum | Email_logsScalarFieldEnum[]
  }

  /**
   * email_logs findFirstOrThrow
   */
  export type email_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * Filter, which email_logs to fetch.
     */
    where?: email_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_logs to fetch.
     */
    orderBy?: email_logsOrderByWithRelationInput | email_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_logs.
     */
    cursor?: email_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_logs.
     */
    distinct?: Email_logsScalarFieldEnum | Email_logsScalarFieldEnum[]
  }

  /**
   * email_logs findMany
   */
  export type email_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * Filter, which email_logs to fetch.
     */
    where?: email_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_logs to fetch.
     */
    orderBy?: email_logsOrderByWithRelationInput | email_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_logs.
     */
    cursor?: email_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_logs.
     */
    skip?: number
    distinct?: Email_logsScalarFieldEnum | Email_logsScalarFieldEnum[]
  }

  /**
   * email_logs create
   */
  export type email_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a email_logs.
     */
    data: XOR<email_logsCreateInput, email_logsUncheckedCreateInput>
  }

  /**
   * email_logs createMany
   */
  export type email_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_logs.
     */
    data: email_logsCreateManyInput | email_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_logs createManyAndReturn
   */
  export type email_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * The data used to create many email_logs.
     */
    data: email_logsCreateManyInput | email_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_logs update
   */
  export type email_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a email_logs.
     */
    data: XOR<email_logsUpdateInput, email_logsUncheckedUpdateInput>
    /**
     * Choose, which email_logs to update.
     */
    where: email_logsWhereUniqueInput
  }

  /**
   * email_logs updateMany
   */
  export type email_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_logs.
     */
    data: XOR<email_logsUpdateManyMutationInput, email_logsUncheckedUpdateManyInput>
    /**
     * Filter which email_logs to update
     */
    where?: email_logsWhereInput
    /**
     * Limit how many email_logs to update.
     */
    limit?: number
  }

  /**
   * email_logs updateManyAndReturn
   */
  export type email_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * The data used to update email_logs.
     */
    data: XOR<email_logsUpdateManyMutationInput, email_logsUncheckedUpdateManyInput>
    /**
     * Filter which email_logs to update
     */
    where?: email_logsWhereInput
    /**
     * Limit how many email_logs to update.
     */
    limit?: number
  }

  /**
   * email_logs upsert
   */
  export type email_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the email_logs to update in case it exists.
     */
    where: email_logsWhereUniqueInput
    /**
     * In case the email_logs found by the `where` argument doesn't exist, create a new email_logs with this data.
     */
    create: XOR<email_logsCreateInput, email_logsUncheckedCreateInput>
    /**
     * In case the email_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_logsUpdateInput, email_logsUncheckedUpdateInput>
  }

  /**
   * email_logs delete
   */
  export type email_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
    /**
     * Filter which email_logs to delete.
     */
    where: email_logsWhereUniqueInput
  }

  /**
   * email_logs deleteMany
   */
  export type email_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_logs to delete
     */
    where?: email_logsWhereInput
    /**
     * Limit how many email_logs to delete.
     */
    limit?: number
  }

  /**
   * email_logs without action
   */
  export type email_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_logs
     */
    select?: email_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_logs
     */
    omit?: email_logsOmit<ExtArgs> | null
  }


  /**
   * Model locations
   */

  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    name: number
    address: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LocationsMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to aggregate.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
    orderBy?: locationsOrderByWithAggregationInput | locationsOrderByWithAggregationInput[]
    by: LocationsScalarFieldEnum[] | LocationsScalarFieldEnum
    having?: locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }

  export type LocationsGroupByOutputType = {
    id: string
    name: string
    address: string
    created_at: Date | null
    updated_at: Date | null
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["locations"]>

  export type locationsSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type locationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "created_at" | "updated_at", ExtArgs["result"]["locations"]>

  export type $locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "locations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["locations"]>
    composites: {}
  }

  type locationsGetPayload<S extends boolean | null | undefined | locationsDefaultArgs> = $Result.GetResult<Prisma.$locationsPayload, S>

  type locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locations'], meta: { name: 'locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {locationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationsFindUniqueArgs>(args: SelectSubset<T, locationsFindUniqueArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationsFindFirstArgs>(args?: SelectSubset<T, locationsFindFirstArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends locationsFindManyArgs>(args?: SelectSubset<T, locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Locations.
     * @param {locationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
     */
    create<T extends locationsCreateArgs>(args: SelectSubset<T, locationsCreateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {locationsCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationsCreateManyArgs>(args?: SelectSubset<T, locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {locationsCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends locationsCreateManyAndReturnArgs>(args?: SelectSubset<T, locationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Locations.
     * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
     */
    delete<T extends locationsDeleteArgs>(args: SelectSubset<T, locationsDeleteArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Locations.
     * @param {locationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationsUpdateArgs>(args: SelectSubset<T, locationsUpdateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationsDeleteManyArgs>(args?: SelectSubset<T, locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationsUpdateManyArgs>(args: SelectSubset<T, locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {locationsUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationsWithIdOnly = await prisma.locations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends locationsUpdateManyAndReturnArgs>(args: SelectSubset<T, locationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Locations.
     * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
     */
    upsert<T extends locationsUpsertArgs>(args: SelectSubset<T, locationsUpsertArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationsCountArgs>(
      args?: Subset<T, locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationsGroupByArgs['orderBy'] }
        : { orderBy?: locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the locations model
   */
  readonly fields: locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the locations model
   */
  interface locationsFieldRefs {
    readonly id: FieldRef<"locations", 'String'>
    readonly name: FieldRef<"locations", 'String'>
    readonly address: FieldRef<"locations", 'String'>
    readonly created_at: FieldRef<"locations", 'DateTime'>
    readonly updated_at: FieldRef<"locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * locations findUnique
   */
  export type locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findUniqueOrThrow
   */
  export type locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findFirst
   */
  export type locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findFirstOrThrow
   */
  export type locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findMany
   */
  export type locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations create
   */
  export type locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data needed to create a locations.
     */
    data: XOR<locationsCreateInput, locationsUncheckedCreateInput>
  }

  /**
   * locations createMany
   */
  export type locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationsCreateManyInput | locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * locations createManyAndReturn
   */
  export type locationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data used to create many locations.
     */
    data: locationsCreateManyInput | locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * locations update
   */
  export type locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data needed to update a locations.
     */
    data: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
    /**
     * Choose, which locations to update.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations updateMany
   */
  export type locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * locations updateManyAndReturn
   */
  export type locationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * locations upsert
   */
  export type locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The filter to search for the locations to update in case it exists.
     */
    where: locationsWhereUniqueInput
    /**
     * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
     */
    create: XOR<locationsCreateInput, locationsUncheckedCreateInput>
    /**
     * In case the locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
  }

  /**
   * locations delete
   */
  export type locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter which locations to delete.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations deleteMany
   */
  export type locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to delete.
     */
    limit?: number
  }

  /**
   * locations without action
   */
  export type locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    booking_id: number | null
    user_id: number | null
    amount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    booking_id: number | null
    user_id: number | null
    amount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    booking_id: number | null
    user_id: number | null
    amount: Decimal | null
    payment_method: string | null
    transaction_id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    booking_id: number | null
    user_id: number | null
    amount: Decimal | null
    payment_method: string | null
    transaction_id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    booking_id: number
    user_id: number
    amount: number
    payment_method: number
    transaction_id: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    booking_id?: true
    user_id?: true
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    booking_id?: true
    user_id?: true
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    booking_id?: true
    user_id?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    booking_id?: true
    user_id?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    booking_id?: true
    user_id?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    booking_id: number | null
    user_id: number | null
    amount: Decimal
    payment_method: string | null
    transaction_id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    user_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    user_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    user_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    booking_id?: boolean
    user_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "booking_id" | "user_id" | "amount" | "payment_method" | "transaction_id" | "status" | "created_at" | "updated_at", ExtArgs["result"]["payments"]>

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      booking_id: number | null
      user_id: number | null
      amount: Prisma.Decimal
      payment_method: string | null
      transaction_id: string | null
      status: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'Int'>
    readonly booking_id: FieldRef<"payments", 'Int'>
    readonly user_id: FieldRef<"payments", 'Int'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly payment_method: FieldRef<"payments", 'String'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly status: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly updated_at: FieldRef<"payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
  }


  /**
   * Model profiles
   */

  export type AggregateProfiles = {
    _count: ProfilesCountAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  export type ProfilesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    phone: string | null
    avatar_url: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zip_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfilesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    phone: string | null
    avatar_url: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zip_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfilesCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    phone: number
    avatar_url: number
    address: number
    city: number
    state: number
    country: number
    zip_code: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProfilesMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    phone?: true
    avatar_url?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zip_code?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfilesMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    phone?: true
    avatar_url?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zip_code?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfilesCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    phone?: true
    avatar_url?: true
    address?: true
    city?: true
    state?: true
    country?: true
    zip_code?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProfilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to aggregate.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfilesMaxAggregateInputType
  }

  export type GetProfilesAggregateType<T extends ProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfiles[P]>
      : GetScalarType<T[P], AggregateProfiles[P]>
  }




  export type profilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profilesWhereInput
    orderBy?: profilesOrderByWithAggregationInput | profilesOrderByWithAggregationInput[]
    by: ProfilesScalarFieldEnum[] | ProfilesScalarFieldEnum
    having?: profilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfilesCountAggregateInputType | true
    _min?: ProfilesMinAggregateInputType
    _max?: ProfilesMaxAggregateInputType
  }

  export type ProfilesGroupByOutputType = {
    id: string
    user_id: string | null
    name: string | null
    phone: string | null
    avatar_url: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    zip_code: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: ProfilesCountAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  type GetProfilesGroupByPayload<T extends profilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
        }
      >
    >


  export type profilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    phone?: boolean
    avatar_url?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zip_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["profiles"]>

  export type profilesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    phone?: boolean
    avatar_url?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zip_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["profiles"]>

  export type profilesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    phone?: boolean
    avatar_url?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zip_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["profiles"]>

  export type profilesSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    phone?: boolean
    avatar_url?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zip_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type profilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "phone" | "avatar_url" | "address" | "city" | "state" | "country" | "zip_code" | "created_at" | "updated_at", ExtArgs["result"]["profiles"]>

  export type $profilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profiles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      name: string | null
      phone: string | null
      avatar_url: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      zip_code: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["profiles"]>
    composites: {}
  }

  type profilesGetPayload<S extends boolean | null | undefined | profilesDefaultArgs> = $Result.GetResult<Prisma.$profilesPayload, S>

  type profilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<profilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfilesCountAggregateInputType | true
    }

  export interface profilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profiles'], meta: { name: 'profiles' } }
    /**
     * Find zero or one Profiles that matches the filter.
     * @param {profilesFindUniqueArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profilesFindUniqueArgs>(args: SelectSubset<T, profilesFindUniqueArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profiles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {profilesFindUniqueOrThrowArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profilesFindUniqueOrThrowArgs>(args: SelectSubset<T, profilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesFindFirstArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profilesFindFirstArgs>(args?: SelectSubset<T, profilesFindFirstArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profiles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesFindFirstOrThrowArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profilesFindFirstOrThrowArgs>(args?: SelectSubset<T, profilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profiles.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profilesWithIdOnly = await prisma.profiles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profilesFindManyArgs>(args?: SelectSubset<T, profilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profiles.
     * @param {profilesCreateArgs} args - Arguments to create a Profiles.
     * @example
     * // Create one Profiles
     * const Profiles = await prisma.profiles.create({
     *   data: {
     *     // ... data to create a Profiles
     *   }
     * })
     * 
     */
    create<T extends profilesCreateArgs>(args: SelectSubset<T, profilesCreateArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {profilesCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profiles = await prisma.profiles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profilesCreateManyArgs>(args?: SelectSubset<T, profilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {profilesCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profiles = await prisma.profiles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profilesWithIdOnly = await prisma.profiles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends profilesCreateManyAndReturnArgs>(args?: SelectSubset<T, profilesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profiles.
     * @param {profilesDeleteArgs} args - Arguments to delete one Profiles.
     * @example
     * // Delete one Profiles
     * const Profiles = await prisma.profiles.delete({
     *   where: {
     *     // ... filter to delete one Profiles
     *   }
     * })
     * 
     */
    delete<T extends profilesDeleteArgs>(args: SelectSubset<T, profilesDeleteArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profiles.
     * @param {profilesUpdateArgs} args - Arguments to update one Profiles.
     * @example
     * // Update one Profiles
     * const profiles = await prisma.profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profilesUpdateArgs>(args: SelectSubset<T, profilesUpdateArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {profilesDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profilesDeleteManyArgs>(args?: SelectSubset<T, profilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profiles = await prisma.profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profilesUpdateManyArgs>(args: SelectSubset<T, profilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {profilesUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profiles = await prisma.profiles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profilesWithIdOnly = await prisma.profiles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends profilesUpdateManyAndReturnArgs>(args: SelectSubset<T, profilesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profiles.
     * @param {profilesUpsertArgs} args - Arguments to update or create a Profiles.
     * @example
     * // Update or create a Profiles
     * const profiles = await prisma.profiles.upsert({
     *   create: {
     *     // ... data to create a Profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profiles we want to update
     *   }
     * })
     */
    upsert<T extends profilesUpsertArgs>(args: SelectSubset<T, profilesUpsertArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profiles.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profilesCountArgs>(
      args?: Subset<T, profilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfilesAggregateArgs>(args: Subset<T, ProfilesAggregateArgs>): Prisma.PrismaPromise<GetProfilesAggregateType<T>>

    /**
     * Group by Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profilesGroupByArgs['orderBy'] }
        : { orderBy?: profilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profiles model
   */
  readonly fields: profilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profiles model
   */
  interface profilesFieldRefs {
    readonly id: FieldRef<"profiles", 'String'>
    readonly user_id: FieldRef<"profiles", 'String'>
    readonly name: FieldRef<"profiles", 'String'>
    readonly phone: FieldRef<"profiles", 'String'>
    readonly avatar_url: FieldRef<"profiles", 'String'>
    readonly address: FieldRef<"profiles", 'String'>
    readonly city: FieldRef<"profiles", 'String'>
    readonly state: FieldRef<"profiles", 'String'>
    readonly country: FieldRef<"profiles", 'String'>
    readonly zip_code: FieldRef<"profiles", 'String'>
    readonly created_at: FieldRef<"profiles", 'DateTime'>
    readonly updated_at: FieldRef<"profiles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * profiles findUnique
   */
  export type profilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles findUniqueOrThrow
   */
  export type profilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles findFirst
   */
  export type profilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * profiles findFirstOrThrow
   */
  export type profilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * profiles findMany
   */
  export type profilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * profiles create
   */
  export type profilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * The data needed to create a profiles.
     */
    data: XOR<profilesCreateInput, profilesUncheckedCreateInput>
  }

  /**
   * profiles createMany
   */
  export type profilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profilesCreateManyInput | profilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profiles createManyAndReturn
   */
  export type profilesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * The data used to create many profiles.
     */
    data: profilesCreateManyInput | profilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profiles update
   */
  export type profilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * The data needed to update a profiles.
     */
    data: XOR<profilesUpdateInput, profilesUncheckedUpdateInput>
    /**
     * Choose, which profiles to update.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles updateMany
   */
  export type profilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profilesUpdateManyMutationInput, profilesUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profilesWhereInput
    /**
     * Limit how many profiles to update.
     */
    limit?: number
  }

  /**
   * profiles updateManyAndReturn
   */
  export type profilesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * The data used to update profiles.
     */
    data: XOR<profilesUpdateManyMutationInput, profilesUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profilesWhereInput
    /**
     * Limit how many profiles to update.
     */
    limit?: number
  }

  /**
   * profiles upsert
   */
  export type profilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * The filter to search for the profiles to update in case it exists.
     */
    where: profilesWhereUniqueInput
    /**
     * In case the profiles found by the `where` argument doesn't exist, create a new profiles with this data.
     */
    create: XOR<profilesCreateInput, profilesUncheckedCreateInput>
    /**
     * In case the profiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profilesUpdateInput, profilesUncheckedUpdateInput>
  }

  /**
   * profiles delete
   */
  export type profilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Filter which profiles to delete.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles deleteMany
   */
  export type profilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profilesWhereInput
    /**
     * Limit how many profiles to delete.
     */
    limit?: number
  }

  /**
   * profiles without action
   */
  export type profilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
  }


  /**
   * Model reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    vehicle_id: number | null
    booking_id: number | null
    rating: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    vehicle_id: number | null
    booking_id: number | null
    rating: number | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    vehicle_id: number | null
    booking_id: number | null
    rating: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    vehicle_id: number | null
    booking_id: number | null
    rating: number | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    user_id: number
    vehicle_id: number
    booking_id: number
    rating: number
    comment: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    booking_id?: true
    rating?: true
  }

  export type ReviewsSumAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    booking_id?: true
    rating?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    booking_id?: true
    rating?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    booking_id?: true
    rating?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    user_id?: true
    vehicle_id?: true
    booking_id?: true
    rating?: true
    comment?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to aggregate.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithAggregationInput | reviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: reviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: number
    user_id: number | null
    vehicle_id: number | null
    booking_id: number | null
    rating: number
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends reviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectScalar = {
    id?: boolean
    user_id?: boolean
    vehicle_id?: boolean
    booking_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type reviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "vehicle_id" | "booking_id" | "rating" | "comment" | "created_at" | "updated_at", ExtArgs["result"]["reviews"]>

  export type $reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviews"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      vehicle_id: number | null
      booking_id: number | null
      rating: number
      comment: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type reviewsGetPayload<S extends boolean | null | undefined | reviewsDefaultArgs> = $Result.GetResult<Prisma.$reviewsPayload, S>

  type reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviews'], meta: { name: 'reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {reviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewsFindUniqueArgs>(args: SelectSubset<T, reviewsFindUniqueArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewsFindFirstArgs>(args?: SelectSubset<T, reviewsFindFirstArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviewsFindManyArgs>(args?: SelectSubset<T, reviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews.
     * @param {reviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
     */
    create<T extends reviewsCreateArgs>(args: SelectSubset<T, reviewsCreateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {reviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewsCreateManyArgs>(args?: SelectSubset<T, reviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {reviewsCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviews.
     * @param {reviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
     */
    delete<T extends reviewsDeleteArgs>(args: SelectSubset<T, reviewsDeleteArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews.
     * @param {reviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewsUpdateArgs>(args: SelectSubset<T, reviewsUpdateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {reviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewsDeleteManyArgs>(args?: SelectSubset<T, reviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewsUpdateManyArgs>(args: SelectSubset<T, reviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {reviewsUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviews.
     * @param {reviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
     */
    upsert<T extends reviewsUpsertArgs>(args: SelectSubset<T, reviewsUpsertArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewsCountArgs>(
      args?: Subset<T, reviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsGroupByArgs['orderBy'] }
        : { orderBy?: reviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviews model
   */
  readonly fields: reviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviews model
   */
  interface reviewsFieldRefs {
    readonly id: FieldRef<"reviews", 'Int'>
    readonly user_id: FieldRef<"reviews", 'Int'>
    readonly vehicle_id: FieldRef<"reviews", 'Int'>
    readonly booking_id: FieldRef<"reviews", 'Int'>
    readonly rating: FieldRef<"reviews", 'Int'>
    readonly comment: FieldRef<"reviews", 'String'>
    readonly created_at: FieldRef<"reviews", 'DateTime'>
    readonly updated_at: FieldRef<"reviews", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reviews findUnique
   */
  export type reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findUniqueOrThrow
   */
  export type reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findFirst
   */
  export type reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findFirstOrThrow
   */
  export type reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findMany
   */
  export type reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews create
   */
  export type reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data needed to create a reviews.
     */
    data: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
  }

  /**
   * reviews createMany
   */
  export type reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviews createManyAndReturn
   */
  export type reviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviews update
   */
  export type reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data needed to update a reviews.
     */
    data: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
    /**
     * Choose, which reviews to update.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews updateMany
   */
  export type reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * reviews updateManyAndReturn
   */
  export type reviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * reviews upsert
   */
  export type reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The filter to search for the reviews to update in case it exists.
     */
    where: reviewsWhereUniqueInput
    /**
     * In case the reviews found by the `where` argument doesn't exist, create a new reviews with this data.
     */
    create: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
    /**
     * In case the reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
  }

  /**
   * reviews delete
   */
  export type reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Filter which reviews to delete.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews deleteMany
   */
  export type reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to delete.
     */
    limit?: number
  }

  /**
   * reviews without action
   */
  export type reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
  }


  /**
   * Model settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithAggregationInput | settingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    key: string
    value: string
    created_at: Date
    updated_at: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "created_at" | "updated_at", ExtArgs["result"]["settings"]>

  export type $settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type settingsGetPayload<S extends boolean | null | undefined | settingsDefaultArgs> = $Result.GetResult<Prisma.$settingsPayload, S>

  type settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settings'], meta: { name: 'settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingsFindUniqueArgs>(args: SelectSubset<T, settingsFindUniqueArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingsFindFirstArgs>(args?: SelectSubset<T, settingsFindFirstArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends settingsFindManyArgs>(args?: SelectSubset<T, settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends settingsCreateArgs>(args: SelectSubset<T, settingsCreateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingsCreateManyArgs>(args?: SelectSubset<T, settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {settingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends settingsCreateManyAndReturnArgs>(args?: SelectSubset<T, settingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends settingsDeleteArgs>(args: SelectSubset<T, settingsDeleteArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingsUpdateArgs>(args: SelectSubset<T, settingsUpdateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingsDeleteManyArgs>(args?: SelectSubset<T, settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingsUpdateManyArgs>(args: SelectSubset<T, settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {settingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends settingsUpdateManyAndReturnArgs>(args: SelectSubset<T, settingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends settingsUpsertArgs>(args: SelectSubset<T, settingsUpsertArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingsGroupByArgs['orderBy'] }
        : { orderBy?: settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settings model
   */
  readonly fields: settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settings model
   */
  interface settingsFieldRefs {
    readonly id: FieldRef<"settings", 'String'>
    readonly key: FieldRef<"settings", 'String'>
    readonly value: FieldRef<"settings", 'String'>
    readonly created_at: FieldRef<"settings", 'DateTime'>
    readonly updated_at: FieldRef<"settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * settings findUnique
   */
  export type settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findFirst
   */
  export type settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findMany
   */
  export type settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings create
   */
  export type settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data needed to create a settings.
     */
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }

  /**
   * settings createMany
   */
  export type settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settings createManyAndReturn
   */
  export type settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settings update
   */
  export type settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * settings updateManyAndReturn
   */
  export type settingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * settings upsert
   */
  export type settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }

  /**
   * settings delete
   */
  export type settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to delete.
     */
    limit?: number
  }

  /**
   * settings without action
   */
  export type settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
  }


  /**
   * Model sms_logs
   */

  export type AggregateSms_logs = {
    _count: Sms_logsCountAggregateOutputType | null
    _min: Sms_logsMinAggregateOutputType | null
    _max: Sms_logsMaxAggregateOutputType | null
  }

  export type Sms_logsMinAggregateOutputType = {
    id: string | null
    phone_number: string | null
    message: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Sms_logsMaxAggregateOutputType = {
    id: string | null
    phone_number: string | null
    message: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Sms_logsCountAggregateOutputType = {
    id: number
    phone_number: number
    message: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Sms_logsMinAggregateInputType = {
    id?: true
    phone_number?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Sms_logsMaxAggregateInputType = {
    id?: true
    phone_number?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Sms_logsCountAggregateInputType = {
    id?: true
    phone_number?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Sms_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sms_logs to aggregate.
     */
    where?: sms_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sms_logs to fetch.
     */
    orderBy?: sms_logsOrderByWithRelationInput | sms_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sms_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sms_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sms_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sms_logs
    **/
    _count?: true | Sms_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sms_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sms_logsMaxAggregateInputType
  }

  export type GetSms_logsAggregateType<T extends Sms_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateSms_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSms_logs[P]>
      : GetScalarType<T[P], AggregateSms_logs[P]>
  }




  export type sms_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sms_logsWhereInput
    orderBy?: sms_logsOrderByWithAggregationInput | sms_logsOrderByWithAggregationInput[]
    by: Sms_logsScalarFieldEnum[] | Sms_logsScalarFieldEnum
    having?: sms_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sms_logsCountAggregateInputType | true
    _min?: Sms_logsMinAggregateInputType
    _max?: Sms_logsMaxAggregateInputType
  }

  export type Sms_logsGroupByOutputType = {
    id: string
    phone_number: string
    message: string
    status: string
    created_at: Date
    updated_at: Date
    _count: Sms_logsCountAggregateOutputType | null
    _min: Sms_logsMinAggregateOutputType | null
    _max: Sms_logsMaxAggregateOutputType | null
  }

  type GetSms_logsGroupByPayload<T extends sms_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sms_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sms_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sms_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Sms_logsGroupByOutputType[P]>
        }
      >
    >


  export type sms_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["sms_logs"]>

  export type sms_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["sms_logs"]>

  export type sms_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone_number?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["sms_logs"]>

  export type sms_logsSelectScalar = {
    id?: boolean
    phone_number?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type sms_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone_number" | "message" | "status" | "created_at" | "updated_at", ExtArgs["result"]["sms_logs"]>

  export type $sms_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sms_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone_number: string
      message: string
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["sms_logs"]>
    composites: {}
  }

  type sms_logsGetPayload<S extends boolean | null | undefined | sms_logsDefaultArgs> = $Result.GetResult<Prisma.$sms_logsPayload, S>

  type sms_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sms_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sms_logsCountAggregateInputType | true
    }

  export interface sms_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sms_logs'], meta: { name: 'sms_logs' } }
    /**
     * Find zero or one Sms_logs that matches the filter.
     * @param {sms_logsFindUniqueArgs} args - Arguments to find a Sms_logs
     * @example
     * // Get one Sms_logs
     * const sms_logs = await prisma.sms_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sms_logsFindUniqueArgs>(args: SelectSubset<T, sms_logsFindUniqueArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sms_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sms_logsFindUniqueOrThrowArgs} args - Arguments to find a Sms_logs
     * @example
     * // Get one Sms_logs
     * const sms_logs = await prisma.sms_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sms_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, sms_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sms_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sms_logsFindFirstArgs} args - Arguments to find a Sms_logs
     * @example
     * // Get one Sms_logs
     * const sms_logs = await prisma.sms_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sms_logsFindFirstArgs>(args?: SelectSubset<T, sms_logsFindFirstArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sms_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sms_logsFindFirstOrThrowArgs} args - Arguments to find a Sms_logs
     * @example
     * // Get one Sms_logs
     * const sms_logs = await prisma.sms_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sms_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, sms_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sms_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sms_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sms_logs
     * const sms_logs = await prisma.sms_logs.findMany()
     * 
     * // Get first 10 Sms_logs
     * const sms_logs = await prisma.sms_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sms_logsWithIdOnly = await prisma.sms_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sms_logsFindManyArgs>(args?: SelectSubset<T, sms_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sms_logs.
     * @param {sms_logsCreateArgs} args - Arguments to create a Sms_logs.
     * @example
     * // Create one Sms_logs
     * const Sms_logs = await prisma.sms_logs.create({
     *   data: {
     *     // ... data to create a Sms_logs
     *   }
     * })
     * 
     */
    create<T extends sms_logsCreateArgs>(args: SelectSubset<T, sms_logsCreateArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sms_logs.
     * @param {sms_logsCreateManyArgs} args - Arguments to create many Sms_logs.
     * @example
     * // Create many Sms_logs
     * const sms_logs = await prisma.sms_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sms_logsCreateManyArgs>(args?: SelectSubset<T, sms_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sms_logs and returns the data saved in the database.
     * @param {sms_logsCreateManyAndReturnArgs} args - Arguments to create many Sms_logs.
     * @example
     * // Create many Sms_logs
     * const sms_logs = await prisma.sms_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sms_logs and only return the `id`
     * const sms_logsWithIdOnly = await prisma.sms_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sms_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, sms_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sms_logs.
     * @param {sms_logsDeleteArgs} args - Arguments to delete one Sms_logs.
     * @example
     * // Delete one Sms_logs
     * const Sms_logs = await prisma.sms_logs.delete({
     *   where: {
     *     // ... filter to delete one Sms_logs
     *   }
     * })
     * 
     */
    delete<T extends sms_logsDeleteArgs>(args: SelectSubset<T, sms_logsDeleteArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sms_logs.
     * @param {sms_logsUpdateArgs} args - Arguments to update one Sms_logs.
     * @example
     * // Update one Sms_logs
     * const sms_logs = await prisma.sms_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sms_logsUpdateArgs>(args: SelectSubset<T, sms_logsUpdateArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sms_logs.
     * @param {sms_logsDeleteManyArgs} args - Arguments to filter Sms_logs to delete.
     * @example
     * // Delete a few Sms_logs
     * const { count } = await prisma.sms_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sms_logsDeleteManyArgs>(args?: SelectSubset<T, sms_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sms_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sms_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sms_logs
     * const sms_logs = await prisma.sms_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sms_logsUpdateManyArgs>(args: SelectSubset<T, sms_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sms_logs and returns the data updated in the database.
     * @param {sms_logsUpdateManyAndReturnArgs} args - Arguments to update many Sms_logs.
     * @example
     * // Update many Sms_logs
     * const sms_logs = await prisma.sms_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sms_logs and only return the `id`
     * const sms_logsWithIdOnly = await prisma.sms_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sms_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, sms_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sms_logs.
     * @param {sms_logsUpsertArgs} args - Arguments to update or create a Sms_logs.
     * @example
     * // Update or create a Sms_logs
     * const sms_logs = await prisma.sms_logs.upsert({
     *   create: {
     *     // ... data to create a Sms_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sms_logs we want to update
     *   }
     * })
     */
    upsert<T extends sms_logsUpsertArgs>(args: SelectSubset<T, sms_logsUpsertArgs<ExtArgs>>): Prisma__sms_logsClient<$Result.GetResult<Prisma.$sms_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sms_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sms_logsCountArgs} args - Arguments to filter Sms_logs to count.
     * @example
     * // Count the number of Sms_logs
     * const count = await prisma.sms_logs.count({
     *   where: {
     *     // ... the filter for the Sms_logs we want to count
     *   }
     * })
    **/
    count<T extends sms_logsCountArgs>(
      args?: Subset<T, sms_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sms_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sms_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sms_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sms_logsAggregateArgs>(args: Subset<T, Sms_logsAggregateArgs>): Prisma.PrismaPromise<GetSms_logsAggregateType<T>>

    /**
     * Group by Sms_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sms_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sms_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sms_logsGroupByArgs['orderBy'] }
        : { orderBy?: sms_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sms_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSms_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sms_logs model
   */
  readonly fields: sms_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sms_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sms_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sms_logs model
   */
  interface sms_logsFieldRefs {
    readonly id: FieldRef<"sms_logs", 'String'>
    readonly phone_number: FieldRef<"sms_logs", 'String'>
    readonly message: FieldRef<"sms_logs", 'String'>
    readonly status: FieldRef<"sms_logs", 'String'>
    readonly created_at: FieldRef<"sms_logs", 'DateTime'>
    readonly updated_at: FieldRef<"sms_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sms_logs findUnique
   */
  export type sms_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * Filter, which sms_logs to fetch.
     */
    where: sms_logsWhereUniqueInput
  }

  /**
   * sms_logs findUniqueOrThrow
   */
  export type sms_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * Filter, which sms_logs to fetch.
     */
    where: sms_logsWhereUniqueInput
  }

  /**
   * sms_logs findFirst
   */
  export type sms_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * Filter, which sms_logs to fetch.
     */
    where?: sms_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sms_logs to fetch.
     */
    orderBy?: sms_logsOrderByWithRelationInput | sms_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sms_logs.
     */
    cursor?: sms_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sms_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sms_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sms_logs.
     */
    distinct?: Sms_logsScalarFieldEnum | Sms_logsScalarFieldEnum[]
  }

  /**
   * sms_logs findFirstOrThrow
   */
  export type sms_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * Filter, which sms_logs to fetch.
     */
    where?: sms_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sms_logs to fetch.
     */
    orderBy?: sms_logsOrderByWithRelationInput | sms_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sms_logs.
     */
    cursor?: sms_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sms_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sms_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sms_logs.
     */
    distinct?: Sms_logsScalarFieldEnum | Sms_logsScalarFieldEnum[]
  }

  /**
   * sms_logs findMany
   */
  export type sms_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * Filter, which sms_logs to fetch.
     */
    where?: sms_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sms_logs to fetch.
     */
    orderBy?: sms_logsOrderByWithRelationInput | sms_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sms_logs.
     */
    cursor?: sms_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sms_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sms_logs.
     */
    skip?: number
    distinct?: Sms_logsScalarFieldEnum | Sms_logsScalarFieldEnum[]
  }

  /**
   * sms_logs create
   */
  export type sms_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a sms_logs.
     */
    data: XOR<sms_logsCreateInput, sms_logsUncheckedCreateInput>
  }

  /**
   * sms_logs createMany
   */
  export type sms_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sms_logs.
     */
    data: sms_logsCreateManyInput | sms_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sms_logs createManyAndReturn
   */
  export type sms_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * The data used to create many sms_logs.
     */
    data: sms_logsCreateManyInput | sms_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sms_logs update
   */
  export type sms_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a sms_logs.
     */
    data: XOR<sms_logsUpdateInput, sms_logsUncheckedUpdateInput>
    /**
     * Choose, which sms_logs to update.
     */
    where: sms_logsWhereUniqueInput
  }

  /**
   * sms_logs updateMany
   */
  export type sms_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sms_logs.
     */
    data: XOR<sms_logsUpdateManyMutationInput, sms_logsUncheckedUpdateManyInput>
    /**
     * Filter which sms_logs to update
     */
    where?: sms_logsWhereInput
    /**
     * Limit how many sms_logs to update.
     */
    limit?: number
  }

  /**
   * sms_logs updateManyAndReturn
   */
  export type sms_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * The data used to update sms_logs.
     */
    data: XOR<sms_logsUpdateManyMutationInput, sms_logsUncheckedUpdateManyInput>
    /**
     * Filter which sms_logs to update
     */
    where?: sms_logsWhereInput
    /**
     * Limit how many sms_logs to update.
     */
    limit?: number
  }

  /**
   * sms_logs upsert
   */
  export type sms_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the sms_logs to update in case it exists.
     */
    where: sms_logsWhereUniqueInput
    /**
     * In case the sms_logs found by the `where` argument doesn't exist, create a new sms_logs with this data.
     */
    create: XOR<sms_logsCreateInput, sms_logsUncheckedCreateInput>
    /**
     * In case the sms_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sms_logsUpdateInput, sms_logsUncheckedUpdateInput>
  }

  /**
   * sms_logs delete
   */
  export type sms_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
    /**
     * Filter which sms_logs to delete.
     */
    where: sms_logsWhereUniqueInput
  }

  /**
   * sms_logs deleteMany
   */
  export type sms_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sms_logs to delete
     */
    where?: sms_logsWhereInput
    /**
     * Limit how many sms_logs to delete.
     */
    limit?: number
  }

  /**
   * sms_logs without action
   */
  export type sms_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sms_logs
     */
    select?: sms_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sms_logs
     */
    omit?: sms_logsOmit<ExtArgs> | null
  }


  /**
   * Model trip_initiations
   */

  export type AggregateTrip_initiations = {
    _count: Trip_initiationsCountAggregateOutputType | null
    _min: Trip_initiationsMinAggregateOutputType | null
    _max: Trip_initiationsMaxAggregateOutputType | null
  }

  export type Trip_initiationsMinAggregateOutputType = {
    id: string | null
    booking_id: string | null
    checklist_completed: boolean | null
    customer_name: string | null
    customer_phone: string | null
    customer_email: string | null
    customer_dl_number: string | null
    customer_address: string | null
    emergency_contact: string | null
    emergency_name: string | null
    customer_aadhaar_number: string | null
    customer_dob: string | null
    vehicle_number: string | null
    terms_accepted: boolean | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Trip_initiationsMaxAggregateOutputType = {
    id: string | null
    booking_id: string | null
    checklist_completed: boolean | null
    customer_name: string | null
    customer_phone: string | null
    customer_email: string | null
    customer_dl_number: string | null
    customer_address: string | null
    emergency_contact: string | null
    emergency_name: string | null
    customer_aadhaar_number: string | null
    customer_dob: string | null
    vehicle_number: string | null
    terms_accepted: boolean | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Trip_initiationsCountAggregateOutputType = {
    id: number
    booking_id: number
    checklist_completed: number
    customer_name: number
    customer_phone: number
    customer_email: number
    customer_dl_number: number
    customer_address: number
    emergency_contact: number
    emergency_name: number
    customer_aadhaar_number: number
    customer_dob: number
    vehicle_number: number
    documents: number
    terms_accepted: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Trip_initiationsMinAggregateInputType = {
    id?: true
    booking_id?: true
    checklist_completed?: true
    customer_name?: true
    customer_phone?: true
    customer_email?: true
    customer_dl_number?: true
    customer_address?: true
    emergency_contact?: true
    emergency_name?: true
    customer_aadhaar_number?: true
    customer_dob?: true
    vehicle_number?: true
    terms_accepted?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Trip_initiationsMaxAggregateInputType = {
    id?: true
    booking_id?: true
    checklist_completed?: true
    customer_name?: true
    customer_phone?: true
    customer_email?: true
    customer_dl_number?: true
    customer_address?: true
    emergency_contact?: true
    emergency_name?: true
    customer_aadhaar_number?: true
    customer_dob?: true
    vehicle_number?: true
    terms_accepted?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Trip_initiationsCountAggregateInputType = {
    id?: true
    booking_id?: true
    checklist_completed?: true
    customer_name?: true
    customer_phone?: true
    customer_email?: true
    customer_dl_number?: true
    customer_address?: true
    emergency_contact?: true
    emergency_name?: true
    customer_aadhaar_number?: true
    customer_dob?: true
    vehicle_number?: true
    documents?: true
    terms_accepted?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Trip_initiationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trip_initiations to aggregate.
     */
    where?: trip_initiationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trip_initiations to fetch.
     */
    orderBy?: trip_initiationsOrderByWithRelationInput | trip_initiationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trip_initiationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trip_initiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trip_initiations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trip_initiations
    **/
    _count?: true | Trip_initiationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Trip_initiationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Trip_initiationsMaxAggregateInputType
  }

  export type GetTrip_initiationsAggregateType<T extends Trip_initiationsAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip_initiations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip_initiations[P]>
      : GetScalarType<T[P], AggregateTrip_initiations[P]>
  }




  export type trip_initiationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trip_initiationsWhereInput
    orderBy?: trip_initiationsOrderByWithAggregationInput | trip_initiationsOrderByWithAggregationInput[]
    by: Trip_initiationsScalarFieldEnum[] | Trip_initiationsScalarFieldEnum
    having?: trip_initiationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Trip_initiationsCountAggregateInputType | true
    _min?: Trip_initiationsMinAggregateInputType
    _max?: Trip_initiationsMaxAggregateInputType
  }

  export type Trip_initiationsGroupByOutputType = {
    id: string
    booking_id: string
    checklist_completed: boolean
    customer_name: string
    customer_phone: string
    customer_email: string | null
    customer_dl_number: string | null
    customer_address: string | null
    emergency_contact: string | null
    emergency_name: string | null
    customer_aadhaar_number: string | null
    customer_dob: string | null
    vehicle_number: string | null
    documents: JsonValue | null
    terms_accepted: boolean
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: Trip_initiationsCountAggregateOutputType | null
    _min: Trip_initiationsMinAggregateOutputType | null
    _max: Trip_initiationsMaxAggregateOutputType | null
  }

  type GetTrip_initiationsGroupByPayload<T extends trip_initiationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Trip_initiationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Trip_initiationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Trip_initiationsGroupByOutputType[P]>
            : GetScalarType<T[P], Trip_initiationsGroupByOutputType[P]>
        }
      >
    >


  export type trip_initiationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    checklist_completed?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_email?: boolean
    customer_dl_number?: boolean
    customer_address?: boolean
    emergency_contact?: boolean
    emergency_name?: boolean
    customer_aadhaar_number?: boolean
    customer_dob?: boolean
    vehicle_number?: boolean
    documents?: boolean
    terms_accepted?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip_initiations"]>

  export type trip_initiationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    checklist_completed?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_email?: boolean
    customer_dl_number?: boolean
    customer_address?: boolean
    emergency_contact?: boolean
    emergency_name?: boolean
    customer_aadhaar_number?: boolean
    customer_dob?: boolean
    vehicle_number?: boolean
    documents?: boolean
    terms_accepted?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip_initiations"]>

  export type trip_initiationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    checklist_completed?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_email?: boolean
    customer_dl_number?: boolean
    customer_address?: boolean
    emergency_contact?: boolean
    emergency_name?: boolean
    customer_aadhaar_number?: boolean
    customer_dob?: boolean
    vehicle_number?: boolean
    documents?: boolean
    terms_accepted?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip_initiations"]>

  export type trip_initiationsSelectScalar = {
    id?: boolean
    booking_id?: boolean
    checklist_completed?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_email?: boolean
    customer_dl_number?: boolean
    customer_address?: boolean
    emergency_contact?: boolean
    emergency_name?: boolean
    customer_aadhaar_number?: boolean
    customer_dob?: boolean
    vehicle_number?: boolean
    documents?: boolean
    terms_accepted?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type trip_initiationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "booking_id" | "checklist_completed" | "customer_name" | "customer_phone" | "customer_email" | "customer_dl_number" | "customer_address" | "emergency_contact" | "emergency_name" | "customer_aadhaar_number" | "customer_dob" | "vehicle_number" | "documents" | "terms_accepted" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["trip_initiations"]>
  export type trip_initiationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }
  export type trip_initiationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }
  export type trip_initiationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }

  export type $trip_initiationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trip_initiations"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      booking_id: string
      checklist_completed: boolean
      customer_name: string
      customer_phone: string
      customer_email: string | null
      customer_dl_number: string | null
      customer_address: string | null
      emergency_contact: string | null
      emergency_name: string | null
      customer_aadhaar_number: string | null
      customer_dob: string | null
      vehicle_number: string | null
      documents: Prisma.JsonValue | null
      terms_accepted: boolean
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["trip_initiations"]>
    composites: {}
  }

  type trip_initiationsGetPayload<S extends boolean | null | undefined | trip_initiationsDefaultArgs> = $Result.GetResult<Prisma.$trip_initiationsPayload, S>

  type trip_initiationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trip_initiationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Trip_initiationsCountAggregateInputType | true
    }

  export interface trip_initiationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trip_initiations'], meta: { name: 'trip_initiations' } }
    /**
     * Find zero or one Trip_initiations that matches the filter.
     * @param {trip_initiationsFindUniqueArgs} args - Arguments to find a Trip_initiations
     * @example
     * // Get one Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trip_initiationsFindUniqueArgs>(args: SelectSubset<T, trip_initiationsFindUniqueArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trip_initiations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trip_initiationsFindUniqueOrThrowArgs} args - Arguments to find a Trip_initiations
     * @example
     * // Get one Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trip_initiationsFindUniqueOrThrowArgs>(args: SelectSubset<T, trip_initiationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip_initiations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trip_initiationsFindFirstArgs} args - Arguments to find a Trip_initiations
     * @example
     * // Get one Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trip_initiationsFindFirstArgs>(args?: SelectSubset<T, trip_initiationsFindFirstArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip_initiations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trip_initiationsFindFirstOrThrowArgs} args - Arguments to find a Trip_initiations
     * @example
     * // Get one Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trip_initiationsFindFirstOrThrowArgs>(args?: SelectSubset<T, trip_initiationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trip_initiations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trip_initiationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.findMany()
     * 
     * // Get first 10 Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trip_initiationsWithIdOnly = await prisma.trip_initiations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trip_initiationsFindManyArgs>(args?: SelectSubset<T, trip_initiationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trip_initiations.
     * @param {trip_initiationsCreateArgs} args - Arguments to create a Trip_initiations.
     * @example
     * // Create one Trip_initiations
     * const Trip_initiations = await prisma.trip_initiations.create({
     *   data: {
     *     // ... data to create a Trip_initiations
     *   }
     * })
     * 
     */
    create<T extends trip_initiationsCreateArgs>(args: SelectSubset<T, trip_initiationsCreateArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trip_initiations.
     * @param {trip_initiationsCreateManyArgs} args - Arguments to create many Trip_initiations.
     * @example
     * // Create many Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trip_initiationsCreateManyArgs>(args?: SelectSubset<T, trip_initiationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trip_initiations and returns the data saved in the database.
     * @param {trip_initiationsCreateManyAndReturnArgs} args - Arguments to create many Trip_initiations.
     * @example
     * // Create many Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trip_initiations and only return the `id`
     * const trip_initiationsWithIdOnly = await prisma.trip_initiations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trip_initiationsCreateManyAndReturnArgs>(args?: SelectSubset<T, trip_initiationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trip_initiations.
     * @param {trip_initiationsDeleteArgs} args - Arguments to delete one Trip_initiations.
     * @example
     * // Delete one Trip_initiations
     * const Trip_initiations = await prisma.trip_initiations.delete({
     *   where: {
     *     // ... filter to delete one Trip_initiations
     *   }
     * })
     * 
     */
    delete<T extends trip_initiationsDeleteArgs>(args: SelectSubset<T, trip_initiationsDeleteArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trip_initiations.
     * @param {trip_initiationsUpdateArgs} args - Arguments to update one Trip_initiations.
     * @example
     * // Update one Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trip_initiationsUpdateArgs>(args: SelectSubset<T, trip_initiationsUpdateArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trip_initiations.
     * @param {trip_initiationsDeleteManyArgs} args - Arguments to filter Trip_initiations to delete.
     * @example
     * // Delete a few Trip_initiations
     * const { count } = await prisma.trip_initiations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trip_initiationsDeleteManyArgs>(args?: SelectSubset<T, trip_initiationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trip_initiations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trip_initiationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trip_initiationsUpdateManyArgs>(args: SelectSubset<T, trip_initiationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trip_initiations and returns the data updated in the database.
     * @param {trip_initiationsUpdateManyAndReturnArgs} args - Arguments to update many Trip_initiations.
     * @example
     * // Update many Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trip_initiations and only return the `id`
     * const trip_initiationsWithIdOnly = await prisma.trip_initiations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trip_initiationsUpdateManyAndReturnArgs>(args: SelectSubset<T, trip_initiationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trip_initiations.
     * @param {trip_initiationsUpsertArgs} args - Arguments to update or create a Trip_initiations.
     * @example
     * // Update or create a Trip_initiations
     * const trip_initiations = await prisma.trip_initiations.upsert({
     *   create: {
     *     // ... data to create a Trip_initiations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip_initiations we want to update
     *   }
     * })
     */
    upsert<T extends trip_initiationsUpsertArgs>(args: SelectSubset<T, trip_initiationsUpsertArgs<ExtArgs>>): Prisma__trip_initiationsClient<$Result.GetResult<Prisma.$trip_initiationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trip_initiations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trip_initiationsCountArgs} args - Arguments to filter Trip_initiations to count.
     * @example
     * // Count the number of Trip_initiations
     * const count = await prisma.trip_initiations.count({
     *   where: {
     *     // ... the filter for the Trip_initiations we want to count
     *   }
     * })
    **/
    count<T extends trip_initiationsCountArgs>(
      args?: Subset<T, trip_initiationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Trip_initiationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip_initiations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Trip_initiationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Trip_initiationsAggregateArgs>(args: Subset<T, Trip_initiationsAggregateArgs>): Prisma.PrismaPromise<GetTrip_initiationsAggregateType<T>>

    /**
     * Group by Trip_initiations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trip_initiationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trip_initiationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trip_initiationsGroupByArgs['orderBy'] }
        : { orderBy?: trip_initiationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trip_initiationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrip_initiationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trip_initiations model
   */
  readonly fields: trip_initiationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trip_initiations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trip_initiationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trip_initiations model
   */
  interface trip_initiationsFieldRefs {
    readonly id: FieldRef<"trip_initiations", 'String'>
    readonly booking_id: FieldRef<"trip_initiations", 'String'>
    readonly checklist_completed: FieldRef<"trip_initiations", 'Boolean'>
    readonly customer_name: FieldRef<"trip_initiations", 'String'>
    readonly customer_phone: FieldRef<"trip_initiations", 'String'>
    readonly customer_email: FieldRef<"trip_initiations", 'String'>
    readonly customer_dl_number: FieldRef<"trip_initiations", 'String'>
    readonly customer_address: FieldRef<"trip_initiations", 'String'>
    readonly emergency_contact: FieldRef<"trip_initiations", 'String'>
    readonly emergency_name: FieldRef<"trip_initiations", 'String'>
    readonly customer_aadhaar_number: FieldRef<"trip_initiations", 'String'>
    readonly customer_dob: FieldRef<"trip_initiations", 'String'>
    readonly vehicle_number: FieldRef<"trip_initiations", 'String'>
    readonly documents: FieldRef<"trip_initiations", 'Json'>
    readonly terms_accepted: FieldRef<"trip_initiations", 'Boolean'>
    readonly notes: FieldRef<"trip_initiations", 'String'>
    readonly created_at: FieldRef<"trip_initiations", 'DateTime'>
    readonly updated_at: FieldRef<"trip_initiations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * trip_initiations findUnique
   */
  export type trip_initiationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * Filter, which trip_initiations to fetch.
     */
    where: trip_initiationsWhereUniqueInput
  }

  /**
   * trip_initiations findUniqueOrThrow
   */
  export type trip_initiationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * Filter, which trip_initiations to fetch.
     */
    where: trip_initiationsWhereUniqueInput
  }

  /**
   * trip_initiations findFirst
   */
  export type trip_initiationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * Filter, which trip_initiations to fetch.
     */
    where?: trip_initiationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trip_initiations to fetch.
     */
    orderBy?: trip_initiationsOrderByWithRelationInput | trip_initiationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trip_initiations.
     */
    cursor?: trip_initiationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trip_initiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trip_initiations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trip_initiations.
     */
    distinct?: Trip_initiationsScalarFieldEnum | Trip_initiationsScalarFieldEnum[]
  }

  /**
   * trip_initiations findFirstOrThrow
   */
  export type trip_initiationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * Filter, which trip_initiations to fetch.
     */
    where?: trip_initiationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trip_initiations to fetch.
     */
    orderBy?: trip_initiationsOrderByWithRelationInput | trip_initiationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trip_initiations.
     */
    cursor?: trip_initiationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trip_initiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trip_initiations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trip_initiations.
     */
    distinct?: Trip_initiationsScalarFieldEnum | Trip_initiationsScalarFieldEnum[]
  }

  /**
   * trip_initiations findMany
   */
  export type trip_initiationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * Filter, which trip_initiations to fetch.
     */
    where?: trip_initiationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trip_initiations to fetch.
     */
    orderBy?: trip_initiationsOrderByWithRelationInput | trip_initiationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trip_initiations.
     */
    cursor?: trip_initiationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trip_initiations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trip_initiations.
     */
    skip?: number
    distinct?: Trip_initiationsScalarFieldEnum | Trip_initiationsScalarFieldEnum[]
  }

  /**
   * trip_initiations create
   */
  export type trip_initiationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * The data needed to create a trip_initiations.
     */
    data: XOR<trip_initiationsCreateInput, trip_initiationsUncheckedCreateInput>
  }

  /**
   * trip_initiations createMany
   */
  export type trip_initiationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trip_initiations.
     */
    data: trip_initiationsCreateManyInput | trip_initiationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trip_initiations createManyAndReturn
   */
  export type trip_initiationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * The data used to create many trip_initiations.
     */
    data: trip_initiationsCreateManyInput | trip_initiationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * trip_initiations update
   */
  export type trip_initiationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * The data needed to update a trip_initiations.
     */
    data: XOR<trip_initiationsUpdateInput, trip_initiationsUncheckedUpdateInput>
    /**
     * Choose, which trip_initiations to update.
     */
    where: trip_initiationsWhereUniqueInput
  }

  /**
   * trip_initiations updateMany
   */
  export type trip_initiationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trip_initiations.
     */
    data: XOR<trip_initiationsUpdateManyMutationInput, trip_initiationsUncheckedUpdateManyInput>
    /**
     * Filter which trip_initiations to update
     */
    where?: trip_initiationsWhereInput
    /**
     * Limit how many trip_initiations to update.
     */
    limit?: number
  }

  /**
   * trip_initiations updateManyAndReturn
   */
  export type trip_initiationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * The data used to update trip_initiations.
     */
    data: XOR<trip_initiationsUpdateManyMutationInput, trip_initiationsUncheckedUpdateManyInput>
    /**
     * Filter which trip_initiations to update
     */
    where?: trip_initiationsWhereInput
    /**
     * Limit how many trip_initiations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * trip_initiations upsert
   */
  export type trip_initiationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * The filter to search for the trip_initiations to update in case it exists.
     */
    where: trip_initiationsWhereUniqueInput
    /**
     * In case the trip_initiations found by the `where` argument doesn't exist, create a new trip_initiations with this data.
     */
    create: XOR<trip_initiationsCreateInput, trip_initiationsUncheckedCreateInput>
    /**
     * In case the trip_initiations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trip_initiationsUpdateInput, trip_initiationsUncheckedUpdateInput>
  }

  /**
   * trip_initiations delete
   */
  export type trip_initiationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
    /**
     * Filter which trip_initiations to delete.
     */
    where: trip_initiationsWhereUniqueInput
  }

  /**
   * trip_initiations deleteMany
   */
  export type trip_initiationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trip_initiations to delete
     */
    where?: trip_initiationsWhereInput
    /**
     * Limit how many trip_initiations to delete.
     */
    limit?: number
  }

  /**
   * trip_initiations without action
   */
  export type trip_initiationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trip_initiations
     */
    select?: trip_initiationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trip_initiations
     */
    omit?: trip_initiationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trip_initiationsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password_hash: string | null
    phone: string | null
    reset_token: string | null
    reset_token_expiry: Date | null
    is_blocked: boolean | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password_hash: string | null
    phone: string | null
    reset_token: string | null
    reset_token_expiry: Date | null
    is_blocked: boolean | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password_hash: number
    phone: number
    reset_token: number
    reset_token_expiry: number
    is_blocked: number
    role: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    phone?: true
    reset_token?: true
    reset_token_expiry?: true
    is_blocked?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    phone?: true
    reset_token?: true
    reset_token_expiry?: true
    is_blocked?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    phone?: true
    reset_token?: true
    reset_token_expiry?: true
    is_blocked?: true
    role?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    password_hash: string | null
    phone: string | null
    reset_token: string | null
    reset_token_expiry: Date | null
    is_blocked: boolean | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    is_blocked?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    DeliveryPartner?: boolean | users$DeliveryPartnerArgs<ExtArgs>
    bookings?: boolean | users$bookingsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    is_blocked?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    is_blocked?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    reset_token?: boolean
    reset_token_expiry?: boolean
    is_blocked?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password_hash" | "phone" | "reset_token" | "reset_token_expiry" | "is_blocked" | "role" | "created_at" | "updated_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeliveryPartner?: boolean | users$DeliveryPartnerArgs<ExtArgs>
    bookings?: boolean | users$bookingsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      DeliveryPartner: Prisma.$DeliveryPartnerPayload<ExtArgs>[]
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      password_hash: string | null
      phone: string | null
      reset_token: string | null
      reset_token_expiry: Date | null
      is_blocked: boolean | null
      role: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeliveryPartner<T extends users$DeliveryPartnerArgs<ExtArgs> = {}>(args?: Subset<T, users$DeliveryPartnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends users$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, users$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly reset_token: FieldRef<"users", 'String'>
    readonly reset_token_expiry: FieldRef<"users", 'DateTime'>
    readonly is_blocked: FieldRef<"users", 'Boolean'>
    readonly role: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data?: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.DeliveryPartner
   */
  export type users$DeliveryPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryPartner
     */
    select?: DeliveryPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryPartner
     */
    omit?: DeliveryPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryPartnerInclude<ExtArgs> | null
    where?: DeliveryPartnerWhereInput
    orderBy?: DeliveryPartnerOrderByWithRelationInput | DeliveryPartnerOrderByWithRelationInput[]
    cursor?: DeliveryPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryPartnerScalarFieldEnum | DeliveryPartnerScalarFieldEnum[]
  }

  /**
   * users.bookings
   */
  export type users$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model vehicles
   */

  export type AggregateVehicles = {
    _count: VehiclesCountAggregateOutputType | null
    _avg: VehiclesAvgAggregateOutputType | null
    _sum: VehiclesSumAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  export type VehiclesAvgAggregateOutputType = {
    quantity: number | null
    price_per_hour: number | null
    min_booking_hours: number | null
    price_15_days: number | null
    price_30_days: number | null
    price_7_days: number | null
    delivery_price_15_days: number | null
    delivery_price_30_days: number | null
    delivery_price_7_days: number | null
  }

  export type VehiclesSumAggregateOutputType = {
    quantity: number | null
    price_per_hour: number | null
    min_booking_hours: number | null
    price_15_days: number | null
    price_30_days: number | null
    price_7_days: number | null
    delivery_price_15_days: number | null
    delivery_price_30_days: number | null
    delivery_price_7_days: number | null
  }

  export type VehiclesMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    location: string | null
    quantity: number | null
    price_per_hour: number | null
    min_booking_hours: number | null
    is_available: boolean | null
    images: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    price_15_days: number | null
    price_30_days: number | null
    price_7_days: number | null
    delivery_price_15_days: number | null
    delivery_price_30_days: number | null
    delivery_price_7_days: number | null
    vehicle_category: string | null
  }

  export type VehiclesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    location: string | null
    quantity: number | null
    price_per_hour: number | null
    min_booking_hours: number | null
    is_available: boolean | null
    images: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    price_15_days: number | null
    price_30_days: number | null
    price_7_days: number | null
    delivery_price_15_days: number | null
    delivery_price_30_days: number | null
    delivery_price_7_days: number | null
    vehicle_category: string | null
  }

  export type VehiclesCountAggregateOutputType = {
    id: number
    name: number
    type: number
    location: number
    quantity: number
    price_per_hour: number
    min_booking_hours: number
    is_available: number
    images: number
    status: number
    created_at: number
    updated_at: number
    price_15_days: number
    price_30_days: number
    price_7_days: number
    delivery_price_15_days: number
    delivery_price_30_days: number
    delivery_price_7_days: number
    vehicle_category: number
    _all: number
  }


  export type VehiclesAvgAggregateInputType = {
    quantity?: true
    price_per_hour?: true
    min_booking_hours?: true
    price_15_days?: true
    price_30_days?: true
    price_7_days?: true
    delivery_price_15_days?: true
    delivery_price_30_days?: true
    delivery_price_7_days?: true
  }

  export type VehiclesSumAggregateInputType = {
    quantity?: true
    price_per_hour?: true
    min_booking_hours?: true
    price_15_days?: true
    price_30_days?: true
    price_7_days?: true
    delivery_price_15_days?: true
    delivery_price_30_days?: true
    delivery_price_7_days?: true
  }

  export type VehiclesMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    location?: true
    quantity?: true
    price_per_hour?: true
    min_booking_hours?: true
    is_available?: true
    images?: true
    status?: true
    created_at?: true
    updated_at?: true
    price_15_days?: true
    price_30_days?: true
    price_7_days?: true
    delivery_price_15_days?: true
    delivery_price_30_days?: true
    delivery_price_7_days?: true
    vehicle_category?: true
  }

  export type VehiclesMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    location?: true
    quantity?: true
    price_per_hour?: true
    min_booking_hours?: true
    is_available?: true
    images?: true
    status?: true
    created_at?: true
    updated_at?: true
    price_15_days?: true
    price_30_days?: true
    price_7_days?: true
    delivery_price_15_days?: true
    delivery_price_30_days?: true
    delivery_price_7_days?: true
    vehicle_category?: true
  }

  export type VehiclesCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    location?: true
    quantity?: true
    price_per_hour?: true
    min_booking_hours?: true
    is_available?: true
    images?: true
    status?: true
    created_at?: true
    updated_at?: true
    price_15_days?: true
    price_30_days?: true
    price_7_days?: true
    delivery_price_15_days?: true
    delivery_price_30_days?: true
    delivery_price_7_days?: true
    vehicle_category?: true
    _all?: true
  }

  export type VehiclesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to aggregate.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicles
    **/
    _count?: true | VehiclesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehiclesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehiclesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiclesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiclesMaxAggregateInputType
  }

  export type GetVehiclesAggregateType<T extends VehiclesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicles[P]>
      : GetScalarType<T[P], AggregateVehicles[P]>
  }




  export type vehiclesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiclesWhereInput
    orderBy?: vehiclesOrderByWithAggregationInput | vehiclesOrderByWithAggregationInput[]
    by: VehiclesScalarFieldEnum[] | VehiclesScalarFieldEnum
    having?: vehiclesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiclesCountAggregateInputType | true
    _avg?: VehiclesAvgAggregateInputType
    _sum?: VehiclesSumAggregateInputType
    _min?: VehiclesMinAggregateInputType
    _max?: VehiclesMaxAggregateInputType
  }

  export type VehiclesGroupByOutputType = {
    id: string
    name: string
    type: string
    location: string
    quantity: number
    price_per_hour: number
    min_booking_hours: number
    is_available: boolean | null
    images: string
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    price_15_days: number | null
    price_30_days: number | null
    price_7_days: number | null
    delivery_price_15_days: number | null
    delivery_price_30_days: number | null
    delivery_price_7_days: number | null
    vehicle_category: string
    _count: VehiclesCountAggregateOutputType | null
    _avg: VehiclesAvgAggregateOutputType | null
    _sum: VehiclesSumAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  type GetVehiclesGroupByPayload<T extends vehiclesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiclesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiclesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
            : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
        }
      >
    >


  export type vehiclesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    quantity?: boolean
    price_per_hour?: boolean
    min_booking_hours?: boolean
    is_available?: boolean
    images?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    price_15_days?: boolean
    price_30_days?: boolean
    price_7_days?: boolean
    delivery_price_15_days?: boolean
    delivery_price_30_days?: boolean
    delivery_price_7_days?: boolean
    vehicle_category?: boolean
    bookings?: boolean | vehicles$bookingsArgs<ExtArgs>
    _count?: boolean | VehiclesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    quantity?: boolean
    price_per_hour?: boolean
    min_booking_hours?: boolean
    is_available?: boolean
    images?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    price_15_days?: boolean
    price_30_days?: boolean
    price_7_days?: boolean
    delivery_price_15_days?: boolean
    delivery_price_30_days?: boolean
    delivery_price_7_days?: boolean
    vehicle_category?: boolean
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    quantity?: boolean
    price_per_hour?: boolean
    min_booking_hours?: boolean
    is_available?: boolean
    images?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    price_15_days?: boolean
    price_30_days?: boolean
    price_7_days?: boolean
    delivery_price_15_days?: boolean
    delivery_price_30_days?: boolean
    delivery_price_7_days?: boolean
    vehicle_category?: boolean
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    quantity?: boolean
    price_per_hour?: boolean
    min_booking_hours?: boolean
    is_available?: boolean
    images?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    price_15_days?: boolean
    price_30_days?: boolean
    price_7_days?: boolean
    delivery_price_15_days?: boolean
    delivery_price_30_days?: boolean
    delivery_price_7_days?: boolean
    vehicle_category?: boolean
  }

  export type vehiclesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "location" | "quantity" | "price_per_hour" | "min_booking_hours" | "is_available" | "images" | "status" | "created_at" | "updated_at" | "price_15_days" | "price_30_days" | "price_7_days" | "delivery_price_15_days" | "delivery_price_30_days" | "delivery_price_7_days" | "vehicle_category", ExtArgs["result"]["vehicles"]>
  export type vehiclesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | vehicles$bookingsArgs<ExtArgs>
    _count?: boolean | VehiclesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehiclesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type vehiclesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $vehiclesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicles"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      location: string
      quantity: number
      price_per_hour: number
      min_booking_hours: number
      is_available: boolean | null
      images: string
      status: string | null
      created_at: Date | null
      updated_at: Date | null
      price_15_days: number | null
      price_30_days: number | null
      price_7_days: number | null
      delivery_price_15_days: number | null
      delivery_price_30_days: number | null
      delivery_price_7_days: number | null
      vehicle_category: string
    }, ExtArgs["result"]["vehicles"]>
    composites: {}
  }

  type vehiclesGetPayload<S extends boolean | null | undefined | vehiclesDefaultArgs> = $Result.GetResult<Prisma.$vehiclesPayload, S>

  type vehiclesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehiclesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehiclesCountAggregateInputType | true
    }

  export interface vehiclesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicles'], meta: { name: 'vehicles' } }
    /**
     * Find zero or one Vehicles that matches the filter.
     * @param {vehiclesFindUniqueArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehiclesFindUniqueArgs>(args: SelectSubset<T, vehiclesFindUniqueArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehiclesFindUniqueOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehiclesFindUniqueOrThrowArgs>(args: SelectSubset<T, vehiclesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehiclesFindFirstArgs>(args?: SelectSubset<T, vehiclesFindFirstArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehiclesFindFirstOrThrowArgs>(args?: SelectSubset<T, vehiclesFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicles.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehiclesFindManyArgs>(args?: SelectSubset<T, vehiclesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicles.
     * @param {vehiclesCreateArgs} args - Arguments to create a Vehicles.
     * @example
     * // Create one Vehicles
     * const Vehicles = await prisma.vehicles.create({
     *   data: {
     *     // ... data to create a Vehicles
     *   }
     * })
     * 
     */
    create<T extends vehiclesCreateArgs>(args: SelectSubset<T, vehiclesCreateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {vehiclesCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehiclesCreateManyArgs>(args?: SelectSubset<T, vehiclesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {vehiclesCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehiclesCreateManyAndReturnArgs>(args?: SelectSubset<T, vehiclesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicles.
     * @param {vehiclesDeleteArgs} args - Arguments to delete one Vehicles.
     * @example
     * // Delete one Vehicles
     * const Vehicles = await prisma.vehicles.delete({
     *   where: {
     *     // ... filter to delete one Vehicles
     *   }
     * })
     * 
     */
    delete<T extends vehiclesDeleteArgs>(args: SelectSubset<T, vehiclesDeleteArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicles.
     * @param {vehiclesUpdateArgs} args - Arguments to update one Vehicles.
     * @example
     * // Update one Vehicles
     * const vehicles = await prisma.vehicles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehiclesUpdateArgs>(args: SelectSubset<T, vehiclesUpdateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {vehiclesDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehiclesDeleteManyArgs>(args?: SelectSubset<T, vehiclesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicles = await prisma.vehicles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehiclesUpdateManyArgs>(args: SelectSubset<T, vehiclesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {vehiclesUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicles = await prisma.vehicles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vehiclesUpdateManyAndReturnArgs>(args: SelectSubset<T, vehiclesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicles.
     * @param {vehiclesUpsertArgs} args - Arguments to update or create a Vehicles.
     * @example
     * // Update or create a Vehicles
     * const vehicles = await prisma.vehicles.upsert({
     *   create: {
     *     // ... data to create a Vehicles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicles we want to update
     *   }
     * })
     */
    upsert<T extends vehiclesUpsertArgs>(args: SelectSubset<T, vehiclesUpsertArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicles.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends vehiclesCountArgs>(
      args?: Subset<T, vehiclesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiclesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiclesAggregateArgs>(args: Subset<T, VehiclesAggregateArgs>): Prisma.PrismaPromise<GetVehiclesAggregateType<T>>

    /**
     * Group by Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehiclesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehiclesGroupByArgs['orderBy'] }
        : { orderBy?: vehiclesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehiclesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiclesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicles model
   */
  readonly fields: vehiclesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehiclesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends vehicles$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, vehicles$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicles model
   */
  interface vehiclesFieldRefs {
    readonly id: FieldRef<"vehicles", 'String'>
    readonly name: FieldRef<"vehicles", 'String'>
    readonly type: FieldRef<"vehicles", 'String'>
    readonly location: FieldRef<"vehicles", 'String'>
    readonly quantity: FieldRef<"vehicles", 'Int'>
    readonly price_per_hour: FieldRef<"vehicles", 'Float'>
    readonly min_booking_hours: FieldRef<"vehicles", 'Int'>
    readonly is_available: FieldRef<"vehicles", 'Boolean'>
    readonly images: FieldRef<"vehicles", 'String'>
    readonly status: FieldRef<"vehicles", 'String'>
    readonly created_at: FieldRef<"vehicles", 'DateTime'>
    readonly updated_at: FieldRef<"vehicles", 'DateTime'>
    readonly price_15_days: FieldRef<"vehicles", 'Float'>
    readonly price_30_days: FieldRef<"vehicles", 'Float'>
    readonly price_7_days: FieldRef<"vehicles", 'Float'>
    readonly delivery_price_15_days: FieldRef<"vehicles", 'Float'>
    readonly delivery_price_30_days: FieldRef<"vehicles", 'Float'>
    readonly delivery_price_7_days: FieldRef<"vehicles", 'Float'>
    readonly vehicle_category: FieldRef<"vehicles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * vehicles findUnique
   */
  export type vehiclesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findUniqueOrThrow
   */
  export type vehiclesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findFirst
   */
  export type vehiclesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findFirstOrThrow
   */
  export type vehiclesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findMany
   */
  export type vehiclesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles create
   */
  export type vehiclesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicles.
     */
    data: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
  }

  /**
   * vehicles createMany
   */
  export type vehiclesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicles createManyAndReturn
   */
  export type vehiclesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicles update
   */
  export type vehiclesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicles.
     */
    data: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
    /**
     * Choose, which vehicles to update.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles updateMany
   */
  export type vehiclesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to update.
     */
    limit?: number
  }

  /**
   * vehicles updateManyAndReturn
   */
  export type vehiclesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to update.
     */
    limit?: number
  }

  /**
   * vehicles upsert
   */
  export type vehiclesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicles to update in case it exists.
     */
    where: vehiclesWhereUniqueInput
    /**
     * In case the vehicles found by the `where` argument doesn't exist, create a new vehicles with this data.
     */
    create: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
    /**
     * In case the vehicles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
  }

  /**
   * vehicles delete
   */
  export type vehiclesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter which vehicles to delete.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles deleteMany
   */
  export type vehiclesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to delete
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to delete.
     */
    limit?: number
  }

  /**
   * vehicles.bookings
   */
  export type vehicles$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * vehicles without action
   */
  export type vehiclesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminNotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    recipient: 'recipient',
    channel: 'channel',
    status: 'status',
    error: 'error',
    data: 'data',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdminNotificationScalarFieldEnum = (typeof AdminNotificationScalarFieldEnum)[keyof typeof AdminNotificationScalarFieldEnum]


  export const DeliveryBookingScalarFieldEnum: {
    id: 'id',
    delivery_partner_id: 'delivery_partner_id',
    booking_id: 'booking_id',
    pickup_location: 'pickup_location',
    dropoff_location: 'dropoff_location',
    status: 'status',
    estimated_distance: 'estimated_distance',
    estimated_duration: 'estimated_duration',
    actual_duration: 'actual_duration',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeliveryBookingScalarFieldEnum = (typeof DeliveryBookingScalarFieldEnum)[keyof typeof DeliveryBookingScalarFieldEnum]


  export const DeliveryPartnerScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    vehicle_type: 'vehicle_type',
    vehicle_number: 'vehicle_number',
    license_number: 'license_number',
    is_available: 'is_available',
    current_location: 'current_location',
    rating: 'rating',
    total_trips: 'total_trips',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DeliveryPartnerScalarFieldEnum = (typeof DeliveryPartnerScalarFieldEnum)[keyof typeof DeliveryPartnerScalarFieldEnum]


  export const DeliveryTrackingScalarFieldEnum: {
    id: 'id',
    delivery_booking_id: 'delivery_booking_id',
    location: 'location',
    timestamp: 'timestamp',
    status: 'status',
    notes: 'notes'
  };

  export type DeliveryTrackingScalarFieldEnum = (typeof DeliveryTrackingScalarFieldEnum)[keyof typeof DeliveryTrackingScalarFieldEnum]


  export const Booking_historyScalarFieldEnum: {
    id: 'id',
    booking_id: 'booking_id',
    action: 'action',
    details: 'details',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Booking_historyScalarFieldEnum = (typeof Booking_historyScalarFieldEnum)[keyof typeof Booking_historyScalarFieldEnum]


  export const BookingsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    vehicle_id: 'vehicle_id',
    start_date: 'start_date',
    end_date: 'end_date',
    total_hours: 'total_hours',
    total_price: 'total_price',
    status: 'status',
    payment_status: 'payment_status',
    payment_details: 'payment_details',
    created_at: 'created_at',
    updated_at: 'updated_at',
    pickup_location: 'pickup_location',
    dropoff_location: 'dropoff_location',
    booking_id: 'booking_id',
    payment_intent_id: 'payment_intent_id'
  };

  export type BookingsScalarFieldEnum = (typeof BookingsScalarFieldEnum)[keyof typeof BookingsScalarFieldEnum]


  export const CouponsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discount_type: 'discount_type',
    discount_value: 'discount_value',
    min_booking_amount: 'min_booking_amount',
    max_discount_amount: 'max_discount_amount',
    start_date: 'start_date',
    end_date: 'end_date',
    usage_limit: 'usage_limit',
    times_used: 'times_used',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CouponsScalarFieldEnum = (typeof CouponsScalarFieldEnum)[keyof typeof CouponsScalarFieldEnum]


  export const Document_submissionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    document_type: 'document_type',
    document_url: 'document_url',
    status: 'status',
    admin_comments: 'admin_comments',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Document_submissionsScalarFieldEnum = (typeof Document_submissionsScalarFieldEnum)[keyof typeof Document_submissionsScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    status: 'status',
    file_url: 'file_url',
    rejection_reason: 'rejection_reason',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const Email_logsScalarFieldEnum: {
    id: 'id',
    recipient: 'recipient',
    subject: 'subject',
    message_content: 'message_content',
    status: 'status',
    error: 'error',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Email_logsScalarFieldEnum = (typeof Email_logsScalarFieldEnum)[keyof typeof Email_logsScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    booking_id: 'booking_id',
    user_id: 'user_id',
    amount: 'amount',
    payment_method: 'payment_method',
    transaction_id: 'transaction_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const ProfilesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    phone: 'phone',
    avatar_url: 'avatar_url',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    zip_code: 'zip_code',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProfilesScalarFieldEnum = (typeof ProfilesScalarFieldEnum)[keyof typeof ProfilesScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    vehicle_id: 'vehicle_id',
    booking_id: 'booking_id',
    rating: 'rating',
    comment: 'comment',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const Sms_logsScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    message: 'message',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Sms_logsScalarFieldEnum = (typeof Sms_logsScalarFieldEnum)[keyof typeof Sms_logsScalarFieldEnum]


  export const Trip_initiationsScalarFieldEnum: {
    id: 'id',
    booking_id: 'booking_id',
    checklist_completed: 'checklist_completed',
    customer_name: 'customer_name',
    customer_phone: 'customer_phone',
    customer_email: 'customer_email',
    customer_dl_number: 'customer_dl_number',
    customer_address: 'customer_address',
    emergency_contact: 'emergency_contact',
    emergency_name: 'emergency_name',
    customer_aadhaar_number: 'customer_aadhaar_number',
    customer_dob: 'customer_dob',
    vehicle_number: 'vehicle_number',
    documents: 'documents',
    terms_accepted: 'terms_accepted',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Trip_initiationsScalarFieldEnum = (typeof Trip_initiationsScalarFieldEnum)[keyof typeof Trip_initiationsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password_hash: 'password_hash',
    phone: 'phone',
    reset_token: 'reset_token',
    reset_token_expiry: 'reset_token_expiry',
    is_blocked: 'is_blocked',
    role: 'role',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VehiclesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    location: 'location',
    quantity: 'quantity',
    price_per_hour: 'price_per_hour',
    min_booking_hours: 'min_booking_hours',
    is_available: 'is_available',
    images: 'images',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    price_15_days: 'price_15_days',
    price_30_days: 'price_30_days',
    price_7_days: 'price_7_days',
    delivery_price_15_days: 'delivery_price_15_days',
    delivery_price_30_days: 'delivery_price_30_days',
    delivery_price_7_days: 'delivery_price_7_days',
    vehicle_category: 'vehicle_category'
  };

  export type VehiclesScalarFieldEnum = (typeof VehiclesScalarFieldEnum)[keyof typeof VehiclesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminNotificationWhereInput = {
    AND?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    OR?: AdminNotificationWhereInput[]
    NOT?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    id?: StringFilter<"AdminNotification"> | string
    type?: StringFilter<"AdminNotification"> | string
    title?: StringFilter<"AdminNotification"> | string
    recipient?: StringFilter<"AdminNotification"> | string
    channel?: StringFilter<"AdminNotification"> | string
    status?: StringFilter<"AdminNotification"> | string
    error?: StringNullableFilter<"AdminNotification"> | string | null
    data?: StringNullableFilter<"AdminNotification"> | string | null
    created_at?: DateTimeFilter<"AdminNotification"> | Date | string
    updated_at?: DateTimeFilter<"AdminNotification"> | Date | string
  }

  export type AdminNotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    OR?: AdminNotificationWhereInput[]
    NOT?: AdminNotificationWhereInput | AdminNotificationWhereInput[]
    type?: StringFilter<"AdminNotification"> | string
    title?: StringFilter<"AdminNotification"> | string
    recipient?: StringFilter<"AdminNotification"> | string
    channel?: StringFilter<"AdminNotification"> | string
    status?: StringFilter<"AdminNotification"> | string
    error?: StringNullableFilter<"AdminNotification"> | string | null
    data?: StringNullableFilter<"AdminNotification"> | string | null
    created_at?: DateTimeFilter<"AdminNotification"> | Date | string
    updated_at?: DateTimeFilter<"AdminNotification"> | Date | string
  }, "id">

  export type AdminNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AdminNotificationCountOrderByAggregateInput
    _max?: AdminNotificationMaxOrderByAggregateInput
    _min?: AdminNotificationMinOrderByAggregateInput
  }

  export type AdminNotificationScalarWhereWithAggregatesInput = {
    AND?: AdminNotificationScalarWhereWithAggregatesInput | AdminNotificationScalarWhereWithAggregatesInput[]
    OR?: AdminNotificationScalarWhereWithAggregatesInput[]
    NOT?: AdminNotificationScalarWhereWithAggregatesInput | AdminNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminNotification"> | string
    type?: StringWithAggregatesFilter<"AdminNotification"> | string
    title?: StringWithAggregatesFilter<"AdminNotification"> | string
    recipient?: StringWithAggregatesFilter<"AdminNotification"> | string
    channel?: StringWithAggregatesFilter<"AdminNotification"> | string
    status?: StringWithAggregatesFilter<"AdminNotification"> | string
    error?: StringNullableWithAggregatesFilter<"AdminNotification"> | string | null
    data?: StringNullableWithAggregatesFilter<"AdminNotification"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AdminNotification"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AdminNotification"> | Date | string
  }

  export type DeliveryBookingWhereInput = {
    AND?: DeliveryBookingWhereInput | DeliveryBookingWhereInput[]
    OR?: DeliveryBookingWhereInput[]
    NOT?: DeliveryBookingWhereInput | DeliveryBookingWhereInput[]
    id?: UuidFilter<"DeliveryBooking"> | string
    delivery_partner_id?: UuidFilter<"DeliveryBooking"> | string
    booking_id?: UuidFilter<"DeliveryBooking"> | string
    pickup_location?: JsonFilter<"DeliveryBooking">
    dropoff_location?: JsonFilter<"DeliveryBooking">
    status?: StringFilter<"DeliveryBooking"> | string
    estimated_distance?: FloatFilter<"DeliveryBooking"> | number
    estimated_duration?: IntFilter<"DeliveryBooking"> | number
    actual_duration?: IntNullableFilter<"DeliveryBooking"> | number | null
    price?: FloatFilter<"DeliveryBooking"> | number
    created_at?: DateTimeFilter<"DeliveryBooking"> | Date | string
    updated_at?: DateTimeFilter<"DeliveryBooking"> | Date | string
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
    DeliveryPartner?: XOR<DeliveryPartnerScalarRelationFilter, DeliveryPartnerWhereInput>
    DeliveryTracking?: DeliveryTrackingListRelationFilter
  }

  export type DeliveryBookingOrderByWithRelationInput = {
    id?: SortOrder
    delivery_partner_id?: SortOrder
    booking_id?: SortOrder
    pickup_location?: SortOrder
    dropoff_location?: SortOrder
    status?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    actual_duration?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    bookings?: bookingsOrderByWithRelationInput
    DeliveryPartner?: DeliveryPartnerOrderByWithRelationInput
    DeliveryTracking?: DeliveryTrackingOrderByRelationAggregateInput
  }

  export type DeliveryBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    booking_id?: string
    AND?: DeliveryBookingWhereInput | DeliveryBookingWhereInput[]
    OR?: DeliveryBookingWhereInput[]
    NOT?: DeliveryBookingWhereInput | DeliveryBookingWhereInput[]
    delivery_partner_id?: UuidFilter<"DeliveryBooking"> | string
    pickup_location?: JsonFilter<"DeliveryBooking">
    dropoff_location?: JsonFilter<"DeliveryBooking">
    status?: StringFilter<"DeliveryBooking"> | string
    estimated_distance?: FloatFilter<"DeliveryBooking"> | number
    estimated_duration?: IntFilter<"DeliveryBooking"> | number
    actual_duration?: IntNullableFilter<"DeliveryBooking"> | number | null
    price?: FloatFilter<"DeliveryBooking"> | number
    created_at?: DateTimeFilter<"DeliveryBooking"> | Date | string
    updated_at?: DateTimeFilter<"DeliveryBooking"> | Date | string
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
    DeliveryPartner?: XOR<DeliveryPartnerScalarRelationFilter, DeliveryPartnerWhereInput>
    DeliveryTracking?: DeliveryTrackingListRelationFilter
  }, "id" | "booking_id">

  export type DeliveryBookingOrderByWithAggregationInput = {
    id?: SortOrder
    delivery_partner_id?: SortOrder
    booking_id?: SortOrder
    pickup_location?: SortOrder
    dropoff_location?: SortOrder
    status?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    actual_duration?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeliveryBookingCountOrderByAggregateInput
    _avg?: DeliveryBookingAvgOrderByAggregateInput
    _max?: DeliveryBookingMaxOrderByAggregateInput
    _min?: DeliveryBookingMinOrderByAggregateInput
    _sum?: DeliveryBookingSumOrderByAggregateInput
  }

  export type DeliveryBookingScalarWhereWithAggregatesInput = {
    AND?: DeliveryBookingScalarWhereWithAggregatesInput | DeliveryBookingScalarWhereWithAggregatesInput[]
    OR?: DeliveryBookingScalarWhereWithAggregatesInput[]
    NOT?: DeliveryBookingScalarWhereWithAggregatesInput | DeliveryBookingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeliveryBooking"> | string
    delivery_partner_id?: UuidWithAggregatesFilter<"DeliveryBooking"> | string
    booking_id?: UuidWithAggregatesFilter<"DeliveryBooking"> | string
    pickup_location?: JsonWithAggregatesFilter<"DeliveryBooking">
    dropoff_location?: JsonWithAggregatesFilter<"DeliveryBooking">
    status?: StringWithAggregatesFilter<"DeliveryBooking"> | string
    estimated_distance?: FloatWithAggregatesFilter<"DeliveryBooking"> | number
    estimated_duration?: IntWithAggregatesFilter<"DeliveryBooking"> | number
    actual_duration?: IntNullableWithAggregatesFilter<"DeliveryBooking"> | number | null
    price?: FloatWithAggregatesFilter<"DeliveryBooking"> | number
    created_at?: DateTimeWithAggregatesFilter<"DeliveryBooking"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"DeliveryBooking"> | Date | string
  }

  export type DeliveryPartnerWhereInput = {
    AND?: DeliveryPartnerWhereInput | DeliveryPartnerWhereInput[]
    OR?: DeliveryPartnerWhereInput[]
    NOT?: DeliveryPartnerWhereInput | DeliveryPartnerWhereInput[]
    id?: UuidFilter<"DeliveryPartner"> | string
    user_id?: UuidFilter<"DeliveryPartner"> | string
    vehicle_type?: StringFilter<"DeliveryPartner"> | string
    vehicle_number?: StringFilter<"DeliveryPartner"> | string
    license_number?: StringFilter<"DeliveryPartner"> | string
    is_available?: BoolFilter<"DeliveryPartner"> | boolean
    current_location?: JsonNullableFilter<"DeliveryPartner">
    rating?: FloatFilter<"DeliveryPartner"> | number
    total_trips?: IntFilter<"DeliveryPartner"> | number
    created_at?: DateTimeFilter<"DeliveryPartner"> | Date | string
    updated_at?: DateTimeFilter<"DeliveryPartner"> | Date | string
    DeliveryBooking?: DeliveryBookingListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type DeliveryPartnerOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_type?: SortOrder
    vehicle_number?: SortOrder
    license_number?: SortOrder
    is_available?: SortOrder
    current_location?: SortOrderInput | SortOrder
    rating?: SortOrder
    total_trips?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    DeliveryBooking?: DeliveryBookingOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type DeliveryPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryPartnerWhereInput | DeliveryPartnerWhereInput[]
    OR?: DeliveryPartnerWhereInput[]
    NOT?: DeliveryPartnerWhereInput | DeliveryPartnerWhereInput[]
    user_id?: UuidFilter<"DeliveryPartner"> | string
    vehicle_type?: StringFilter<"DeliveryPartner"> | string
    vehicle_number?: StringFilter<"DeliveryPartner"> | string
    license_number?: StringFilter<"DeliveryPartner"> | string
    is_available?: BoolFilter<"DeliveryPartner"> | boolean
    current_location?: JsonNullableFilter<"DeliveryPartner">
    rating?: FloatFilter<"DeliveryPartner"> | number
    total_trips?: IntFilter<"DeliveryPartner"> | number
    created_at?: DateTimeFilter<"DeliveryPartner"> | Date | string
    updated_at?: DateTimeFilter<"DeliveryPartner"> | Date | string
    DeliveryBooking?: DeliveryBookingListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type DeliveryPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_type?: SortOrder
    vehicle_number?: SortOrder
    license_number?: SortOrder
    is_available?: SortOrder
    current_location?: SortOrderInput | SortOrder
    rating?: SortOrder
    total_trips?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DeliveryPartnerCountOrderByAggregateInput
    _avg?: DeliveryPartnerAvgOrderByAggregateInput
    _max?: DeliveryPartnerMaxOrderByAggregateInput
    _min?: DeliveryPartnerMinOrderByAggregateInput
    _sum?: DeliveryPartnerSumOrderByAggregateInput
  }

  export type DeliveryPartnerScalarWhereWithAggregatesInput = {
    AND?: DeliveryPartnerScalarWhereWithAggregatesInput | DeliveryPartnerScalarWhereWithAggregatesInput[]
    OR?: DeliveryPartnerScalarWhereWithAggregatesInput[]
    NOT?: DeliveryPartnerScalarWhereWithAggregatesInput | DeliveryPartnerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeliveryPartner"> | string
    user_id?: UuidWithAggregatesFilter<"DeliveryPartner"> | string
    vehicle_type?: StringWithAggregatesFilter<"DeliveryPartner"> | string
    vehicle_number?: StringWithAggregatesFilter<"DeliveryPartner"> | string
    license_number?: StringWithAggregatesFilter<"DeliveryPartner"> | string
    is_available?: BoolWithAggregatesFilter<"DeliveryPartner"> | boolean
    current_location?: JsonNullableWithAggregatesFilter<"DeliveryPartner">
    rating?: FloatWithAggregatesFilter<"DeliveryPartner"> | number
    total_trips?: IntWithAggregatesFilter<"DeliveryPartner"> | number
    created_at?: DateTimeWithAggregatesFilter<"DeliveryPartner"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"DeliveryPartner"> | Date | string
  }

  export type DeliveryTrackingWhereInput = {
    AND?: DeliveryTrackingWhereInput | DeliveryTrackingWhereInput[]
    OR?: DeliveryTrackingWhereInput[]
    NOT?: DeliveryTrackingWhereInput | DeliveryTrackingWhereInput[]
    id?: UuidFilter<"DeliveryTracking"> | string
    delivery_booking_id?: UuidFilter<"DeliveryTracking"> | string
    location?: JsonFilter<"DeliveryTracking">
    timestamp?: DateTimeFilter<"DeliveryTracking"> | Date | string
    status?: StringFilter<"DeliveryTracking"> | string
    notes?: StringNullableFilter<"DeliveryTracking"> | string | null
    DeliveryBooking?: XOR<DeliveryBookingScalarRelationFilter, DeliveryBookingWhereInput>
  }

  export type DeliveryTrackingOrderByWithRelationInput = {
    id?: SortOrder
    delivery_booking_id?: SortOrder
    location?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    DeliveryBooking?: DeliveryBookingOrderByWithRelationInput
  }

  export type DeliveryTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryTrackingWhereInput | DeliveryTrackingWhereInput[]
    OR?: DeliveryTrackingWhereInput[]
    NOT?: DeliveryTrackingWhereInput | DeliveryTrackingWhereInput[]
    delivery_booking_id?: UuidFilter<"DeliveryTracking"> | string
    location?: JsonFilter<"DeliveryTracking">
    timestamp?: DateTimeFilter<"DeliveryTracking"> | Date | string
    status?: StringFilter<"DeliveryTracking"> | string
    notes?: StringNullableFilter<"DeliveryTracking"> | string | null
    DeliveryBooking?: XOR<DeliveryBookingScalarRelationFilter, DeliveryBookingWhereInput>
  }, "id">

  export type DeliveryTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    delivery_booking_id?: SortOrder
    location?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: DeliveryTrackingCountOrderByAggregateInput
    _max?: DeliveryTrackingMaxOrderByAggregateInput
    _min?: DeliveryTrackingMinOrderByAggregateInput
  }

  export type DeliveryTrackingScalarWhereWithAggregatesInput = {
    AND?: DeliveryTrackingScalarWhereWithAggregatesInput | DeliveryTrackingScalarWhereWithAggregatesInput[]
    OR?: DeliveryTrackingScalarWhereWithAggregatesInput[]
    NOT?: DeliveryTrackingScalarWhereWithAggregatesInput | DeliveryTrackingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DeliveryTracking"> | string
    delivery_booking_id?: UuidWithAggregatesFilter<"DeliveryTracking"> | string
    location?: JsonWithAggregatesFilter<"DeliveryTracking">
    timestamp?: DateTimeWithAggregatesFilter<"DeliveryTracking"> | Date | string
    status?: StringWithAggregatesFilter<"DeliveryTracking"> | string
    notes?: StringNullableWithAggregatesFilter<"DeliveryTracking"> | string | null
  }

  export type booking_historyWhereInput = {
    AND?: booking_historyWhereInput | booking_historyWhereInput[]
    OR?: booking_historyWhereInput[]
    NOT?: booking_historyWhereInput | booking_historyWhereInput[]
    id?: UuidFilter<"booking_history"> | string
    booking_id?: UuidFilter<"booking_history"> | string
    action?: StringFilter<"booking_history"> | string
    details?: StringFilter<"booking_history"> | string
    created_by?: StringFilter<"booking_history"> | string
    created_at?: DateTimeFilter<"booking_history"> | Date | string
    updated_at?: DateTimeFilter<"booking_history"> | Date | string
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
  }

  export type booking_historyOrderByWithRelationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    bookings?: bookingsOrderByWithRelationInput
  }

  export type booking_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: booking_historyWhereInput | booking_historyWhereInput[]
    OR?: booking_historyWhereInput[]
    NOT?: booking_historyWhereInput | booking_historyWhereInput[]
    booking_id?: UuidFilter<"booking_history"> | string
    action?: StringFilter<"booking_history"> | string
    details?: StringFilter<"booking_history"> | string
    created_by?: StringFilter<"booking_history"> | string
    created_at?: DateTimeFilter<"booking_history"> | Date | string
    updated_at?: DateTimeFilter<"booking_history"> | Date | string
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
  }, "id">

  export type booking_historyOrderByWithAggregationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: booking_historyCountOrderByAggregateInput
    _max?: booking_historyMaxOrderByAggregateInput
    _min?: booking_historyMinOrderByAggregateInput
  }

  export type booking_historyScalarWhereWithAggregatesInput = {
    AND?: booking_historyScalarWhereWithAggregatesInput | booking_historyScalarWhereWithAggregatesInput[]
    OR?: booking_historyScalarWhereWithAggregatesInput[]
    NOT?: booking_historyScalarWhereWithAggregatesInput | booking_historyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"booking_history"> | string
    booking_id?: UuidWithAggregatesFilter<"booking_history"> | string
    action?: StringWithAggregatesFilter<"booking_history"> | string
    details?: StringWithAggregatesFilter<"booking_history"> | string
    created_by?: StringWithAggregatesFilter<"booking_history"> | string
    created_at?: DateTimeWithAggregatesFilter<"booking_history"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"booking_history"> | Date | string
  }

  export type bookingsWhereInput = {
    AND?: bookingsWhereInput | bookingsWhereInput[]
    OR?: bookingsWhereInput[]
    NOT?: bookingsWhereInput | bookingsWhereInput[]
    id?: UuidFilter<"bookings"> | string
    user_id?: UuidFilter<"bookings"> | string
    vehicle_id?: UuidFilter<"bookings"> | string
    start_date?: DateTimeFilter<"bookings"> | Date | string
    end_date?: DateTimeFilter<"bookings"> | Date | string
    total_hours?: FloatFilter<"bookings"> | number
    total_price?: FloatFilter<"bookings"> | number
    status?: StringNullableFilter<"bookings"> | string | null
    payment_status?: StringNullableFilter<"bookings"> | string | null
    payment_details?: StringNullableFilter<"bookings"> | string | null
    created_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    pickup_location?: StringNullableFilter<"bookings"> | string | null
    dropoff_location?: StringNullableFilter<"bookings"> | string | null
    booking_id?: StringNullableFilter<"bookings"> | string | null
    payment_intent_id?: StringNullableFilter<"bookings"> | string | null
    DeliveryBooking?: XOR<DeliveryBookingNullableScalarRelationFilter, DeliveryBookingWhereInput> | null
    booking_history?: Booking_historyListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    vehicles?: XOR<VehiclesScalarRelationFilter, vehiclesWhereInput>
    trip_initiations?: XOR<Trip_initiationsNullableScalarRelationFilter, trip_initiationsWhereInput> | null
  }

  export type bookingsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_hours?: SortOrder
    total_price?: SortOrder
    status?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    payment_details?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    pickup_location?: SortOrderInput | SortOrder
    dropoff_location?: SortOrderInput | SortOrder
    booking_id?: SortOrderInput | SortOrder
    payment_intent_id?: SortOrderInput | SortOrder
    DeliveryBooking?: DeliveryBookingOrderByWithRelationInput
    booking_history?: booking_historyOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    vehicles?: vehiclesOrderByWithRelationInput
    trip_initiations?: trip_initiationsOrderByWithRelationInput
  }

  export type bookingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    payment_intent_id?: string
    AND?: bookingsWhereInput | bookingsWhereInput[]
    OR?: bookingsWhereInput[]
    NOT?: bookingsWhereInput | bookingsWhereInput[]
    user_id?: UuidFilter<"bookings"> | string
    vehicle_id?: UuidFilter<"bookings"> | string
    start_date?: DateTimeFilter<"bookings"> | Date | string
    end_date?: DateTimeFilter<"bookings"> | Date | string
    total_hours?: FloatFilter<"bookings"> | number
    total_price?: FloatFilter<"bookings"> | number
    status?: StringNullableFilter<"bookings"> | string | null
    payment_status?: StringNullableFilter<"bookings"> | string | null
    payment_details?: StringNullableFilter<"bookings"> | string | null
    created_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    pickup_location?: StringNullableFilter<"bookings"> | string | null
    dropoff_location?: StringNullableFilter<"bookings"> | string | null
    booking_id?: StringNullableFilter<"bookings"> | string | null
    DeliveryBooking?: XOR<DeliveryBookingNullableScalarRelationFilter, DeliveryBookingWhereInput> | null
    booking_history?: Booking_historyListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    vehicles?: XOR<VehiclesScalarRelationFilter, vehiclesWhereInput>
    trip_initiations?: XOR<Trip_initiationsNullableScalarRelationFilter, trip_initiationsWhereInput> | null
  }, "id" | "payment_intent_id">

  export type bookingsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_hours?: SortOrder
    total_price?: SortOrder
    status?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    payment_details?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    pickup_location?: SortOrderInput | SortOrder
    dropoff_location?: SortOrderInput | SortOrder
    booking_id?: SortOrderInput | SortOrder
    payment_intent_id?: SortOrderInput | SortOrder
    _count?: bookingsCountOrderByAggregateInput
    _avg?: bookingsAvgOrderByAggregateInput
    _max?: bookingsMaxOrderByAggregateInput
    _min?: bookingsMinOrderByAggregateInput
    _sum?: bookingsSumOrderByAggregateInput
  }

  export type bookingsScalarWhereWithAggregatesInput = {
    AND?: bookingsScalarWhereWithAggregatesInput | bookingsScalarWhereWithAggregatesInput[]
    OR?: bookingsScalarWhereWithAggregatesInput[]
    NOT?: bookingsScalarWhereWithAggregatesInput | bookingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bookings"> | string
    user_id?: UuidWithAggregatesFilter<"bookings"> | string
    vehicle_id?: UuidWithAggregatesFilter<"bookings"> | string
    start_date?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    total_hours?: FloatWithAggregatesFilter<"bookings"> | number
    total_price?: FloatWithAggregatesFilter<"bookings"> | number
    status?: StringNullableWithAggregatesFilter<"bookings"> | string | null
    payment_status?: StringNullableWithAggregatesFilter<"bookings"> | string | null
    payment_details?: StringNullableWithAggregatesFilter<"bookings"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bookings"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bookings"> | Date | string | null
    pickup_location?: StringNullableWithAggregatesFilter<"bookings"> | string | null
    dropoff_location?: StringNullableWithAggregatesFilter<"bookings"> | string | null
    booking_id?: StringNullableWithAggregatesFilter<"bookings"> | string | null
    payment_intent_id?: StringNullableWithAggregatesFilter<"bookings"> | string | null
  }

  export type couponsWhereInput = {
    AND?: couponsWhereInput | couponsWhereInput[]
    OR?: couponsWhereInput[]
    NOT?: couponsWhereInput | couponsWhereInput[]
    id?: StringFilter<"coupons"> | string
    code?: StringFilter<"coupons"> | string
    description?: StringNullableFilter<"coupons"> | string | null
    discount_type?: StringFilter<"coupons"> | string
    discount_value?: DecimalFilter<"coupons"> | Decimal | DecimalJsLike | number | string
    min_booking_amount?: DecimalNullableFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: DecimalNullableFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeNullableFilter<"coupons"> | Date | string | null
    end_date?: DateTimeNullableFilter<"coupons"> | Date | string | null
    usage_limit?: IntNullableFilter<"coupons"> | number | null
    times_used?: IntNullableFilter<"coupons"> | number | null
    is_active?: BoolNullableFilter<"coupons"> | boolean | null
    created_at?: DateTimeNullableFilter<"coupons"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"coupons"> | Date | string | null
  }

  export type couponsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    min_booking_amount?: SortOrderInput | SortOrder
    max_discount_amount?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    usage_limit?: SortOrderInput | SortOrder
    times_used?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type couponsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: couponsWhereInput | couponsWhereInput[]
    OR?: couponsWhereInput[]
    NOT?: couponsWhereInput | couponsWhereInput[]
    description?: StringNullableFilter<"coupons"> | string | null
    discount_type?: StringFilter<"coupons"> | string
    discount_value?: DecimalFilter<"coupons"> | Decimal | DecimalJsLike | number | string
    min_booking_amount?: DecimalNullableFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: DecimalNullableFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeNullableFilter<"coupons"> | Date | string | null
    end_date?: DateTimeNullableFilter<"coupons"> | Date | string | null
    usage_limit?: IntNullableFilter<"coupons"> | number | null
    times_used?: IntNullableFilter<"coupons"> | number | null
    is_active?: BoolNullableFilter<"coupons"> | boolean | null
    created_at?: DateTimeNullableFilter<"coupons"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"coupons"> | Date | string | null
  }, "id" | "code">

  export type couponsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    min_booking_amount?: SortOrderInput | SortOrder
    max_discount_amount?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    usage_limit?: SortOrderInput | SortOrder
    times_used?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: couponsCountOrderByAggregateInput
    _avg?: couponsAvgOrderByAggregateInput
    _max?: couponsMaxOrderByAggregateInput
    _min?: couponsMinOrderByAggregateInput
    _sum?: couponsSumOrderByAggregateInput
  }

  export type couponsScalarWhereWithAggregatesInput = {
    AND?: couponsScalarWhereWithAggregatesInput | couponsScalarWhereWithAggregatesInput[]
    OR?: couponsScalarWhereWithAggregatesInput[]
    NOT?: couponsScalarWhereWithAggregatesInput | couponsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"coupons"> | string
    code?: StringWithAggregatesFilter<"coupons"> | string
    description?: StringNullableWithAggregatesFilter<"coupons"> | string | null
    discount_type?: StringWithAggregatesFilter<"coupons"> | string
    discount_value?: DecimalWithAggregatesFilter<"coupons"> | Decimal | DecimalJsLike | number | string
    min_booking_amount?: DecimalNullableWithAggregatesFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: DecimalNullableWithAggregatesFilter<"coupons"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"coupons"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"coupons"> | Date | string | null
    usage_limit?: IntNullableWithAggregatesFilter<"coupons"> | number | null
    times_used?: IntNullableWithAggregatesFilter<"coupons"> | number | null
    is_active?: BoolNullableWithAggregatesFilter<"coupons"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"coupons"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"coupons"> | Date | string | null
  }

  export type document_submissionsWhereInput = {
    AND?: document_submissionsWhereInput | document_submissionsWhereInput[]
    OR?: document_submissionsWhereInput[]
    NOT?: document_submissionsWhereInput | document_submissionsWhereInput[]
    id?: IntFilter<"document_submissions"> | number
    user_id?: IntNullableFilter<"document_submissions"> | number | null
    document_type?: StringFilter<"document_submissions"> | string
    document_url?: StringFilter<"document_submissions"> | string
    status?: StringNullableFilter<"document_submissions"> | string | null
    admin_comments?: StringNullableFilter<"document_submissions"> | string | null
    created_at?: DateTimeNullableFilter<"document_submissions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"document_submissions"> | Date | string | null
  }

  export type document_submissionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    document_type?: SortOrder
    document_url?: SortOrder
    status?: SortOrderInput | SortOrder
    admin_comments?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type document_submissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: document_submissionsWhereInput | document_submissionsWhereInput[]
    OR?: document_submissionsWhereInput[]
    NOT?: document_submissionsWhereInput | document_submissionsWhereInput[]
    user_id?: IntNullableFilter<"document_submissions"> | number | null
    document_type?: StringFilter<"document_submissions"> | string
    document_url?: StringFilter<"document_submissions"> | string
    status?: StringNullableFilter<"document_submissions"> | string | null
    admin_comments?: StringNullableFilter<"document_submissions"> | string | null
    created_at?: DateTimeNullableFilter<"document_submissions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"document_submissions"> | Date | string | null
  }, "id">

  export type document_submissionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    document_type?: SortOrder
    document_url?: SortOrder
    status?: SortOrderInput | SortOrder
    admin_comments?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: document_submissionsCountOrderByAggregateInput
    _avg?: document_submissionsAvgOrderByAggregateInput
    _max?: document_submissionsMaxOrderByAggregateInput
    _min?: document_submissionsMinOrderByAggregateInput
    _sum?: document_submissionsSumOrderByAggregateInput
  }

  export type document_submissionsScalarWhereWithAggregatesInput = {
    AND?: document_submissionsScalarWhereWithAggregatesInput | document_submissionsScalarWhereWithAggregatesInput[]
    OR?: document_submissionsScalarWhereWithAggregatesInput[]
    NOT?: document_submissionsScalarWhereWithAggregatesInput | document_submissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"document_submissions"> | number
    user_id?: IntNullableWithAggregatesFilter<"document_submissions"> | number | null
    document_type?: StringWithAggregatesFilter<"document_submissions"> | string
    document_url?: StringWithAggregatesFilter<"document_submissions"> | string
    status?: StringNullableWithAggregatesFilter<"document_submissions"> | string | null
    admin_comments?: StringNullableWithAggregatesFilter<"document_submissions"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"document_submissions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"document_submissions"> | Date | string | null
  }

  export type documentsWhereInput = {
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    id?: UuidFilter<"documents"> | string
    user_id?: UuidFilter<"documents"> | string
    type?: StringFilter<"documents"> | string
    status?: StringNullableFilter<"documents"> | string | null
    file_url?: StringFilter<"documents"> | string
    rejection_reason?: StringNullableFilter<"documents"> | string | null
    created_at?: DateTimeNullableFilter<"documents"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"documents"> | Date | string | null
  }

  export type documentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    status?: SortOrderInput | SortOrder
    file_url?: SortOrder
    rejection_reason?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    user_id?: UuidFilter<"documents"> | string
    type?: StringFilter<"documents"> | string
    status?: StringNullableFilter<"documents"> | string | null
    file_url?: StringFilter<"documents"> | string
    rejection_reason?: StringNullableFilter<"documents"> | string | null
    created_at?: DateTimeNullableFilter<"documents"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"documents"> | Date | string | null
  }, "id">

  export type documentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    status?: SortOrderInput | SortOrder
    file_url?: SortOrder
    rejection_reason?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: documentsCountOrderByAggregateInput
    _max?: documentsMaxOrderByAggregateInput
    _min?: documentsMinOrderByAggregateInput
  }

  export type documentsScalarWhereWithAggregatesInput = {
    AND?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    OR?: documentsScalarWhereWithAggregatesInput[]
    NOT?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"documents"> | string
    user_id?: UuidWithAggregatesFilter<"documents"> | string
    type?: StringWithAggregatesFilter<"documents"> | string
    status?: StringNullableWithAggregatesFilter<"documents"> | string | null
    file_url?: StringWithAggregatesFilter<"documents"> | string
    rejection_reason?: StringNullableWithAggregatesFilter<"documents"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"documents"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"documents"> | Date | string | null
  }

  export type email_logsWhereInput = {
    AND?: email_logsWhereInput | email_logsWhereInput[]
    OR?: email_logsWhereInput[]
    NOT?: email_logsWhereInput | email_logsWhereInput[]
    id?: UuidFilter<"email_logs"> | string
    recipient?: StringFilter<"email_logs"> | string
    subject?: StringFilter<"email_logs"> | string
    message_content?: StringFilter<"email_logs"> | string
    status?: StringFilter<"email_logs"> | string
    error?: StringNullableFilter<"email_logs"> | string | null
    created_at?: DateTimeNullableFilter<"email_logs"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"email_logs"> | Date | string | null
  }

  export type email_logsOrderByWithRelationInput = {
    id?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message_content?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type email_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: email_logsWhereInput | email_logsWhereInput[]
    OR?: email_logsWhereInput[]
    NOT?: email_logsWhereInput | email_logsWhereInput[]
    recipient?: StringFilter<"email_logs"> | string
    subject?: StringFilter<"email_logs"> | string
    message_content?: StringFilter<"email_logs"> | string
    status?: StringFilter<"email_logs"> | string
    error?: StringNullableFilter<"email_logs"> | string | null
    created_at?: DateTimeNullableFilter<"email_logs"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"email_logs"> | Date | string | null
  }, "id">

  export type email_logsOrderByWithAggregationInput = {
    id?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message_content?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: email_logsCountOrderByAggregateInput
    _max?: email_logsMaxOrderByAggregateInput
    _min?: email_logsMinOrderByAggregateInput
  }

  export type email_logsScalarWhereWithAggregatesInput = {
    AND?: email_logsScalarWhereWithAggregatesInput | email_logsScalarWhereWithAggregatesInput[]
    OR?: email_logsScalarWhereWithAggregatesInput[]
    NOT?: email_logsScalarWhereWithAggregatesInput | email_logsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"email_logs"> | string
    recipient?: StringWithAggregatesFilter<"email_logs"> | string
    subject?: StringWithAggregatesFilter<"email_logs"> | string
    message_content?: StringWithAggregatesFilter<"email_logs"> | string
    status?: StringWithAggregatesFilter<"email_logs"> | string
    error?: StringNullableWithAggregatesFilter<"email_logs"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"email_logs"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"email_logs"> | Date | string | null
  }

  export type locationsWhereInput = {
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    id?: StringFilter<"locations"> | string
    name?: StringFilter<"locations"> | string
    address?: StringFilter<"locations"> | string
    created_at?: DateTimeNullableFilter<"locations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"locations"> | Date | string | null
  }

  export type locationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    name?: StringFilter<"locations"> | string
    address?: StringFilter<"locations"> | string
    created_at?: DateTimeNullableFilter<"locations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"locations"> | Date | string | null
  }, "id">

  export type locationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: locationsCountOrderByAggregateInput
    _max?: locationsMaxOrderByAggregateInput
    _min?: locationsMinOrderByAggregateInput
  }

  export type locationsScalarWhereWithAggregatesInput = {
    AND?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    OR?: locationsScalarWhereWithAggregatesInput[]
    NOT?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"locations"> | string
    name?: StringWithAggregatesFilter<"locations"> | string
    address?: StringWithAggregatesFilter<"locations"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"locations"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"locations"> | Date | string | null
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: IntFilter<"payments"> | number
    booking_id?: IntNullableFilter<"payments"> | number | null
    user_id?: IntNullableFilter<"payments"> | number | null
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringNullableFilter<"payments"> | string | null
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    booking_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    booking_id?: IntNullableFilter<"payments"> | number | null
    user_id?: IntNullableFilter<"payments"> | number | null
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringNullableFilter<"payments"> | string | null
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    booking_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payments"> | number
    booking_id?: IntNullableWithAggregatesFilter<"payments"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"payments"> | number | null
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringNullableWithAggregatesFilter<"payments"> | string | null
    transaction_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    status?: StringNullableWithAggregatesFilter<"payments"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
  }

  export type profilesWhereInput = {
    AND?: profilesWhereInput | profilesWhereInput[]
    OR?: profilesWhereInput[]
    NOT?: profilesWhereInput | profilesWhereInput[]
    id?: StringFilter<"profiles"> | string
    user_id?: StringNullableFilter<"profiles"> | string | null
    name?: StringNullableFilter<"profiles"> | string | null
    phone?: StringNullableFilter<"profiles"> | string | null
    avatar_url?: StringNullableFilter<"profiles"> | string | null
    address?: StringNullableFilter<"profiles"> | string | null
    city?: StringNullableFilter<"profiles"> | string | null
    state?: StringNullableFilter<"profiles"> | string | null
    country?: StringNullableFilter<"profiles"> | string | null
    zip_code?: StringNullableFilter<"profiles"> | string | null
    created_at?: DateTimeNullableFilter<"profiles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"profiles"> | Date | string | null
  }

  export type profilesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar_url?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zip_code?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type profilesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: profilesWhereInput | profilesWhereInput[]
    OR?: profilesWhereInput[]
    NOT?: profilesWhereInput | profilesWhereInput[]
    user_id?: StringNullableFilter<"profiles"> | string | null
    name?: StringNullableFilter<"profiles"> | string | null
    phone?: StringNullableFilter<"profiles"> | string | null
    avatar_url?: StringNullableFilter<"profiles"> | string | null
    address?: StringNullableFilter<"profiles"> | string | null
    city?: StringNullableFilter<"profiles"> | string | null
    state?: StringNullableFilter<"profiles"> | string | null
    country?: StringNullableFilter<"profiles"> | string | null
    zip_code?: StringNullableFilter<"profiles"> | string | null
    created_at?: DateTimeNullableFilter<"profiles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"profiles"> | Date | string | null
  }, "id">

  export type profilesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar_url?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zip_code?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: profilesCountOrderByAggregateInput
    _max?: profilesMaxOrderByAggregateInput
    _min?: profilesMinOrderByAggregateInput
  }

  export type profilesScalarWhereWithAggregatesInput = {
    AND?: profilesScalarWhereWithAggregatesInput | profilesScalarWhereWithAggregatesInput[]
    OR?: profilesScalarWhereWithAggregatesInput[]
    NOT?: profilesScalarWhereWithAggregatesInput | profilesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"profiles"> | string
    user_id?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    name?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    phone?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    avatar_url?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    address?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    city?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    state?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    country?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    zip_code?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"profiles"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"profiles"> | Date | string | null
  }

  export type reviewsWhereInput = {
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    id?: IntFilter<"reviews"> | number
    user_id?: IntNullableFilter<"reviews"> | number | null
    vehicle_id?: IntNullableFilter<"reviews"> | number | null
    booking_id?: IntNullableFilter<"reviews"> | number | null
    rating?: IntFilter<"reviews"> | number
    comment?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
  }

  export type reviewsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    vehicle_id?: SortOrderInput | SortOrder
    booking_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type reviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    user_id?: IntNullableFilter<"reviews"> | number | null
    vehicle_id?: IntNullableFilter<"reviews"> | number | null
    booking_id?: IntNullableFilter<"reviews"> | number | null
    rating?: IntFilter<"reviews"> | number
    comment?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
  }, "id">

  export type reviewsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    vehicle_id?: SortOrderInput | SortOrder
    booking_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: reviewsCountOrderByAggregateInput
    _avg?: reviewsAvgOrderByAggregateInput
    _max?: reviewsMaxOrderByAggregateInput
    _min?: reviewsMinOrderByAggregateInput
    _sum?: reviewsSumOrderByAggregateInput
  }

  export type reviewsScalarWhereWithAggregatesInput = {
    AND?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    OR?: reviewsScalarWhereWithAggregatesInput[]
    NOT?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reviews"> | number
    user_id?: IntNullableWithAggregatesFilter<"reviews"> | number | null
    vehicle_id?: IntNullableWithAggregatesFilter<"reviews"> | number | null
    booking_id?: IntNullableWithAggregatesFilter<"reviews"> | number | null
    rating?: IntWithAggregatesFilter<"reviews"> | number
    comment?: StringNullableWithAggregatesFilter<"reviews"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"reviews"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"reviews"> | Date | string | null
  }

  export type settingsWhereInput = {
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    id?: StringFilter<"settings"> | string
    key?: StringFilter<"settings"> | string
    value?: StringFilter<"settings"> | string
    created_at?: DateTimeFilter<"settings"> | Date | string
    updated_at?: DateTimeFilter<"settings"> | Date | string
  }

  export type settingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    value?: StringFilter<"settings"> | string
    created_at?: DateTimeFilter<"settings"> | Date | string
    updated_at?: DateTimeFilter<"settings"> | Date | string
  }, "id" | "key">

  export type settingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: settingsCountOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    OR?: settingsScalarWhereWithAggregatesInput[]
    NOT?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"settings"> | string
    key?: StringWithAggregatesFilter<"settings"> | string
    value?: StringWithAggregatesFilter<"settings"> | string
    created_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string
  }

  export type sms_logsWhereInput = {
    AND?: sms_logsWhereInput | sms_logsWhereInput[]
    OR?: sms_logsWhereInput[]
    NOT?: sms_logsWhereInput | sms_logsWhereInput[]
    id?: StringFilter<"sms_logs"> | string
    phone_number?: StringFilter<"sms_logs"> | string
    message?: StringFilter<"sms_logs"> | string
    status?: StringFilter<"sms_logs"> | string
    created_at?: DateTimeFilter<"sms_logs"> | Date | string
    updated_at?: DateTimeFilter<"sms_logs"> | Date | string
  }

  export type sms_logsOrderByWithRelationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sms_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sms_logsWhereInput | sms_logsWhereInput[]
    OR?: sms_logsWhereInput[]
    NOT?: sms_logsWhereInput | sms_logsWhereInput[]
    phone_number?: StringFilter<"sms_logs"> | string
    message?: StringFilter<"sms_logs"> | string
    status?: StringFilter<"sms_logs"> | string
    created_at?: DateTimeFilter<"sms_logs"> | Date | string
    updated_at?: DateTimeFilter<"sms_logs"> | Date | string
  }, "id">

  export type sms_logsOrderByWithAggregationInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: sms_logsCountOrderByAggregateInput
    _max?: sms_logsMaxOrderByAggregateInput
    _min?: sms_logsMinOrderByAggregateInput
  }

  export type sms_logsScalarWhereWithAggregatesInput = {
    AND?: sms_logsScalarWhereWithAggregatesInput | sms_logsScalarWhereWithAggregatesInput[]
    OR?: sms_logsScalarWhereWithAggregatesInput[]
    NOT?: sms_logsScalarWhereWithAggregatesInput | sms_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sms_logs"> | string
    phone_number?: StringWithAggregatesFilter<"sms_logs"> | string
    message?: StringWithAggregatesFilter<"sms_logs"> | string
    status?: StringWithAggregatesFilter<"sms_logs"> | string
    created_at?: DateTimeWithAggregatesFilter<"sms_logs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"sms_logs"> | Date | string
  }

  export type trip_initiationsWhereInput = {
    AND?: trip_initiationsWhereInput | trip_initiationsWhereInput[]
    OR?: trip_initiationsWhereInput[]
    NOT?: trip_initiationsWhereInput | trip_initiationsWhereInput[]
    id?: UuidFilter<"trip_initiations"> | string
    booking_id?: UuidFilter<"trip_initiations"> | string
    checklist_completed?: BoolFilter<"trip_initiations"> | boolean
    customer_name?: StringFilter<"trip_initiations"> | string
    customer_phone?: StringFilter<"trip_initiations"> | string
    customer_email?: StringNullableFilter<"trip_initiations"> | string | null
    customer_dl_number?: StringNullableFilter<"trip_initiations"> | string | null
    customer_address?: StringNullableFilter<"trip_initiations"> | string | null
    emergency_contact?: StringNullableFilter<"trip_initiations"> | string | null
    emergency_name?: StringNullableFilter<"trip_initiations"> | string | null
    customer_aadhaar_number?: StringNullableFilter<"trip_initiations"> | string | null
    customer_dob?: StringNullableFilter<"trip_initiations"> | string | null
    vehicle_number?: StringNullableFilter<"trip_initiations"> | string | null
    documents?: JsonNullableFilter<"trip_initiations">
    terms_accepted?: BoolFilter<"trip_initiations"> | boolean
    notes?: StringNullableFilter<"trip_initiations"> | string | null
    created_at?: DateTimeFilter<"trip_initiations"> | Date | string
    updated_at?: DateTimeFilter<"trip_initiations"> | Date | string
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
  }

  export type trip_initiationsOrderByWithRelationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    checklist_completed?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_email?: SortOrderInput | SortOrder
    customer_dl_number?: SortOrderInput | SortOrder
    customer_address?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    emergency_name?: SortOrderInput | SortOrder
    customer_aadhaar_number?: SortOrderInput | SortOrder
    customer_dob?: SortOrderInput | SortOrder
    vehicle_number?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    terms_accepted?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    bookings?: bookingsOrderByWithRelationInput
  }

  export type trip_initiationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    booking_id?: string
    AND?: trip_initiationsWhereInput | trip_initiationsWhereInput[]
    OR?: trip_initiationsWhereInput[]
    NOT?: trip_initiationsWhereInput | trip_initiationsWhereInput[]
    checklist_completed?: BoolFilter<"trip_initiations"> | boolean
    customer_name?: StringFilter<"trip_initiations"> | string
    customer_phone?: StringFilter<"trip_initiations"> | string
    customer_email?: StringNullableFilter<"trip_initiations"> | string | null
    customer_dl_number?: StringNullableFilter<"trip_initiations"> | string | null
    customer_address?: StringNullableFilter<"trip_initiations"> | string | null
    emergency_contact?: StringNullableFilter<"trip_initiations"> | string | null
    emergency_name?: StringNullableFilter<"trip_initiations"> | string | null
    customer_aadhaar_number?: StringNullableFilter<"trip_initiations"> | string | null
    customer_dob?: StringNullableFilter<"trip_initiations"> | string | null
    vehicle_number?: StringNullableFilter<"trip_initiations"> | string | null
    documents?: JsonNullableFilter<"trip_initiations">
    terms_accepted?: BoolFilter<"trip_initiations"> | boolean
    notes?: StringNullableFilter<"trip_initiations"> | string | null
    created_at?: DateTimeFilter<"trip_initiations"> | Date | string
    updated_at?: DateTimeFilter<"trip_initiations"> | Date | string
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
  }, "id" | "booking_id">

  export type trip_initiationsOrderByWithAggregationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    checklist_completed?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_email?: SortOrderInput | SortOrder
    customer_dl_number?: SortOrderInput | SortOrder
    customer_address?: SortOrderInput | SortOrder
    emergency_contact?: SortOrderInput | SortOrder
    emergency_name?: SortOrderInput | SortOrder
    customer_aadhaar_number?: SortOrderInput | SortOrder
    customer_dob?: SortOrderInput | SortOrder
    vehicle_number?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    terms_accepted?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: trip_initiationsCountOrderByAggregateInput
    _max?: trip_initiationsMaxOrderByAggregateInput
    _min?: trip_initiationsMinOrderByAggregateInput
  }

  export type trip_initiationsScalarWhereWithAggregatesInput = {
    AND?: trip_initiationsScalarWhereWithAggregatesInput | trip_initiationsScalarWhereWithAggregatesInput[]
    OR?: trip_initiationsScalarWhereWithAggregatesInput[]
    NOT?: trip_initiationsScalarWhereWithAggregatesInput | trip_initiationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"trip_initiations"> | string
    booking_id?: UuidWithAggregatesFilter<"trip_initiations"> | string
    checklist_completed?: BoolWithAggregatesFilter<"trip_initiations"> | boolean
    customer_name?: StringWithAggregatesFilter<"trip_initiations"> | string
    customer_phone?: StringWithAggregatesFilter<"trip_initiations"> | string
    customer_email?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    customer_dl_number?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    customer_address?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    emergency_contact?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    emergency_name?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    customer_aadhaar_number?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    customer_dob?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    vehicle_number?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    documents?: JsonNullableWithAggregatesFilter<"trip_initiations">
    terms_accepted?: BoolWithAggregatesFilter<"trip_initiations"> | boolean
    notes?: StringNullableWithAggregatesFilter<"trip_initiations"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"trip_initiations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"trip_initiations"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    password_hash?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    reset_token?: StringNullableFilter<"users"> | string | null
    reset_token_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    is_blocked?: BoolNullableFilter<"users"> | boolean | null
    role?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    DeliveryPartner?: DeliveryPartnerListRelationFilter
    bookings?: BookingsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expiry?: SortOrderInput | SortOrder
    is_blocked?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    DeliveryPartner?: DeliveryPartnerOrderByRelationAggregateInput
    bookings?: bookingsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringNullableFilter<"users"> | string | null
    password_hash?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    reset_token?: StringNullableFilter<"users"> | string | null
    reset_token_expiry?: DateTimeNullableFilter<"users"> | Date | string | null
    is_blocked?: BoolNullableFilter<"users"> | boolean | null
    role?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    DeliveryPartner?: DeliveryPartnerListRelationFilter
    bookings?: BookingsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    reset_token?: SortOrderInput | SortOrder
    reset_token_expiry?: SortOrderInput | SortOrder
    is_blocked?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    password_hash?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    reset_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    reset_token_expiry?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    is_blocked?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    role?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type vehiclesWhereInput = {
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    id?: UuidFilter<"vehicles"> | string
    name?: StringFilter<"vehicles"> | string
    type?: StringFilter<"vehicles"> | string
    location?: StringFilter<"vehicles"> | string
    quantity?: IntFilter<"vehicles"> | number
    price_per_hour?: FloatFilter<"vehicles"> | number
    min_booking_hours?: IntFilter<"vehicles"> | number
    is_available?: BoolNullableFilter<"vehicles"> | boolean | null
    images?: StringFilter<"vehicles"> | string
    status?: StringNullableFilter<"vehicles"> | string | null
    created_at?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    price_15_days?: FloatNullableFilter<"vehicles"> | number | null
    price_30_days?: FloatNullableFilter<"vehicles"> | number | null
    price_7_days?: FloatNullableFilter<"vehicles"> | number | null
    delivery_price_15_days?: FloatNullableFilter<"vehicles"> | number | null
    delivery_price_30_days?: FloatNullableFilter<"vehicles"> | number | null
    delivery_price_7_days?: FloatNullableFilter<"vehicles"> | number | null
    vehicle_category?: StringFilter<"vehicles"> | string
    bookings?: BookingsListRelationFilter
  }

  export type vehiclesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    price_per_hour?: SortOrder
    min_booking_hours?: SortOrder
    is_available?: SortOrderInput | SortOrder
    images?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    price_15_days?: SortOrderInput | SortOrder
    price_30_days?: SortOrderInput | SortOrder
    price_7_days?: SortOrderInput | SortOrder
    delivery_price_15_days?: SortOrderInput | SortOrder
    delivery_price_30_days?: SortOrderInput | SortOrder
    delivery_price_7_days?: SortOrderInput | SortOrder
    vehicle_category?: SortOrder
    bookings?: bookingsOrderByRelationAggregateInput
  }

  export type vehiclesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    name?: StringFilter<"vehicles"> | string
    type?: StringFilter<"vehicles"> | string
    location?: StringFilter<"vehicles"> | string
    quantity?: IntFilter<"vehicles"> | number
    price_per_hour?: FloatFilter<"vehicles"> | number
    min_booking_hours?: IntFilter<"vehicles"> | number
    is_available?: BoolNullableFilter<"vehicles"> | boolean | null
    images?: StringFilter<"vehicles"> | string
    status?: StringNullableFilter<"vehicles"> | string | null
    created_at?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"vehicles"> | Date | string | null
    price_15_days?: FloatNullableFilter<"vehicles"> | number | null
    price_30_days?: FloatNullableFilter<"vehicles"> | number | null
    price_7_days?: FloatNullableFilter<"vehicles"> | number | null
    delivery_price_15_days?: FloatNullableFilter<"vehicles"> | number | null
    delivery_price_30_days?: FloatNullableFilter<"vehicles"> | number | null
    delivery_price_7_days?: FloatNullableFilter<"vehicles"> | number | null
    vehicle_category?: StringFilter<"vehicles"> | string
    bookings?: BookingsListRelationFilter
  }, "id">

  export type vehiclesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    price_per_hour?: SortOrder
    min_booking_hours?: SortOrder
    is_available?: SortOrderInput | SortOrder
    images?: SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    price_15_days?: SortOrderInput | SortOrder
    price_30_days?: SortOrderInput | SortOrder
    price_7_days?: SortOrderInput | SortOrder
    delivery_price_15_days?: SortOrderInput | SortOrder
    delivery_price_30_days?: SortOrderInput | SortOrder
    delivery_price_7_days?: SortOrderInput | SortOrder
    vehicle_category?: SortOrder
    _count?: vehiclesCountOrderByAggregateInput
    _avg?: vehiclesAvgOrderByAggregateInput
    _max?: vehiclesMaxOrderByAggregateInput
    _min?: vehiclesMinOrderByAggregateInput
    _sum?: vehiclesSumOrderByAggregateInput
  }

  export type vehiclesScalarWhereWithAggregatesInput = {
    AND?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    OR?: vehiclesScalarWhereWithAggregatesInput[]
    NOT?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"vehicles"> | string
    name?: StringWithAggregatesFilter<"vehicles"> | string
    type?: StringWithAggregatesFilter<"vehicles"> | string
    location?: StringWithAggregatesFilter<"vehicles"> | string
    quantity?: IntWithAggregatesFilter<"vehicles"> | number
    price_per_hour?: FloatWithAggregatesFilter<"vehicles"> | number
    min_booking_hours?: IntWithAggregatesFilter<"vehicles"> | number
    is_available?: BoolNullableWithAggregatesFilter<"vehicles"> | boolean | null
    images?: StringWithAggregatesFilter<"vehicles"> | string
    status?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"vehicles"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"vehicles"> | Date | string | null
    price_15_days?: FloatNullableWithAggregatesFilter<"vehicles"> | number | null
    price_30_days?: FloatNullableWithAggregatesFilter<"vehicles"> | number | null
    price_7_days?: FloatNullableWithAggregatesFilter<"vehicles"> | number | null
    delivery_price_15_days?: FloatNullableWithAggregatesFilter<"vehicles"> | number | null
    delivery_price_30_days?: FloatNullableWithAggregatesFilter<"vehicles"> | number | null
    delivery_price_7_days?: FloatNullableWithAggregatesFilter<"vehicles"> | number | null
    vehicle_category?: StringWithAggregatesFilter<"vehicles"> | string
  }

  export type AdminNotificationCreateInput = {
    id: string
    type: string
    title: string
    recipient: string
    channel: string
    status: string
    error?: string | null
    data?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type AdminNotificationUncheckedCreateInput = {
    id: string
    type: string
    title: string
    recipient: string
    channel: string
    status: string
    error?: string | null
    data?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type AdminNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationCreateManyInput = {
    id: string
    type: string
    title: string
    recipient: string
    channel: string
    status: string
    error?: string | null
    data?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type AdminNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBookingCreateInput = {
    id?: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    bookings: bookingsCreateNestedOneWithoutDeliveryBookingInput
    DeliveryPartner: DeliveryPartnerCreateNestedOneWithoutDeliveryBookingInput
    DeliveryTracking?: DeliveryTrackingCreateNestedManyWithoutDeliveryBookingInput
  }

  export type DeliveryBookingUncheckedCreateInput = {
    id?: string
    delivery_partner_id: string
    booking_id: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryTracking?: DeliveryTrackingUncheckedCreateNestedManyWithoutDeliveryBookingInput
  }

  export type DeliveryBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateOneRequiredWithoutDeliveryBookingNestedInput
    DeliveryPartner?: DeliveryPartnerUpdateOneRequiredWithoutDeliveryBookingNestedInput
    DeliveryTracking?: DeliveryTrackingUpdateManyWithoutDeliveryBookingNestedInput
  }

  export type DeliveryBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_partner_id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryTracking?: DeliveryTrackingUncheckedUpdateManyWithoutDeliveryBookingNestedInput
  }

  export type DeliveryBookingCreateManyInput = {
    id?: string
    delivery_partner_id: string
    booking_id: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_partner_id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryPartnerCreateInput = {
    id?: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryBooking?: DeliveryBookingCreateNestedManyWithoutDeliveryPartnerInput
    users: usersCreateNestedOneWithoutDeliveryPartnerInput
  }

  export type DeliveryPartnerUncheckedCreateInput = {
    id?: string
    user_id: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryBooking?: DeliveryBookingUncheckedCreateNestedManyWithoutDeliveryPartnerInput
  }

  export type DeliveryPartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryBooking?: DeliveryBookingUpdateManyWithoutDeliveryPartnerNestedInput
    users?: usersUpdateOneRequiredWithoutDeliveryPartnerNestedInput
  }

  export type DeliveryPartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryBooking?: DeliveryBookingUncheckedUpdateManyWithoutDeliveryPartnerNestedInput
  }

  export type DeliveryPartnerCreateManyInput = {
    id?: string
    user_id: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryPartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryPartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryTrackingCreateInput = {
    id?: string
    location: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status: string
    notes?: string | null
    DeliveryBooking: DeliveryBookingCreateNestedOneWithoutDeliveryTrackingInput
  }

  export type DeliveryTrackingUncheckedCreateInput = {
    id?: string
    delivery_booking_id: string
    location: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status: string
    notes?: string | null
  }

  export type DeliveryTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUpdateOneRequiredWithoutDeliveryTrackingNestedInput
  }

  export type DeliveryTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_booking_id?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryTrackingCreateManyInput = {
    id?: string
    delivery_booking_id: string
    location: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status: string
    notes?: string | null
  }

  export type DeliveryTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_booking_id?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type booking_historyCreateInput = {
    id?: string
    action: string
    details: string
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    bookings: bookingsCreateNestedOneWithoutBooking_historyInput
  }

  export type booking_historyUncheckedCreateInput = {
    id?: string
    booking_id: string
    action: string
    details: string
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type booking_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateOneRequiredWithoutBooking_historyNestedInput
  }

  export type booking_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_historyCreateManyInput = {
    id?: string
    booking_id: string
    action: string
    details: string
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type booking_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsCreateInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyCreateNestedManyWithoutBookingsInput
    users: usersCreateNestedOneWithoutBookingsInput
    vehicles: vehiclesCreateNestedOneWithoutBookingsInput
    trip_initiations?: trip_initiationsCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateInput = {
    id?: string
    user_id: string
    vehicle_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingUncheckedCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyUncheckedCreateNestedManyWithoutBookingsInput
    trip_initiations?: trip_initiationsUncheckedCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUpdateManyWithoutBookingsNestedInput
    users?: usersUpdateOneRequiredWithoutBookingsNestedInput
    vehicles?: vehiclesUpdateOneRequiredWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUncheckedUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUncheckedUpdateManyWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUncheckedUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsCreateManyInput = {
    id?: string
    user_id: string
    vehicle_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
  }

  export type bookingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsCreateInput = {
    id: string
    code: string
    description?: string | null
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    min_booking_amount?: Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage_limit?: number | null
    times_used?: number | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type couponsUncheckedCreateInput = {
    id: string
    code: string
    description?: string | null
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    min_booking_amount?: Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage_limit?: number | null
    times_used?: number | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type couponsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_booking_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage_limit?: NullableIntFieldUpdateOperationsInput | number | null
    times_used?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_booking_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage_limit?: NullableIntFieldUpdateOperationsInput | number | null
    times_used?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsCreateManyInput = {
    id: string
    code: string
    description?: string | null
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    min_booking_amount?: Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    usage_limit?: number | null
    times_used?: number | null
    is_active?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type couponsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_booking_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage_limit?: NullableIntFieldUpdateOperationsInput | number | null
    times_used?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_booking_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_discount_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usage_limit?: NullableIntFieldUpdateOperationsInput | number | null
    times_used?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_submissionsCreateInput = {
    user_id?: number | null
    document_type: string
    document_url: string
    status?: string | null
    admin_comments?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type document_submissionsUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    document_type: string
    document_url: string
    status?: string | null
    admin_comments?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type document_submissionsUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    document_type?: StringFieldUpdateOperationsInput | string
    document_url?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_submissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    document_type?: StringFieldUpdateOperationsInput | string
    document_url?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_submissionsCreateManyInput = {
    id?: number
    user_id?: number | null
    document_type: string
    document_url: string
    status?: string | null
    admin_comments?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type document_submissionsUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    document_type?: StringFieldUpdateOperationsInput | string
    document_url?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_submissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    document_type?: StringFieldUpdateOperationsInput | string
    document_url?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsCreateInput = {
    id?: string
    user_id: string
    type: string
    status?: string | null
    file_url: string
    rejection_reason?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type documentsUncheckedCreateInput = {
    id?: string
    user_id: string
    type: string
    status?: string | null
    file_url: string
    rejection_reason?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type documentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsCreateManyInput = {
    id?: string
    user_id: string
    type: string
    status?: string | null
    file_url: string
    rejection_reason?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type documentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_logsCreateInput = {
    id?: string
    recipient: string
    subject: string
    message_content: string
    status: string
    error?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type email_logsUncheckedCreateInput = {
    id?: string
    recipient: string
    subject: string
    message_content: string
    status: string
    error?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type email_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message_content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message_content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_logsCreateManyInput = {
    id?: string
    recipient: string
    subject: string
    message_content: string
    status: string
    error?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type email_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message_content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message_content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsCreateInput = {
    id: string
    name: string
    address: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type locationsUncheckedCreateInput = {
    id: string
    name: string
    address: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type locationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsCreateManyInput = {
    id: string
    name: string
    address: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type locationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateInput = {
    booking_id?: number | null
    user_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method?: string | null
    transaction_id?: string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsUncheckedCreateInput = {
    id?: number
    booking_id?: number | null
    user_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method?: string | null
    transaction_id?: string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsUpdateInput = {
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateManyInput = {
    id?: number
    booking_id?: number | null
    user_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method?: string | null
    transaction_id?: string | null
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsUpdateManyMutationInput = {
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profilesCreateInput = {
    id: string
    user_id?: string | null
    name?: string | null
    phone?: string | null
    avatar_url?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zip_code?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type profilesUncheckedCreateInput = {
    id: string
    user_id?: string | null
    name?: string | null
    phone?: string | null
    avatar_url?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zip_code?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type profilesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profilesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profilesCreateManyInput = {
    id: string
    user_id?: string | null
    name?: string | null
    phone?: string | null
    avatar_url?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    zip_code?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type profilesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profilesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsCreateInput = {
    user_id?: number | null
    vehicle_id?: number | null
    booking_id?: number | null
    rating: number
    comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type reviewsUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    vehicle_id?: number | null
    booking_id?: number | null
    rating: number
    comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type reviewsUpdateInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsCreateManyInput = {
    id?: number
    user_id?: number | null
    vehicle_id?: number | null
    booking_id?: number | null
    rating: number
    comment?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type reviewsUpdateManyMutationInput = {
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    vehicle_id?: NullableIntFieldUpdateOperationsInput | number | null
    booking_id?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type settingsCreateInput = {
    id: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type settingsUncheckedCreateInput = {
    id: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsCreateManyInput = {
    id: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sms_logsCreateInput = {
    id: string
    phone_number: string
    message: string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type sms_logsUncheckedCreateInput = {
    id: string
    phone_number: string
    message: string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type sms_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sms_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sms_logsCreateManyInput = {
    id: string
    phone_number: string
    message: string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type sms_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sms_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trip_initiationsCreateInput = {
    id?: string
    checklist_completed?: boolean
    customer_name: string
    customer_phone: string
    customer_email?: string | null
    customer_dl_number?: string | null
    customer_address?: string | null
    emergency_contact?: string | null
    emergency_name?: string | null
    customer_aadhaar_number?: string | null
    customer_dob?: string | null
    vehicle_number?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: boolean
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    bookings: bookingsCreateNestedOneWithoutTrip_initiationsInput
  }

  export type trip_initiationsUncheckedCreateInput = {
    id?: string
    booking_id: string
    checklist_completed?: boolean
    customer_name: string
    customer_phone: string
    customer_email?: string | null
    customer_dl_number?: string | null
    customer_address?: string | null
    emergency_contact?: string | null
    emergency_name?: string | null
    customer_aadhaar_number?: string | null
    customer_dob?: string | null
    vehicle_number?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: boolean
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type trip_initiationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklist_completed?: BoolFieldUpdateOperationsInput | boolean
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dl_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_aadhaar_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dob?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateOneRequiredWithoutTrip_initiationsNestedInput
  }

  export type trip_initiationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    checklist_completed?: BoolFieldUpdateOperationsInput | boolean
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dl_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_aadhaar_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dob?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trip_initiationsCreateManyInput = {
    id?: string
    booking_id: string
    checklist_completed?: boolean
    customer_name: string
    customer_phone: string
    customer_email?: string | null
    customer_dl_number?: string | null
    customer_address?: string | null
    emergency_contact?: string | null
    emergency_name?: string | null
    customer_aadhaar_number?: string | null
    customer_dob?: string | null
    vehicle_number?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: boolean
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type trip_initiationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklist_completed?: BoolFieldUpdateOperationsInput | boolean
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dl_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_aadhaar_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dob?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trip_initiationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    checklist_completed?: BoolFieldUpdateOperationsInput | boolean
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dl_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_aadhaar_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dob?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password_hash?: string | null
    phone?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    is_blocked?: boolean | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    DeliveryPartner?: DeliveryPartnerCreateNestedManyWithoutUsersInput
    bookings?: bookingsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    password_hash?: string | null
    phone?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    is_blocked?: boolean | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    DeliveryPartner?: DeliveryPartnerUncheckedCreateNestedManyWithoutUsersInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeliveryPartner?: DeliveryPartnerUpdateManyWithoutUsersNestedInput
    bookings?: bookingsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeliveryPartner?: DeliveryPartnerUncheckedUpdateManyWithoutUsersNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    password_hash?: string | null
    phone?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    is_blocked?: boolean | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type vehiclesCreateInput = {
    id?: string
    name: string
    type: string
    location: string
    quantity: number
    price_per_hour: number
    min_booking_hours: number
    is_available?: boolean | null
    images: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    price_15_days?: number | null
    price_30_days?: number | null
    price_7_days?: number | null
    delivery_price_15_days?: number | null
    delivery_price_30_days?: number | null
    delivery_price_7_days?: number | null
    vehicle_category?: string
    bookings?: bookingsCreateNestedManyWithoutVehiclesInput
  }

  export type vehiclesUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    location: string
    quantity: number
    price_per_hour: number
    min_booking_hours: number
    is_available?: boolean | null
    images: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    price_15_days?: number | null
    price_30_days?: number | null
    price_7_days?: number | null
    delivery_price_15_days?: number | null
    delivery_price_30_days?: number | null
    delivery_price_7_days?: number | null
    vehicle_category?: string
    bookings?: bookingsUncheckedCreateNestedManyWithoutVehiclesInput
  }

  export type vehiclesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price_per_hour?: FloatFieldUpdateOperationsInput | number
    min_booking_hours?: IntFieldUpdateOperationsInput | number
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    vehicle_category?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutVehiclesNestedInput
  }

  export type vehiclesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price_per_hour?: FloatFieldUpdateOperationsInput | number
    min_booking_hours?: IntFieldUpdateOperationsInput | number
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    vehicle_category?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUncheckedUpdateManyWithoutVehiclesNestedInput
  }

  export type vehiclesCreateManyInput = {
    id?: string
    name: string
    type: string
    location: string
    quantity: number
    price_per_hour: number
    min_booking_hours: number
    is_available?: boolean | null
    images: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    price_15_days?: number | null
    price_30_days?: number | null
    price_7_days?: number | null
    delivery_price_15_days?: number | null
    delivery_price_30_days?: number | null
    delivery_price_7_days?: number | null
    vehicle_category?: string
  }

  export type vehiclesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price_per_hour?: FloatFieldUpdateOperationsInput | number
    min_booking_hours?: IntFieldUpdateOperationsInput | number
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    vehicle_category?: StringFieldUpdateOperationsInput | string
  }

  export type vehiclesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price_per_hour?: FloatFieldUpdateOperationsInput | number
    min_booking_hours?: IntFieldUpdateOperationsInput | number
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    vehicle_category?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdminNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    recipient?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    error?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BookingsScalarRelationFilter = {
    is?: bookingsWhereInput
    isNot?: bookingsWhereInput
  }

  export type DeliveryPartnerScalarRelationFilter = {
    is?: DeliveryPartnerWhereInput
    isNot?: DeliveryPartnerWhereInput
  }

  export type DeliveryTrackingListRelationFilter = {
    every?: DeliveryTrackingWhereInput
    some?: DeliveryTrackingWhereInput
    none?: DeliveryTrackingWhereInput
  }

  export type DeliveryTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryBookingCountOrderByAggregateInput = {
    id?: SortOrder
    delivery_partner_id?: SortOrder
    booking_id?: SortOrder
    pickup_location?: SortOrder
    dropoff_location?: SortOrder
    status?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    actual_duration?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryBookingAvgOrderByAggregateInput = {
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    actual_duration?: SortOrder
    price?: SortOrder
  }

  export type DeliveryBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    delivery_partner_id?: SortOrder
    booking_id?: SortOrder
    status?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    actual_duration?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryBookingMinOrderByAggregateInput = {
    id?: SortOrder
    delivery_partner_id?: SortOrder
    booking_id?: SortOrder
    status?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    actual_duration?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryBookingSumOrderByAggregateInput = {
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    actual_duration?: SortOrder
    price?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DeliveryBookingListRelationFilter = {
    every?: DeliveryBookingWhereInput
    some?: DeliveryBookingWhereInput
    none?: DeliveryBookingWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type DeliveryBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_type?: SortOrder
    vehicle_number?: SortOrder
    license_number?: SortOrder
    is_available?: SortOrder
    current_location?: SortOrder
    rating?: SortOrder
    total_trips?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryPartnerAvgOrderByAggregateInput = {
    rating?: SortOrder
    total_trips?: SortOrder
  }

  export type DeliveryPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_type?: SortOrder
    vehicle_number?: SortOrder
    license_number?: SortOrder
    is_available?: SortOrder
    rating?: SortOrder
    total_trips?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_type?: SortOrder
    vehicle_number?: SortOrder
    license_number?: SortOrder
    is_available?: SortOrder
    rating?: SortOrder
    total_trips?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryPartnerSumOrderByAggregateInput = {
    rating?: SortOrder
    total_trips?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DeliveryBookingScalarRelationFilter = {
    is?: DeliveryBookingWhereInput
    isNot?: DeliveryBookingWhereInput
  }

  export type DeliveryTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    delivery_booking_id?: SortOrder
    location?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type DeliveryTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    delivery_booking_id?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type DeliveryTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    delivery_booking_id?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type booking_historyCountOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type booking_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type booking_historyMinOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    action?: SortOrder
    details?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DeliveryBookingNullableScalarRelationFilter = {
    is?: DeliveryBookingWhereInput | null
    isNot?: DeliveryBookingWhereInput | null
  }

  export type Booking_historyListRelationFilter = {
    every?: booking_historyWhereInput
    some?: booking_historyWhereInput
    none?: booking_historyWhereInput
  }

  export type VehiclesScalarRelationFilter = {
    is?: vehiclesWhereInput
    isNot?: vehiclesWhereInput
  }

  export type Trip_initiationsNullableScalarRelationFilter = {
    is?: trip_initiationsWhereInput | null
    isNot?: trip_initiationsWhereInput | null
  }

  export type booking_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bookingsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_hours?: SortOrder
    total_price?: SortOrder
    status?: SortOrder
    payment_status?: SortOrder
    payment_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    pickup_location?: SortOrder
    dropoff_location?: SortOrder
    booking_id?: SortOrder
    payment_intent_id?: SortOrder
  }

  export type bookingsAvgOrderByAggregateInput = {
    total_hours?: SortOrder
    total_price?: SortOrder
  }

  export type bookingsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_hours?: SortOrder
    total_price?: SortOrder
    status?: SortOrder
    payment_status?: SortOrder
    payment_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    pickup_location?: SortOrder
    dropoff_location?: SortOrder
    booking_id?: SortOrder
    payment_intent_id?: SortOrder
  }

  export type bookingsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    total_hours?: SortOrder
    total_price?: SortOrder
    status?: SortOrder
    payment_status?: SortOrder
    payment_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    pickup_location?: SortOrder
    dropoff_location?: SortOrder
    booking_id?: SortOrder
    payment_intent_id?: SortOrder
  }

  export type bookingsSumOrderByAggregateInput = {
    total_hours?: SortOrder
    total_price?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type couponsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    min_booking_amount?: SortOrder
    max_discount_amount?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    usage_limit?: SortOrder
    times_used?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type couponsAvgOrderByAggregateInput = {
    discount_value?: SortOrder
    min_booking_amount?: SortOrder
    max_discount_amount?: SortOrder
    usage_limit?: SortOrder
    times_used?: SortOrder
  }

  export type couponsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    min_booking_amount?: SortOrder
    max_discount_amount?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    usage_limit?: SortOrder
    times_used?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type couponsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    min_booking_amount?: SortOrder
    max_discount_amount?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    usage_limit?: SortOrder
    times_used?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type couponsSumOrderByAggregateInput = {
    discount_value?: SortOrder
    min_booking_amount?: SortOrder
    max_discount_amount?: SortOrder
    usage_limit?: SortOrder
    times_used?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type document_submissionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    document_type?: SortOrder
    document_url?: SortOrder
    status?: SortOrder
    admin_comments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type document_submissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type document_submissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    document_type?: SortOrder
    document_url?: SortOrder
    status?: SortOrder
    admin_comments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type document_submissionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    document_type?: SortOrder
    document_url?: SortOrder
    status?: SortOrder
    admin_comments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type document_submissionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type documentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    file_url?: SortOrder
    rejection_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    file_url?: SortOrder
    rejection_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type documentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    file_url?: SortOrder
    rejection_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type email_logsCountOrderByAggregateInput = {
    id?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message_content?: SortOrder
    status?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type email_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message_content?: SortOrder
    status?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type email_logsMinOrderByAggregateInput = {
    id?: SortOrder
    recipient?: SortOrder
    subject?: SortOrder
    message_content?: SortOrder
    status?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type profilesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    avatar_url?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zip_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type profilesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    avatar_url?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zip_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type profilesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    avatar_url?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zip_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type reviewsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type reviewsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
  }

  export type reviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type reviewsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type reviewsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    vehicle_id?: SortOrder
    booking_id?: SortOrder
    rating?: SortOrder
  }

  export type settingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sms_logsCountOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sms_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type sms_logsMinOrderByAggregateInput = {
    id?: SortOrder
    phone_number?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type trip_initiationsCountOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    checklist_completed?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_email?: SortOrder
    customer_dl_number?: SortOrder
    customer_address?: SortOrder
    emergency_contact?: SortOrder
    emergency_name?: SortOrder
    customer_aadhaar_number?: SortOrder
    customer_dob?: SortOrder
    vehicle_number?: SortOrder
    documents?: SortOrder
    terms_accepted?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type trip_initiationsMaxOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    checklist_completed?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_email?: SortOrder
    customer_dl_number?: SortOrder
    customer_address?: SortOrder
    emergency_contact?: SortOrder
    emergency_name?: SortOrder
    customer_aadhaar_number?: SortOrder
    customer_dob?: SortOrder
    vehicle_number?: SortOrder
    terms_accepted?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type trip_initiationsMinOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    checklist_completed?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_email?: SortOrder
    customer_dl_number?: SortOrder
    customer_address?: SortOrder
    emergency_contact?: SortOrder
    emergency_name?: SortOrder
    customer_aadhaar_number?: SortOrder
    customer_dob?: SortOrder
    vehicle_number?: SortOrder
    terms_accepted?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DeliveryPartnerListRelationFilter = {
    every?: DeliveryPartnerWhereInput
    some?: DeliveryPartnerWhereInput
    none?: DeliveryPartnerWhereInput
  }

  export type BookingsListRelationFilter = {
    every?: bookingsWhereInput
    some?: bookingsWhereInput
    none?: bookingsWhereInput
  }

  export type DeliveryPartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bookingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    reset_token?: SortOrder
    reset_token_expiry?: SortOrder
    is_blocked?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    reset_token?: SortOrder
    reset_token_expiry?: SortOrder
    is_blocked?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    reset_token?: SortOrder
    reset_token_expiry?: SortOrder
    is_blocked?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type vehiclesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    price_per_hour?: SortOrder
    min_booking_hours?: SortOrder
    is_available?: SortOrder
    images?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price_15_days?: SortOrder
    price_30_days?: SortOrder
    price_7_days?: SortOrder
    delivery_price_15_days?: SortOrder
    delivery_price_30_days?: SortOrder
    delivery_price_7_days?: SortOrder
    vehicle_category?: SortOrder
  }

  export type vehiclesAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price_per_hour?: SortOrder
    min_booking_hours?: SortOrder
    price_15_days?: SortOrder
    price_30_days?: SortOrder
    price_7_days?: SortOrder
    delivery_price_15_days?: SortOrder
    delivery_price_30_days?: SortOrder
    delivery_price_7_days?: SortOrder
  }

  export type vehiclesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    price_per_hour?: SortOrder
    min_booking_hours?: SortOrder
    is_available?: SortOrder
    images?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price_15_days?: SortOrder
    price_30_days?: SortOrder
    price_7_days?: SortOrder
    delivery_price_15_days?: SortOrder
    delivery_price_30_days?: SortOrder
    delivery_price_7_days?: SortOrder
    vehicle_category?: SortOrder
  }

  export type vehiclesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    quantity?: SortOrder
    price_per_hour?: SortOrder
    min_booking_hours?: SortOrder
    is_available?: SortOrder
    images?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    price_15_days?: SortOrder
    price_30_days?: SortOrder
    price_7_days?: SortOrder
    delivery_price_15_days?: SortOrder
    delivery_price_30_days?: SortOrder
    delivery_price_7_days?: SortOrder
    vehicle_category?: SortOrder
  }

  export type vehiclesSumOrderByAggregateInput = {
    quantity?: SortOrder
    price_per_hour?: SortOrder
    min_booking_hours?: SortOrder
    price_15_days?: SortOrder
    price_30_days?: SortOrder
    price_7_days?: SortOrder
    delivery_price_15_days?: SortOrder
    delivery_price_30_days?: SortOrder
    delivery_price_7_days?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type bookingsCreateNestedOneWithoutDeliveryBookingInput = {
    create?: XOR<bookingsCreateWithoutDeliveryBookingInput, bookingsUncheckedCreateWithoutDeliveryBookingInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutDeliveryBookingInput
    connect?: bookingsWhereUniqueInput
  }

  export type DeliveryPartnerCreateNestedOneWithoutDeliveryBookingInput = {
    create?: XOR<DeliveryPartnerCreateWithoutDeliveryBookingInput, DeliveryPartnerUncheckedCreateWithoutDeliveryBookingInput>
    connectOrCreate?: DeliveryPartnerCreateOrConnectWithoutDeliveryBookingInput
    connect?: DeliveryPartnerWhereUniqueInput
  }

  export type DeliveryTrackingCreateNestedManyWithoutDeliveryBookingInput = {
    create?: XOR<DeliveryTrackingCreateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput> | DeliveryTrackingCreateWithoutDeliveryBookingInput[] | DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput[]
    connectOrCreate?: DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput | DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput[]
    createMany?: DeliveryTrackingCreateManyDeliveryBookingInputEnvelope
    connect?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
  }

  export type DeliveryTrackingUncheckedCreateNestedManyWithoutDeliveryBookingInput = {
    create?: XOR<DeliveryTrackingCreateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput> | DeliveryTrackingCreateWithoutDeliveryBookingInput[] | DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput[]
    connectOrCreate?: DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput | DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput[]
    createMany?: DeliveryTrackingCreateManyDeliveryBookingInputEnvelope
    connect?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type bookingsUpdateOneRequiredWithoutDeliveryBookingNestedInput = {
    create?: XOR<bookingsCreateWithoutDeliveryBookingInput, bookingsUncheckedCreateWithoutDeliveryBookingInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutDeliveryBookingInput
    upsert?: bookingsUpsertWithoutDeliveryBookingInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutDeliveryBookingInput, bookingsUpdateWithoutDeliveryBookingInput>, bookingsUncheckedUpdateWithoutDeliveryBookingInput>
  }

  export type DeliveryPartnerUpdateOneRequiredWithoutDeliveryBookingNestedInput = {
    create?: XOR<DeliveryPartnerCreateWithoutDeliveryBookingInput, DeliveryPartnerUncheckedCreateWithoutDeliveryBookingInput>
    connectOrCreate?: DeliveryPartnerCreateOrConnectWithoutDeliveryBookingInput
    upsert?: DeliveryPartnerUpsertWithoutDeliveryBookingInput
    connect?: DeliveryPartnerWhereUniqueInput
    update?: XOR<XOR<DeliveryPartnerUpdateToOneWithWhereWithoutDeliveryBookingInput, DeliveryPartnerUpdateWithoutDeliveryBookingInput>, DeliveryPartnerUncheckedUpdateWithoutDeliveryBookingInput>
  }

  export type DeliveryTrackingUpdateManyWithoutDeliveryBookingNestedInput = {
    create?: XOR<DeliveryTrackingCreateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput> | DeliveryTrackingCreateWithoutDeliveryBookingInput[] | DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput[]
    connectOrCreate?: DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput | DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput[]
    upsert?: DeliveryTrackingUpsertWithWhereUniqueWithoutDeliveryBookingInput | DeliveryTrackingUpsertWithWhereUniqueWithoutDeliveryBookingInput[]
    createMany?: DeliveryTrackingCreateManyDeliveryBookingInputEnvelope
    set?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    disconnect?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    delete?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    connect?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    update?: DeliveryTrackingUpdateWithWhereUniqueWithoutDeliveryBookingInput | DeliveryTrackingUpdateWithWhereUniqueWithoutDeliveryBookingInput[]
    updateMany?: DeliveryTrackingUpdateManyWithWhereWithoutDeliveryBookingInput | DeliveryTrackingUpdateManyWithWhereWithoutDeliveryBookingInput[]
    deleteMany?: DeliveryTrackingScalarWhereInput | DeliveryTrackingScalarWhereInput[]
  }

  export type DeliveryTrackingUncheckedUpdateManyWithoutDeliveryBookingNestedInput = {
    create?: XOR<DeliveryTrackingCreateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput> | DeliveryTrackingCreateWithoutDeliveryBookingInput[] | DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput[]
    connectOrCreate?: DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput | DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput[]
    upsert?: DeliveryTrackingUpsertWithWhereUniqueWithoutDeliveryBookingInput | DeliveryTrackingUpsertWithWhereUniqueWithoutDeliveryBookingInput[]
    createMany?: DeliveryTrackingCreateManyDeliveryBookingInputEnvelope
    set?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    disconnect?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    delete?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    connect?: DeliveryTrackingWhereUniqueInput | DeliveryTrackingWhereUniqueInput[]
    update?: DeliveryTrackingUpdateWithWhereUniqueWithoutDeliveryBookingInput | DeliveryTrackingUpdateWithWhereUniqueWithoutDeliveryBookingInput[]
    updateMany?: DeliveryTrackingUpdateManyWithWhereWithoutDeliveryBookingInput | DeliveryTrackingUpdateManyWithWhereWithoutDeliveryBookingInput[]
    deleteMany?: DeliveryTrackingScalarWhereInput | DeliveryTrackingScalarWhereInput[]
  }

  export type DeliveryBookingCreateNestedManyWithoutDeliveryPartnerInput = {
    create?: XOR<DeliveryBookingCreateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput> | DeliveryBookingCreateWithoutDeliveryPartnerInput[] | DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput[]
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput | DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput[]
    createMany?: DeliveryBookingCreateManyDeliveryPartnerInputEnvelope
    connect?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutDeliveryPartnerInput = {
    create?: XOR<usersCreateWithoutDeliveryPartnerInput, usersUncheckedCreateWithoutDeliveryPartnerInput>
    connectOrCreate?: usersCreateOrConnectWithoutDeliveryPartnerInput
    connect?: usersWhereUniqueInput
  }

  export type DeliveryBookingUncheckedCreateNestedManyWithoutDeliveryPartnerInput = {
    create?: XOR<DeliveryBookingCreateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput> | DeliveryBookingCreateWithoutDeliveryPartnerInput[] | DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput[]
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput | DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput[]
    createMany?: DeliveryBookingCreateManyDeliveryPartnerInputEnvelope
    connect?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DeliveryBookingUpdateManyWithoutDeliveryPartnerNestedInput = {
    create?: XOR<DeliveryBookingCreateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput> | DeliveryBookingCreateWithoutDeliveryPartnerInput[] | DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput[]
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput | DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput[]
    upsert?: DeliveryBookingUpsertWithWhereUniqueWithoutDeliveryPartnerInput | DeliveryBookingUpsertWithWhereUniqueWithoutDeliveryPartnerInput[]
    createMany?: DeliveryBookingCreateManyDeliveryPartnerInputEnvelope
    set?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    disconnect?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    delete?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    connect?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    update?: DeliveryBookingUpdateWithWhereUniqueWithoutDeliveryPartnerInput | DeliveryBookingUpdateWithWhereUniqueWithoutDeliveryPartnerInput[]
    updateMany?: DeliveryBookingUpdateManyWithWhereWithoutDeliveryPartnerInput | DeliveryBookingUpdateManyWithWhereWithoutDeliveryPartnerInput[]
    deleteMany?: DeliveryBookingScalarWhereInput | DeliveryBookingScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutDeliveryPartnerNestedInput = {
    create?: XOR<usersCreateWithoutDeliveryPartnerInput, usersUncheckedCreateWithoutDeliveryPartnerInput>
    connectOrCreate?: usersCreateOrConnectWithoutDeliveryPartnerInput
    upsert?: usersUpsertWithoutDeliveryPartnerInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDeliveryPartnerInput, usersUpdateWithoutDeliveryPartnerInput>, usersUncheckedUpdateWithoutDeliveryPartnerInput>
  }

  export type DeliveryBookingUncheckedUpdateManyWithoutDeliveryPartnerNestedInput = {
    create?: XOR<DeliveryBookingCreateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput> | DeliveryBookingCreateWithoutDeliveryPartnerInput[] | DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput[]
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput | DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput[]
    upsert?: DeliveryBookingUpsertWithWhereUniqueWithoutDeliveryPartnerInput | DeliveryBookingUpsertWithWhereUniqueWithoutDeliveryPartnerInput[]
    createMany?: DeliveryBookingCreateManyDeliveryPartnerInputEnvelope
    set?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    disconnect?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    delete?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    connect?: DeliveryBookingWhereUniqueInput | DeliveryBookingWhereUniqueInput[]
    update?: DeliveryBookingUpdateWithWhereUniqueWithoutDeliveryPartnerInput | DeliveryBookingUpdateWithWhereUniqueWithoutDeliveryPartnerInput[]
    updateMany?: DeliveryBookingUpdateManyWithWhereWithoutDeliveryPartnerInput | DeliveryBookingUpdateManyWithWhereWithoutDeliveryPartnerInput[]
    deleteMany?: DeliveryBookingScalarWhereInput | DeliveryBookingScalarWhereInput[]
  }

  export type DeliveryBookingCreateNestedOneWithoutDeliveryTrackingInput = {
    create?: XOR<DeliveryBookingCreateWithoutDeliveryTrackingInput, DeliveryBookingUncheckedCreateWithoutDeliveryTrackingInput>
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutDeliveryTrackingInput
    connect?: DeliveryBookingWhereUniqueInput
  }

  export type DeliveryBookingUpdateOneRequiredWithoutDeliveryTrackingNestedInput = {
    create?: XOR<DeliveryBookingCreateWithoutDeliveryTrackingInput, DeliveryBookingUncheckedCreateWithoutDeliveryTrackingInput>
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutDeliveryTrackingInput
    upsert?: DeliveryBookingUpsertWithoutDeliveryTrackingInput
    connect?: DeliveryBookingWhereUniqueInput
    update?: XOR<XOR<DeliveryBookingUpdateToOneWithWhereWithoutDeliveryTrackingInput, DeliveryBookingUpdateWithoutDeliveryTrackingInput>, DeliveryBookingUncheckedUpdateWithoutDeliveryTrackingInput>
  }

  export type bookingsCreateNestedOneWithoutBooking_historyInput = {
    create?: XOR<bookingsCreateWithoutBooking_historyInput, bookingsUncheckedCreateWithoutBooking_historyInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutBooking_historyInput
    connect?: bookingsWhereUniqueInput
  }

  export type bookingsUpdateOneRequiredWithoutBooking_historyNestedInput = {
    create?: XOR<bookingsCreateWithoutBooking_historyInput, bookingsUncheckedCreateWithoutBooking_historyInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutBooking_historyInput
    upsert?: bookingsUpsertWithoutBooking_historyInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutBooking_historyInput, bookingsUpdateWithoutBooking_historyInput>, bookingsUncheckedUpdateWithoutBooking_historyInput>
  }

  export type DeliveryBookingCreateNestedOneWithoutBookingsInput = {
    create?: XOR<DeliveryBookingCreateWithoutBookingsInput, DeliveryBookingUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutBookingsInput
    connect?: DeliveryBookingWhereUniqueInput
  }

  export type booking_historyCreateNestedManyWithoutBookingsInput = {
    create?: XOR<booking_historyCreateWithoutBookingsInput, booking_historyUncheckedCreateWithoutBookingsInput> | booking_historyCreateWithoutBookingsInput[] | booking_historyUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: booking_historyCreateOrConnectWithoutBookingsInput | booking_historyCreateOrConnectWithoutBookingsInput[]
    createMany?: booking_historyCreateManyBookingsInputEnvelope
    connect?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutBookingsInput = {
    create?: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBookingsInput
    connect?: usersWhereUniqueInput
  }

  export type vehiclesCreateNestedOneWithoutBookingsInput = {
    create?: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: vehiclesCreateOrConnectWithoutBookingsInput
    connect?: vehiclesWhereUniqueInput
  }

  export type trip_initiationsCreateNestedOneWithoutBookingsInput = {
    create?: XOR<trip_initiationsCreateWithoutBookingsInput, trip_initiationsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: trip_initiationsCreateOrConnectWithoutBookingsInput
    connect?: trip_initiationsWhereUniqueInput
  }

  export type DeliveryBookingUncheckedCreateNestedOneWithoutBookingsInput = {
    create?: XOR<DeliveryBookingCreateWithoutBookingsInput, DeliveryBookingUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutBookingsInput
    connect?: DeliveryBookingWhereUniqueInput
  }

  export type booking_historyUncheckedCreateNestedManyWithoutBookingsInput = {
    create?: XOR<booking_historyCreateWithoutBookingsInput, booking_historyUncheckedCreateWithoutBookingsInput> | booking_historyCreateWithoutBookingsInput[] | booking_historyUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: booking_historyCreateOrConnectWithoutBookingsInput | booking_historyCreateOrConnectWithoutBookingsInput[]
    createMany?: booking_historyCreateManyBookingsInputEnvelope
    connect?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
  }

  export type trip_initiationsUncheckedCreateNestedOneWithoutBookingsInput = {
    create?: XOR<trip_initiationsCreateWithoutBookingsInput, trip_initiationsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: trip_initiationsCreateOrConnectWithoutBookingsInput
    connect?: trip_initiationsWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DeliveryBookingUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<DeliveryBookingCreateWithoutBookingsInput, DeliveryBookingUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutBookingsInput
    upsert?: DeliveryBookingUpsertWithoutBookingsInput
    disconnect?: DeliveryBookingWhereInput | boolean
    delete?: DeliveryBookingWhereInput | boolean
    connect?: DeliveryBookingWhereUniqueInput
    update?: XOR<XOR<DeliveryBookingUpdateToOneWithWhereWithoutBookingsInput, DeliveryBookingUpdateWithoutBookingsInput>, DeliveryBookingUncheckedUpdateWithoutBookingsInput>
  }

  export type booking_historyUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<booking_historyCreateWithoutBookingsInput, booking_historyUncheckedCreateWithoutBookingsInput> | booking_historyCreateWithoutBookingsInput[] | booking_historyUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: booking_historyCreateOrConnectWithoutBookingsInput | booking_historyCreateOrConnectWithoutBookingsInput[]
    upsert?: booking_historyUpsertWithWhereUniqueWithoutBookingsInput | booking_historyUpsertWithWhereUniqueWithoutBookingsInput[]
    createMany?: booking_historyCreateManyBookingsInputEnvelope
    set?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    disconnect?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    delete?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    connect?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    update?: booking_historyUpdateWithWhereUniqueWithoutBookingsInput | booking_historyUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: booking_historyUpdateManyWithWhereWithoutBookingsInput | booking_historyUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: booking_historyScalarWhereInput | booking_historyScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBookingsInput
    upsert?: usersUpsertWithoutBookingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBookingsInput, usersUpdateWithoutBookingsInput>, usersUncheckedUpdateWithoutBookingsInput>
  }

  export type vehiclesUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: vehiclesCreateOrConnectWithoutBookingsInput
    upsert?: vehiclesUpsertWithoutBookingsInput
    connect?: vehiclesWhereUniqueInput
    update?: XOR<XOR<vehiclesUpdateToOneWithWhereWithoutBookingsInput, vehiclesUpdateWithoutBookingsInput>, vehiclesUncheckedUpdateWithoutBookingsInput>
  }

  export type trip_initiationsUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<trip_initiationsCreateWithoutBookingsInput, trip_initiationsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: trip_initiationsCreateOrConnectWithoutBookingsInput
    upsert?: trip_initiationsUpsertWithoutBookingsInput
    disconnect?: trip_initiationsWhereInput | boolean
    delete?: trip_initiationsWhereInput | boolean
    connect?: trip_initiationsWhereUniqueInput
    update?: XOR<XOR<trip_initiationsUpdateToOneWithWhereWithoutBookingsInput, trip_initiationsUpdateWithoutBookingsInput>, trip_initiationsUncheckedUpdateWithoutBookingsInput>
  }

  export type DeliveryBookingUncheckedUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<DeliveryBookingCreateWithoutBookingsInput, DeliveryBookingUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DeliveryBookingCreateOrConnectWithoutBookingsInput
    upsert?: DeliveryBookingUpsertWithoutBookingsInput
    disconnect?: DeliveryBookingWhereInput | boolean
    delete?: DeliveryBookingWhereInput | boolean
    connect?: DeliveryBookingWhereUniqueInput
    update?: XOR<XOR<DeliveryBookingUpdateToOneWithWhereWithoutBookingsInput, DeliveryBookingUpdateWithoutBookingsInput>, DeliveryBookingUncheckedUpdateWithoutBookingsInput>
  }

  export type booking_historyUncheckedUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<booking_historyCreateWithoutBookingsInput, booking_historyUncheckedCreateWithoutBookingsInput> | booking_historyCreateWithoutBookingsInput[] | booking_historyUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: booking_historyCreateOrConnectWithoutBookingsInput | booking_historyCreateOrConnectWithoutBookingsInput[]
    upsert?: booking_historyUpsertWithWhereUniqueWithoutBookingsInput | booking_historyUpsertWithWhereUniqueWithoutBookingsInput[]
    createMany?: booking_historyCreateManyBookingsInputEnvelope
    set?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    disconnect?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    delete?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    connect?: booking_historyWhereUniqueInput | booking_historyWhereUniqueInput[]
    update?: booking_historyUpdateWithWhereUniqueWithoutBookingsInput | booking_historyUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: booking_historyUpdateManyWithWhereWithoutBookingsInput | booking_historyUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: booking_historyScalarWhereInput | booking_historyScalarWhereInput[]
  }

  export type trip_initiationsUncheckedUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<trip_initiationsCreateWithoutBookingsInput, trip_initiationsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: trip_initiationsCreateOrConnectWithoutBookingsInput
    upsert?: trip_initiationsUpsertWithoutBookingsInput
    disconnect?: trip_initiationsWhereInput | boolean
    delete?: trip_initiationsWhereInput | boolean
    connect?: trip_initiationsWhereUniqueInput
    update?: XOR<XOR<trip_initiationsUpdateToOneWithWhereWithoutBookingsInput, trip_initiationsUpdateWithoutBookingsInput>, trip_initiationsUncheckedUpdateWithoutBookingsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type bookingsCreateNestedOneWithoutTrip_initiationsInput = {
    create?: XOR<bookingsCreateWithoutTrip_initiationsInput, bookingsUncheckedCreateWithoutTrip_initiationsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutTrip_initiationsInput
    connect?: bookingsWhereUniqueInput
  }

  export type bookingsUpdateOneRequiredWithoutTrip_initiationsNestedInput = {
    create?: XOR<bookingsCreateWithoutTrip_initiationsInput, bookingsUncheckedCreateWithoutTrip_initiationsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutTrip_initiationsInput
    upsert?: bookingsUpsertWithoutTrip_initiationsInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutTrip_initiationsInput, bookingsUpdateWithoutTrip_initiationsInput>, bookingsUncheckedUpdateWithoutTrip_initiationsInput>
  }

  export type DeliveryPartnerCreateNestedManyWithoutUsersInput = {
    create?: XOR<DeliveryPartnerCreateWithoutUsersInput, DeliveryPartnerUncheckedCreateWithoutUsersInput> | DeliveryPartnerCreateWithoutUsersInput[] | DeliveryPartnerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DeliveryPartnerCreateOrConnectWithoutUsersInput | DeliveryPartnerCreateOrConnectWithoutUsersInput[]
    createMany?: DeliveryPartnerCreateManyUsersInputEnvelope
    connect?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
  }

  export type bookingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<bookingsCreateWithoutUsersInput, bookingsUncheckedCreateWithoutUsersInput> | bookingsCreateWithoutUsersInput[] | bookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUsersInput | bookingsCreateOrConnectWithoutUsersInput[]
    createMany?: bookingsCreateManyUsersInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type DeliveryPartnerUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<DeliveryPartnerCreateWithoutUsersInput, DeliveryPartnerUncheckedCreateWithoutUsersInput> | DeliveryPartnerCreateWithoutUsersInput[] | DeliveryPartnerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DeliveryPartnerCreateOrConnectWithoutUsersInput | DeliveryPartnerCreateOrConnectWithoutUsersInput[]
    createMany?: DeliveryPartnerCreateManyUsersInputEnvelope
    connect?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<bookingsCreateWithoutUsersInput, bookingsUncheckedCreateWithoutUsersInput> | bookingsCreateWithoutUsersInput[] | bookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUsersInput | bookingsCreateOrConnectWithoutUsersInput[]
    createMany?: bookingsCreateManyUsersInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type DeliveryPartnerUpdateManyWithoutUsersNestedInput = {
    create?: XOR<DeliveryPartnerCreateWithoutUsersInput, DeliveryPartnerUncheckedCreateWithoutUsersInput> | DeliveryPartnerCreateWithoutUsersInput[] | DeliveryPartnerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DeliveryPartnerCreateOrConnectWithoutUsersInput | DeliveryPartnerCreateOrConnectWithoutUsersInput[]
    upsert?: DeliveryPartnerUpsertWithWhereUniqueWithoutUsersInput | DeliveryPartnerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: DeliveryPartnerCreateManyUsersInputEnvelope
    set?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    disconnect?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    delete?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    connect?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    update?: DeliveryPartnerUpdateWithWhereUniqueWithoutUsersInput | DeliveryPartnerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: DeliveryPartnerUpdateManyWithWhereWithoutUsersInput | DeliveryPartnerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: DeliveryPartnerScalarWhereInput | DeliveryPartnerScalarWhereInput[]
  }

  export type bookingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bookingsCreateWithoutUsersInput, bookingsUncheckedCreateWithoutUsersInput> | bookingsCreateWithoutUsersInput[] | bookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUsersInput | bookingsCreateOrConnectWithoutUsersInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutUsersInput | bookingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bookingsCreateManyUsersInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutUsersInput | bookingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutUsersInput | bookingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type DeliveryPartnerUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<DeliveryPartnerCreateWithoutUsersInput, DeliveryPartnerUncheckedCreateWithoutUsersInput> | DeliveryPartnerCreateWithoutUsersInput[] | DeliveryPartnerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DeliveryPartnerCreateOrConnectWithoutUsersInput | DeliveryPartnerCreateOrConnectWithoutUsersInput[]
    upsert?: DeliveryPartnerUpsertWithWhereUniqueWithoutUsersInput | DeliveryPartnerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: DeliveryPartnerCreateManyUsersInputEnvelope
    set?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    disconnect?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    delete?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    connect?: DeliveryPartnerWhereUniqueInput | DeliveryPartnerWhereUniqueInput[]
    update?: DeliveryPartnerUpdateWithWhereUniqueWithoutUsersInput | DeliveryPartnerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: DeliveryPartnerUpdateManyWithWhereWithoutUsersInput | DeliveryPartnerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: DeliveryPartnerScalarWhereInput | DeliveryPartnerScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bookingsCreateWithoutUsersInput, bookingsUncheckedCreateWithoutUsersInput> | bookingsCreateWithoutUsersInput[] | bookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUsersInput | bookingsCreateOrConnectWithoutUsersInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutUsersInput | bookingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bookingsCreateManyUsersInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutUsersInput | bookingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutUsersInput | bookingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type bookingsCreateNestedManyWithoutVehiclesInput = {
    create?: XOR<bookingsCreateWithoutVehiclesInput, bookingsUncheckedCreateWithoutVehiclesInput> | bookingsCreateWithoutVehiclesInput[] | bookingsUncheckedCreateWithoutVehiclesInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehiclesInput | bookingsCreateOrConnectWithoutVehiclesInput[]
    createMany?: bookingsCreateManyVehiclesInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutVehiclesInput = {
    create?: XOR<bookingsCreateWithoutVehiclesInput, bookingsUncheckedCreateWithoutVehiclesInput> | bookingsCreateWithoutVehiclesInput[] | bookingsUncheckedCreateWithoutVehiclesInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehiclesInput | bookingsCreateOrConnectWithoutVehiclesInput[]
    createMany?: bookingsCreateManyVehiclesInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type bookingsUpdateManyWithoutVehiclesNestedInput = {
    create?: XOR<bookingsCreateWithoutVehiclesInput, bookingsUncheckedCreateWithoutVehiclesInput> | bookingsCreateWithoutVehiclesInput[] | bookingsUncheckedCreateWithoutVehiclesInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehiclesInput | bookingsCreateOrConnectWithoutVehiclesInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutVehiclesInput | bookingsUpsertWithWhereUniqueWithoutVehiclesInput[]
    createMany?: bookingsCreateManyVehiclesInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutVehiclesInput | bookingsUpdateWithWhereUniqueWithoutVehiclesInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutVehiclesInput | bookingsUpdateManyWithWhereWithoutVehiclesInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutVehiclesNestedInput = {
    create?: XOR<bookingsCreateWithoutVehiclesInput, bookingsUncheckedCreateWithoutVehiclesInput> | bookingsCreateWithoutVehiclesInput[] | bookingsUncheckedCreateWithoutVehiclesInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehiclesInput | bookingsCreateOrConnectWithoutVehiclesInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutVehiclesInput | bookingsUpsertWithWhereUniqueWithoutVehiclesInput[]
    createMany?: bookingsCreateManyVehiclesInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutVehiclesInput | bookingsUpdateWithWhereUniqueWithoutVehiclesInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutVehiclesInput | bookingsUpdateManyWithWhereWithoutVehiclesInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type bookingsCreateWithoutDeliveryBookingInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    booking_history?: booking_historyCreateNestedManyWithoutBookingsInput
    users: usersCreateNestedOneWithoutBookingsInput
    vehicles: vehiclesCreateNestedOneWithoutBookingsInput
    trip_initiations?: trip_initiationsCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutDeliveryBookingInput = {
    id?: string
    user_id: string
    vehicle_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    booking_history?: booking_historyUncheckedCreateNestedManyWithoutBookingsInput
    trip_initiations?: trip_initiationsUncheckedCreateNestedOneWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutDeliveryBookingInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutDeliveryBookingInput, bookingsUncheckedCreateWithoutDeliveryBookingInput>
  }

  export type DeliveryPartnerCreateWithoutDeliveryBookingInput = {
    id?: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutDeliveryPartnerInput
  }

  export type DeliveryPartnerUncheckedCreateWithoutDeliveryBookingInput = {
    id?: string
    user_id: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryPartnerCreateOrConnectWithoutDeliveryBookingInput = {
    where: DeliveryPartnerWhereUniqueInput
    create: XOR<DeliveryPartnerCreateWithoutDeliveryBookingInput, DeliveryPartnerUncheckedCreateWithoutDeliveryBookingInput>
  }

  export type DeliveryTrackingCreateWithoutDeliveryBookingInput = {
    id?: string
    location: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status: string
    notes?: string | null
  }

  export type DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput = {
    id?: string
    location: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status: string
    notes?: string | null
  }

  export type DeliveryTrackingCreateOrConnectWithoutDeliveryBookingInput = {
    where: DeliveryTrackingWhereUniqueInput
    create: XOR<DeliveryTrackingCreateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput>
  }

  export type DeliveryTrackingCreateManyDeliveryBookingInputEnvelope = {
    data: DeliveryTrackingCreateManyDeliveryBookingInput | DeliveryTrackingCreateManyDeliveryBookingInput[]
    skipDuplicates?: boolean
  }

  export type bookingsUpsertWithoutDeliveryBookingInput = {
    update: XOR<bookingsUpdateWithoutDeliveryBookingInput, bookingsUncheckedUpdateWithoutDeliveryBookingInput>
    create: XOR<bookingsCreateWithoutDeliveryBookingInput, bookingsUncheckedCreateWithoutDeliveryBookingInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutDeliveryBookingInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutDeliveryBookingInput, bookingsUncheckedUpdateWithoutDeliveryBookingInput>
  }

  export type bookingsUpdateWithoutDeliveryBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_history?: booking_historyUpdateManyWithoutBookingsNestedInput
    users?: usersUpdateOneRequiredWithoutBookingsNestedInput
    vehicles?: vehiclesUpdateOneRequiredWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutDeliveryBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_history?: booking_historyUncheckedUpdateManyWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUncheckedUpdateOneWithoutBookingsNestedInput
  }

  export type DeliveryPartnerUpsertWithoutDeliveryBookingInput = {
    update: XOR<DeliveryPartnerUpdateWithoutDeliveryBookingInput, DeliveryPartnerUncheckedUpdateWithoutDeliveryBookingInput>
    create: XOR<DeliveryPartnerCreateWithoutDeliveryBookingInput, DeliveryPartnerUncheckedCreateWithoutDeliveryBookingInput>
    where?: DeliveryPartnerWhereInput
  }

  export type DeliveryPartnerUpdateToOneWithWhereWithoutDeliveryBookingInput = {
    where?: DeliveryPartnerWhereInput
    data: XOR<DeliveryPartnerUpdateWithoutDeliveryBookingInput, DeliveryPartnerUncheckedUpdateWithoutDeliveryBookingInput>
  }

  export type DeliveryPartnerUpdateWithoutDeliveryBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutDeliveryPartnerNestedInput
  }

  export type DeliveryPartnerUncheckedUpdateWithoutDeliveryBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryTrackingUpsertWithWhereUniqueWithoutDeliveryBookingInput = {
    where: DeliveryTrackingWhereUniqueInput
    update: XOR<DeliveryTrackingUpdateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedUpdateWithoutDeliveryBookingInput>
    create: XOR<DeliveryTrackingCreateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedCreateWithoutDeliveryBookingInput>
  }

  export type DeliveryTrackingUpdateWithWhereUniqueWithoutDeliveryBookingInput = {
    where: DeliveryTrackingWhereUniqueInput
    data: XOR<DeliveryTrackingUpdateWithoutDeliveryBookingInput, DeliveryTrackingUncheckedUpdateWithoutDeliveryBookingInput>
  }

  export type DeliveryTrackingUpdateManyWithWhereWithoutDeliveryBookingInput = {
    where: DeliveryTrackingScalarWhereInput
    data: XOR<DeliveryTrackingUpdateManyMutationInput, DeliveryTrackingUncheckedUpdateManyWithoutDeliveryBookingInput>
  }

  export type DeliveryTrackingScalarWhereInput = {
    AND?: DeliveryTrackingScalarWhereInput | DeliveryTrackingScalarWhereInput[]
    OR?: DeliveryTrackingScalarWhereInput[]
    NOT?: DeliveryTrackingScalarWhereInput | DeliveryTrackingScalarWhereInput[]
    id?: UuidFilter<"DeliveryTracking"> | string
    delivery_booking_id?: UuidFilter<"DeliveryTracking"> | string
    location?: JsonFilter<"DeliveryTracking">
    timestamp?: DateTimeFilter<"DeliveryTracking"> | Date | string
    status?: StringFilter<"DeliveryTracking"> | string
    notes?: StringNullableFilter<"DeliveryTracking"> | string | null
  }

  export type DeliveryBookingCreateWithoutDeliveryPartnerInput = {
    id?: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    bookings: bookingsCreateNestedOneWithoutDeliveryBookingInput
    DeliveryTracking?: DeliveryTrackingCreateNestedManyWithoutDeliveryBookingInput
  }

  export type DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput = {
    id?: string
    booking_id: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryTracking?: DeliveryTrackingUncheckedCreateNestedManyWithoutDeliveryBookingInput
  }

  export type DeliveryBookingCreateOrConnectWithoutDeliveryPartnerInput = {
    where: DeliveryBookingWhereUniqueInput
    create: XOR<DeliveryBookingCreateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput>
  }

  export type DeliveryBookingCreateManyDeliveryPartnerInputEnvelope = {
    data: DeliveryBookingCreateManyDeliveryPartnerInput | DeliveryBookingCreateManyDeliveryPartnerInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutDeliveryPartnerInput = {
    id?: string
    name?: string | null
    email?: string | null
    password_hash?: string | null
    phone?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    is_blocked?: boolean | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bookings?: bookingsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutDeliveryPartnerInput = {
    id?: string
    name?: string | null
    email?: string | null
    password_hash?: string | null
    phone?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    is_blocked?: boolean | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bookings?: bookingsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutDeliveryPartnerInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDeliveryPartnerInput, usersUncheckedCreateWithoutDeliveryPartnerInput>
  }

  export type DeliveryBookingUpsertWithWhereUniqueWithoutDeliveryPartnerInput = {
    where: DeliveryBookingWhereUniqueInput
    update: XOR<DeliveryBookingUpdateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedUpdateWithoutDeliveryPartnerInput>
    create: XOR<DeliveryBookingCreateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedCreateWithoutDeliveryPartnerInput>
  }

  export type DeliveryBookingUpdateWithWhereUniqueWithoutDeliveryPartnerInput = {
    where: DeliveryBookingWhereUniqueInput
    data: XOR<DeliveryBookingUpdateWithoutDeliveryPartnerInput, DeliveryBookingUncheckedUpdateWithoutDeliveryPartnerInput>
  }

  export type DeliveryBookingUpdateManyWithWhereWithoutDeliveryPartnerInput = {
    where: DeliveryBookingScalarWhereInput
    data: XOR<DeliveryBookingUpdateManyMutationInput, DeliveryBookingUncheckedUpdateManyWithoutDeliveryPartnerInput>
  }

  export type DeliveryBookingScalarWhereInput = {
    AND?: DeliveryBookingScalarWhereInput | DeliveryBookingScalarWhereInput[]
    OR?: DeliveryBookingScalarWhereInput[]
    NOT?: DeliveryBookingScalarWhereInput | DeliveryBookingScalarWhereInput[]
    id?: UuidFilter<"DeliveryBooking"> | string
    delivery_partner_id?: UuidFilter<"DeliveryBooking"> | string
    booking_id?: UuidFilter<"DeliveryBooking"> | string
    pickup_location?: JsonFilter<"DeliveryBooking">
    dropoff_location?: JsonFilter<"DeliveryBooking">
    status?: StringFilter<"DeliveryBooking"> | string
    estimated_distance?: FloatFilter<"DeliveryBooking"> | number
    estimated_duration?: IntFilter<"DeliveryBooking"> | number
    actual_duration?: IntNullableFilter<"DeliveryBooking"> | number | null
    price?: FloatFilter<"DeliveryBooking"> | number
    created_at?: DateTimeFilter<"DeliveryBooking"> | Date | string
    updated_at?: DateTimeFilter<"DeliveryBooking"> | Date | string
  }

  export type usersUpsertWithoutDeliveryPartnerInput = {
    update: XOR<usersUpdateWithoutDeliveryPartnerInput, usersUncheckedUpdateWithoutDeliveryPartnerInput>
    create: XOR<usersCreateWithoutDeliveryPartnerInput, usersUncheckedCreateWithoutDeliveryPartnerInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDeliveryPartnerInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDeliveryPartnerInput, usersUncheckedUpdateWithoutDeliveryPartnerInput>
  }

  export type usersUpdateWithoutDeliveryPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: bookingsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutDeliveryPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: bookingsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type DeliveryBookingCreateWithoutDeliveryTrackingInput = {
    id?: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    bookings: bookingsCreateNestedOneWithoutDeliveryBookingInput
    DeliveryPartner: DeliveryPartnerCreateNestedOneWithoutDeliveryBookingInput
  }

  export type DeliveryBookingUncheckedCreateWithoutDeliveryTrackingInput = {
    id?: string
    delivery_partner_id: string
    booking_id: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryBookingCreateOrConnectWithoutDeliveryTrackingInput = {
    where: DeliveryBookingWhereUniqueInput
    create: XOR<DeliveryBookingCreateWithoutDeliveryTrackingInput, DeliveryBookingUncheckedCreateWithoutDeliveryTrackingInput>
  }

  export type DeliveryBookingUpsertWithoutDeliveryTrackingInput = {
    update: XOR<DeliveryBookingUpdateWithoutDeliveryTrackingInput, DeliveryBookingUncheckedUpdateWithoutDeliveryTrackingInput>
    create: XOR<DeliveryBookingCreateWithoutDeliveryTrackingInput, DeliveryBookingUncheckedCreateWithoutDeliveryTrackingInput>
    where?: DeliveryBookingWhereInput
  }

  export type DeliveryBookingUpdateToOneWithWhereWithoutDeliveryTrackingInput = {
    where?: DeliveryBookingWhereInput
    data: XOR<DeliveryBookingUpdateWithoutDeliveryTrackingInput, DeliveryBookingUncheckedUpdateWithoutDeliveryTrackingInput>
  }

  export type DeliveryBookingUpdateWithoutDeliveryTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateOneRequiredWithoutDeliveryBookingNestedInput
    DeliveryPartner?: DeliveryPartnerUpdateOneRequiredWithoutDeliveryBookingNestedInput
  }

  export type DeliveryBookingUncheckedUpdateWithoutDeliveryTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_partner_id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsCreateWithoutBooking_historyInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingCreateNestedOneWithoutBookingsInput
    users: usersCreateNestedOneWithoutBookingsInput
    vehicles: vehiclesCreateNestedOneWithoutBookingsInput
    trip_initiations?: trip_initiationsCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutBooking_historyInput = {
    id?: string
    user_id: string
    vehicle_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingUncheckedCreateNestedOneWithoutBookingsInput
    trip_initiations?: trip_initiationsUncheckedCreateNestedOneWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutBooking_historyInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutBooking_historyInput, bookingsUncheckedCreateWithoutBooking_historyInput>
  }

  export type bookingsUpsertWithoutBooking_historyInput = {
    update: XOR<bookingsUpdateWithoutBooking_historyInput, bookingsUncheckedUpdateWithoutBooking_historyInput>
    create: XOR<bookingsCreateWithoutBooking_historyInput, bookingsUncheckedCreateWithoutBooking_historyInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutBooking_historyInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutBooking_historyInput, bookingsUncheckedUpdateWithoutBooking_historyInput>
  }

  export type bookingsUpdateWithoutBooking_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUpdateOneWithoutBookingsNestedInput
    users?: usersUpdateOneRequiredWithoutBookingsNestedInput
    vehicles?: vehiclesUpdateOneRequiredWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutBooking_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUncheckedUpdateOneWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUncheckedUpdateOneWithoutBookingsNestedInput
  }

  export type DeliveryBookingCreateWithoutBookingsInput = {
    id?: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryPartner: DeliveryPartnerCreateNestedOneWithoutDeliveryBookingInput
    DeliveryTracking?: DeliveryTrackingCreateNestedManyWithoutDeliveryBookingInput
  }

  export type DeliveryBookingUncheckedCreateWithoutBookingsInput = {
    id?: string
    delivery_partner_id: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryTracking?: DeliveryTrackingUncheckedCreateNestedManyWithoutDeliveryBookingInput
  }

  export type DeliveryBookingCreateOrConnectWithoutBookingsInput = {
    where: DeliveryBookingWhereUniqueInput
    create: XOR<DeliveryBookingCreateWithoutBookingsInput, DeliveryBookingUncheckedCreateWithoutBookingsInput>
  }

  export type booking_historyCreateWithoutBookingsInput = {
    id?: string
    action: string
    details: string
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type booking_historyUncheckedCreateWithoutBookingsInput = {
    id?: string
    action: string
    details: string
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type booking_historyCreateOrConnectWithoutBookingsInput = {
    where: booking_historyWhereUniqueInput
    create: XOR<booking_historyCreateWithoutBookingsInput, booking_historyUncheckedCreateWithoutBookingsInput>
  }

  export type booking_historyCreateManyBookingsInputEnvelope = {
    data: booking_historyCreateManyBookingsInput | booking_historyCreateManyBookingsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password_hash?: string | null
    phone?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    is_blocked?: boolean | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    DeliveryPartner?: DeliveryPartnerCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    password_hash?: string | null
    phone?: string | null
    reset_token?: string | null
    reset_token_expiry?: Date | string | null
    is_blocked?: boolean | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    DeliveryPartner?: DeliveryPartnerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBookingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
  }

  export type vehiclesCreateWithoutBookingsInput = {
    id?: string
    name: string
    type: string
    location: string
    quantity: number
    price_per_hour: number
    min_booking_hours: number
    is_available?: boolean | null
    images: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    price_15_days?: number | null
    price_30_days?: number | null
    price_7_days?: number | null
    delivery_price_15_days?: number | null
    delivery_price_30_days?: number | null
    delivery_price_7_days?: number | null
    vehicle_category?: string
  }

  export type vehiclesUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    type: string
    location: string
    quantity: number
    price_per_hour: number
    min_booking_hours: number
    is_available?: boolean | null
    images: string
    status?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    price_15_days?: number | null
    price_30_days?: number | null
    price_7_days?: number | null
    delivery_price_15_days?: number | null
    delivery_price_30_days?: number | null
    delivery_price_7_days?: number | null
    vehicle_category?: string
  }

  export type vehiclesCreateOrConnectWithoutBookingsInput = {
    where: vehiclesWhereUniqueInput
    create: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
  }

  export type trip_initiationsCreateWithoutBookingsInput = {
    id?: string
    checklist_completed?: boolean
    customer_name: string
    customer_phone: string
    customer_email?: string | null
    customer_dl_number?: string | null
    customer_address?: string | null
    emergency_contact?: string | null
    emergency_name?: string | null
    customer_aadhaar_number?: string | null
    customer_dob?: string | null
    vehicle_number?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: boolean
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type trip_initiationsUncheckedCreateWithoutBookingsInput = {
    id?: string
    checklist_completed?: boolean
    customer_name: string
    customer_phone: string
    customer_email?: string | null
    customer_dl_number?: string | null
    customer_address?: string | null
    emergency_contact?: string | null
    emergency_name?: string | null
    customer_aadhaar_number?: string | null
    customer_dob?: string | null
    vehicle_number?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: boolean
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type trip_initiationsCreateOrConnectWithoutBookingsInput = {
    where: trip_initiationsWhereUniqueInput
    create: XOR<trip_initiationsCreateWithoutBookingsInput, trip_initiationsUncheckedCreateWithoutBookingsInput>
  }

  export type DeliveryBookingUpsertWithoutBookingsInput = {
    update: XOR<DeliveryBookingUpdateWithoutBookingsInput, DeliveryBookingUncheckedUpdateWithoutBookingsInput>
    create: XOR<DeliveryBookingCreateWithoutBookingsInput, DeliveryBookingUncheckedCreateWithoutBookingsInput>
    where?: DeliveryBookingWhereInput
  }

  export type DeliveryBookingUpdateToOneWithWhereWithoutBookingsInput = {
    where?: DeliveryBookingWhereInput
    data: XOR<DeliveryBookingUpdateWithoutBookingsInput, DeliveryBookingUncheckedUpdateWithoutBookingsInput>
  }

  export type DeliveryBookingUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryPartner?: DeliveryPartnerUpdateOneRequiredWithoutDeliveryBookingNestedInput
    DeliveryTracking?: DeliveryTrackingUpdateManyWithoutDeliveryBookingNestedInput
  }

  export type DeliveryBookingUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    delivery_partner_id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryTracking?: DeliveryTrackingUncheckedUpdateManyWithoutDeliveryBookingNestedInput
  }

  export type booking_historyUpsertWithWhereUniqueWithoutBookingsInput = {
    where: booking_historyWhereUniqueInput
    update: XOR<booking_historyUpdateWithoutBookingsInput, booking_historyUncheckedUpdateWithoutBookingsInput>
    create: XOR<booking_historyCreateWithoutBookingsInput, booking_historyUncheckedCreateWithoutBookingsInput>
  }

  export type booking_historyUpdateWithWhereUniqueWithoutBookingsInput = {
    where: booking_historyWhereUniqueInput
    data: XOR<booking_historyUpdateWithoutBookingsInput, booking_historyUncheckedUpdateWithoutBookingsInput>
  }

  export type booking_historyUpdateManyWithWhereWithoutBookingsInput = {
    where: booking_historyScalarWhereInput
    data: XOR<booking_historyUpdateManyMutationInput, booking_historyUncheckedUpdateManyWithoutBookingsInput>
  }

  export type booking_historyScalarWhereInput = {
    AND?: booking_historyScalarWhereInput | booking_historyScalarWhereInput[]
    OR?: booking_historyScalarWhereInput[]
    NOT?: booking_historyScalarWhereInput | booking_historyScalarWhereInput[]
    id?: UuidFilter<"booking_history"> | string
    booking_id?: UuidFilter<"booking_history"> | string
    action?: StringFilter<"booking_history"> | string
    details?: StringFilter<"booking_history"> | string
    created_by?: StringFilter<"booking_history"> | string
    created_at?: DateTimeFilter<"booking_history"> | Date | string
    updated_at?: DateTimeFilter<"booking_history"> | Date | string
  }

  export type usersUpsertWithoutBookingsInput = {
    update: XOR<usersUpdateWithoutBookingsInput, usersUncheckedUpdateWithoutBookingsInput>
    create: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBookingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBookingsInput, usersUncheckedUpdateWithoutBookingsInput>
  }

  export type usersUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeliveryPartner?: DeliveryPartnerUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_token_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_blocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DeliveryPartner?: DeliveryPartnerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type vehiclesUpsertWithoutBookingsInput = {
    update: XOR<vehiclesUpdateWithoutBookingsInput, vehiclesUncheckedUpdateWithoutBookingsInput>
    create: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
    where?: vehiclesWhereInput
  }

  export type vehiclesUpdateToOneWithWhereWithoutBookingsInput = {
    where?: vehiclesWhereInput
    data: XOR<vehiclesUpdateWithoutBookingsInput, vehiclesUncheckedUpdateWithoutBookingsInput>
  }

  export type vehiclesUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price_per_hour?: FloatFieldUpdateOperationsInput | number
    min_booking_hours?: IntFieldUpdateOperationsInput | number
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    vehicle_category?: StringFieldUpdateOperationsInput | string
  }

  export type vehiclesUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price_per_hour?: FloatFieldUpdateOperationsInput | number
    min_booking_hours?: IntFieldUpdateOperationsInput | number
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    images?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_15_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_30_days?: NullableFloatFieldUpdateOperationsInput | number | null
    delivery_price_7_days?: NullableFloatFieldUpdateOperationsInput | number | null
    vehicle_category?: StringFieldUpdateOperationsInput | string
  }

  export type trip_initiationsUpsertWithoutBookingsInput = {
    update: XOR<trip_initiationsUpdateWithoutBookingsInput, trip_initiationsUncheckedUpdateWithoutBookingsInput>
    create: XOR<trip_initiationsCreateWithoutBookingsInput, trip_initiationsUncheckedCreateWithoutBookingsInput>
    where?: trip_initiationsWhereInput
  }

  export type trip_initiationsUpdateToOneWithWhereWithoutBookingsInput = {
    where?: trip_initiationsWhereInput
    data: XOR<trip_initiationsUpdateWithoutBookingsInput, trip_initiationsUncheckedUpdateWithoutBookingsInput>
  }

  export type trip_initiationsUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklist_completed?: BoolFieldUpdateOperationsInput | boolean
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dl_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_aadhaar_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dob?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type trip_initiationsUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklist_completed?: BoolFieldUpdateOperationsInput | boolean
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    customer_email?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dl_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_contact?: NullableStringFieldUpdateOperationsInput | string | null
    emergency_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_aadhaar_number?: NullableStringFieldUpdateOperationsInput | string | null
    customer_dob?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsCreateWithoutTrip_initiationsInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyCreateNestedManyWithoutBookingsInput
    users: usersCreateNestedOneWithoutBookingsInput
    vehicles: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutTrip_initiationsInput = {
    id?: string
    user_id: string
    vehicle_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingUncheckedCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutTrip_initiationsInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutTrip_initiationsInput, bookingsUncheckedCreateWithoutTrip_initiationsInput>
  }

  export type bookingsUpsertWithoutTrip_initiationsInput = {
    update: XOR<bookingsUpdateWithoutTrip_initiationsInput, bookingsUncheckedUpdateWithoutTrip_initiationsInput>
    create: XOR<bookingsCreateWithoutTrip_initiationsInput, bookingsUncheckedCreateWithoutTrip_initiationsInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutTrip_initiationsInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutTrip_initiationsInput, bookingsUncheckedUpdateWithoutTrip_initiationsInput>
  }

  export type bookingsUpdateWithoutTrip_initiationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUpdateManyWithoutBookingsNestedInput
    users?: usersUpdateOneRequiredWithoutBookingsNestedInput
    vehicles?: vehiclesUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutTrip_initiationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUncheckedUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type DeliveryPartnerCreateWithoutUsersInput = {
    id?: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryBooking?: DeliveryBookingCreateNestedManyWithoutDeliveryPartnerInput
  }

  export type DeliveryPartnerUncheckedCreateWithoutUsersInput = {
    id?: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
    DeliveryBooking?: DeliveryBookingUncheckedCreateNestedManyWithoutDeliveryPartnerInput
  }

  export type DeliveryPartnerCreateOrConnectWithoutUsersInput = {
    where: DeliveryPartnerWhereUniqueInput
    create: XOR<DeliveryPartnerCreateWithoutUsersInput, DeliveryPartnerUncheckedCreateWithoutUsersInput>
  }

  export type DeliveryPartnerCreateManyUsersInputEnvelope = {
    data: DeliveryPartnerCreateManyUsersInput | DeliveryPartnerCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type bookingsCreateWithoutUsersInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyCreateNestedManyWithoutBookingsInput
    vehicles: vehiclesCreateNestedOneWithoutBookingsInput
    trip_initiations?: trip_initiationsCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutUsersInput = {
    id?: string
    vehicle_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingUncheckedCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyUncheckedCreateNestedManyWithoutBookingsInput
    trip_initiations?: trip_initiationsUncheckedCreateNestedOneWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutUsersInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutUsersInput, bookingsUncheckedCreateWithoutUsersInput>
  }

  export type bookingsCreateManyUsersInputEnvelope = {
    data: bookingsCreateManyUsersInput | bookingsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryPartnerUpsertWithWhereUniqueWithoutUsersInput = {
    where: DeliveryPartnerWhereUniqueInput
    update: XOR<DeliveryPartnerUpdateWithoutUsersInput, DeliveryPartnerUncheckedUpdateWithoutUsersInput>
    create: XOR<DeliveryPartnerCreateWithoutUsersInput, DeliveryPartnerUncheckedCreateWithoutUsersInput>
  }

  export type DeliveryPartnerUpdateWithWhereUniqueWithoutUsersInput = {
    where: DeliveryPartnerWhereUniqueInput
    data: XOR<DeliveryPartnerUpdateWithoutUsersInput, DeliveryPartnerUncheckedUpdateWithoutUsersInput>
  }

  export type DeliveryPartnerUpdateManyWithWhereWithoutUsersInput = {
    where: DeliveryPartnerScalarWhereInput
    data: XOR<DeliveryPartnerUpdateManyMutationInput, DeliveryPartnerUncheckedUpdateManyWithoutUsersInput>
  }

  export type DeliveryPartnerScalarWhereInput = {
    AND?: DeliveryPartnerScalarWhereInput | DeliveryPartnerScalarWhereInput[]
    OR?: DeliveryPartnerScalarWhereInput[]
    NOT?: DeliveryPartnerScalarWhereInput | DeliveryPartnerScalarWhereInput[]
    id?: UuidFilter<"DeliveryPartner"> | string
    user_id?: UuidFilter<"DeliveryPartner"> | string
    vehicle_type?: StringFilter<"DeliveryPartner"> | string
    vehicle_number?: StringFilter<"DeliveryPartner"> | string
    license_number?: StringFilter<"DeliveryPartner"> | string
    is_available?: BoolFilter<"DeliveryPartner"> | boolean
    current_location?: JsonNullableFilter<"DeliveryPartner">
    rating?: FloatFilter<"DeliveryPartner"> | number
    total_trips?: IntFilter<"DeliveryPartner"> | number
    created_at?: DateTimeFilter<"DeliveryPartner"> | Date | string
    updated_at?: DateTimeFilter<"DeliveryPartner"> | Date | string
  }

  export type bookingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutUsersInput, bookingsUncheckedUpdateWithoutUsersInput>
    create: XOR<bookingsCreateWithoutUsersInput, bookingsUncheckedCreateWithoutUsersInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutUsersInput, bookingsUncheckedUpdateWithoutUsersInput>
  }

  export type bookingsUpdateManyWithWhereWithoutUsersInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutUsersInput>
  }

  export type bookingsScalarWhereInput = {
    AND?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
    OR?: bookingsScalarWhereInput[]
    NOT?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
    id?: UuidFilter<"bookings"> | string
    user_id?: UuidFilter<"bookings"> | string
    vehicle_id?: UuidFilter<"bookings"> | string
    start_date?: DateTimeFilter<"bookings"> | Date | string
    end_date?: DateTimeFilter<"bookings"> | Date | string
    total_hours?: FloatFilter<"bookings"> | number
    total_price?: FloatFilter<"bookings"> | number
    status?: StringNullableFilter<"bookings"> | string | null
    payment_status?: StringNullableFilter<"bookings"> | string | null
    payment_details?: StringNullableFilter<"bookings"> | string | null
    created_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    pickup_location?: StringNullableFilter<"bookings"> | string | null
    dropoff_location?: StringNullableFilter<"bookings"> | string | null
    booking_id?: StringNullableFilter<"bookings"> | string | null
    payment_intent_id?: StringNullableFilter<"bookings"> | string | null
  }

  export type bookingsCreateWithoutVehiclesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyCreateNestedManyWithoutBookingsInput
    users: usersCreateNestedOneWithoutBookingsInput
    trip_initiations?: trip_initiationsCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutVehiclesInput = {
    id?: string
    user_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
    DeliveryBooking?: DeliveryBookingUncheckedCreateNestedOneWithoutBookingsInput
    booking_history?: booking_historyUncheckedCreateNestedManyWithoutBookingsInput
    trip_initiations?: trip_initiationsUncheckedCreateNestedOneWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutVehiclesInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutVehiclesInput, bookingsUncheckedCreateWithoutVehiclesInput>
  }

  export type bookingsCreateManyVehiclesInputEnvelope = {
    data: bookingsCreateManyVehiclesInput | bookingsCreateManyVehiclesInput[]
    skipDuplicates?: boolean
  }

  export type bookingsUpsertWithWhereUniqueWithoutVehiclesInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutVehiclesInput, bookingsUncheckedUpdateWithoutVehiclesInput>
    create: XOR<bookingsCreateWithoutVehiclesInput, bookingsUncheckedCreateWithoutVehiclesInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutVehiclesInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutVehiclesInput, bookingsUncheckedUpdateWithoutVehiclesInput>
  }

  export type bookingsUpdateManyWithWhereWithoutVehiclesInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutVehiclesInput>
  }

  export type DeliveryTrackingCreateManyDeliveryBookingInput = {
    id?: string
    location: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status: string
    notes?: string | null
  }

  export type DeliveryTrackingUpdateWithoutDeliveryBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryTrackingUncheckedUpdateWithoutDeliveryBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryTrackingUncheckedUpdateManyWithoutDeliveryBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryBookingCreateManyDeliveryPartnerInput = {
    id?: string
    booking_id: string
    pickup_location: JsonNullValueInput | InputJsonValue
    dropoff_location: JsonNullValueInput | InputJsonValue
    status?: string
    estimated_distance: number
    estimated_duration: number
    actual_duration?: number | null
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DeliveryBookingUpdateWithoutDeliveryPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateOneRequiredWithoutDeliveryBookingNestedInput
    DeliveryTracking?: DeliveryTrackingUpdateManyWithoutDeliveryBookingNestedInput
  }

  export type DeliveryBookingUncheckedUpdateWithoutDeliveryPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryTracking?: DeliveryTrackingUncheckedUpdateManyWithoutDeliveryBookingNestedInput
  }

  export type DeliveryBookingUncheckedUpdateManyWithoutDeliveryPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    booking_id?: StringFieldUpdateOperationsInput | string
    pickup_location?: JsonNullValueInput | InputJsonValue
    dropoff_location?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    estimated_distance?: FloatFieldUpdateOperationsInput | number
    estimated_duration?: IntFieldUpdateOperationsInput | number
    actual_duration?: NullableIntFieldUpdateOperationsInput | number | null
    price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_historyCreateManyBookingsInput = {
    id?: string
    action: string
    details: string
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type booking_historyUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_historyUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_historyUncheckedUpdateManyWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryPartnerCreateManyUsersInput = {
    id?: string
    vehicle_type: string
    vehicle_number: string
    license_number: string
    is_available?: boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: number
    total_trips?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type bookingsCreateManyUsersInput = {
    id?: string
    vehicle_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
  }

  export type DeliveryPartnerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryBooking?: DeliveryBookingUpdateManyWithoutDeliveryPartnerNestedInput
  }

  export type DeliveryPartnerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    DeliveryBooking?: DeliveryBookingUncheckedUpdateManyWithoutDeliveryPartnerNestedInput
  }

  export type DeliveryPartnerUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_type?: StringFieldUpdateOperationsInput | string
    vehicle_number?: StringFieldUpdateOperationsInput | string
    license_number?: StringFieldUpdateOperationsInput | string
    is_available?: BoolFieldUpdateOperationsInput | boolean
    current_location?: NullableJsonNullValueInput | InputJsonValue
    rating?: FloatFieldUpdateOperationsInput | number
    total_trips?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUpdateManyWithoutBookingsNestedInput
    vehicles?: vehiclesUpdateOneRequiredWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUncheckedUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUncheckedUpdateManyWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUncheckedUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookingsCreateManyVehiclesInput = {
    id?: string
    user_id: string
    start_date: Date | string
    end_date: Date | string
    total_hours: number
    total_price: number
    status?: string | null
    payment_status?: string | null
    payment_details?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    pickup_location?: string | null
    dropoff_location?: string | null
    booking_id?: string | null
    payment_intent_id?: string | null
  }

  export type bookingsUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUpdateManyWithoutBookingsNestedInput
    users?: usersUpdateOneRequiredWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    DeliveryBooking?: DeliveryBookingUncheckedUpdateOneWithoutBookingsNestedInput
    booking_history?: booking_historyUncheckedUpdateManyWithoutBookingsNestedInput
    trip_initiations?: trip_initiationsUncheckedUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total_hours?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_details?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickup_location?: NullableStringFieldUpdateOperationsInput | string | null
    dropoff_location?: NullableStringFieldUpdateOperationsInput | string | null
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}